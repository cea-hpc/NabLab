"""
DO NOT EDIT THIS FILE - it is machine generated
"""
import sys
import json
import math
import numpy as np
import dace
from dataclasses import dataclass
from dace.sdfg import SDFG
from cartesianmesh2d import CartesianMesh2D
from pvdfilewriter2d import PvdFileWriter2D

@dataclass()
class HeatEquation:
	PI = 3.1415926
	alpha = 1.0
	deltat = 0.001

	def __init__(self, mesh):
		self._mesh = mesh
		self._nbNodes = mesh.nbNodes
		self._nbCells = mesh.nbCells
		self._nbFaces = mesh.nbFaces
		self._nbNodesOfCellJ = 4

	def jsonInit(self, jsonContent):
		self._outputPath = jsonContent["outputPath"]
		self._writer = PvdFileWriter2D("HeatEquation", self._outputPath)
		self.outputPeriod = jsonContent["outputPeriod"]
		self.lastDump = -sys.maxsize - 1
		self.n = 0
		self.stopTime = jsonContent["stopTime"]
		self.maxIterations = jsonContent["maxIterations"]
		self.X = np.empty((self._nbNodes, 2), dtype=np.double)
		self.center = np.empty((self._nbCells, 2), dtype=np.double)
		self.u_n = np.empty((self._nbCells), dtype=np.double)
		self.u_nplus1 = np.empty((self._nbCells), dtype=np.double)
		self.V = np.empty((self._nbCells), dtype=np.double)
		self.f = np.empty((self._nbCells), dtype=np.double)
		self.outgoingFlux = np.empty((self._nbCells), dtype=np.double)
		self.surface = np.empty((self._nbFaces), dtype=np.double)

		# Copy node coordinates
		gNodes = mesh.geometry.nodes
		for rNodes in dace.map[0:self._nbNodes]:
			self.X[rNodes] = gNodes[rNodes]

	"""
	 Job computeOutgoingFlux called @1.0 in executeTimeLoopN method.
	 In variables: V, center, deltat, surface, u_n
	 Out variables: outgoingFlux
	"""
	@dace.method
	def _computeOutgoingFlux(self):
		startIndex = 0
		for j1Cells in range(startIndex, self._nbCells):
			j1Id = j1Cells
			reduction0 = 0.0
			neighbourCellsJ1 = mesh.getNeighbourCells(j1Id)
			nbNeighbourCellsJ1 = neighbourCellsJ1.size
			startIndex = np.count_nonzero(neighbourCellsJ1 == -1)
			for j2NeighbourCellsJ1 in range(startIndex, nbNeighbourCellsJ1):
				j2Id = neighbourCellsJ1[j2NeighbourCellsJ1]
				j2Cells = j2Id
				cfId = mesh.getCommonFace(j1Id, j2Id)
				cfFaces = cfId[0]
				reduction1 = (self.u_n[j2Cells] - self.u_n[j1Cells]) / self._norm(self._operatorSub(self.center[j2Cells], self.center[j1Cells])) * self.surface[cfFaces]
				reduction0 = self._sumR0(reduction0, reduction1)
			self.outgoingFlux[j1Cells] = self.deltat / self.V[j1Cells] * reduction0

	"""
	 Job computeSurface called @1.0 in simulate method.
	 In variables: X
	 Out variables: surface
	"""
	@dace.method
	def _computeSurface(self):
		startIndex = 0
		for fFaces in range(startIndex, self._nbFaces):
			fId = fFaces
			reduction0 = 0.0
			nodesOfFaceF = mesh.getNodesOfFace(fId)
			nbNodesOfFaceF = nodesOfFaceF.size
			startIndex = 0
			for rNodesOfFaceF in range(startIndex, nbNodesOfFaceF):
				rId = nodesOfFaceF[rNodesOfFaceF]
				rPlus1Id = nodesOfFaceF[(rNodesOfFaceF+1+nbNodesOfFaceF)%nbNodesOfFaceF]
				rNodes = rId
				rPlus1Nodes = rPlus1Id
				resultatOperatorSub = self._operatorSub(self.X[rNodes], self.X[rPlus1Nodes])
				reduction0 = self._sumR0(reduction0, self._norm(self._operatorSub(self.X[rNodes], self.X[rPlus1Nodes])))
			self.surface[fFaces] = 0.5 * reduction0

	"""
	 Job computeTn called @1.0 in executeTimeLoopN method.
	 In variables: deltat, t_n
	 Out variables: t_nplus1
	"""
	def _computeTn(self):
		self.t_nplus1 = self.t_n + self.deltat

	"""
	 Job computeV called @1.0 in simulate method.
	 In variables: X
	 Out variables: V
	"""
	@dace.method
	def _computeV(self):
		startIndex = 0
		for jCells in range(startIndex, self._nbCells):
			jId = jCells
			reduction0 = 0.0
			nodesOfCellJ = mesh.getNodesOfCell(jId)
			nbNodesOfCellJ = nodesOfCellJ.size
			startIndex = 0
			for rNodesOfCellJ in range(startIndex, nbNodesOfCellJ):
				rId = nodesOfCellJ[rNodesOfCellJ]
				rPlus1Id = nodesOfCellJ[(rNodesOfCellJ+1+nbNodesOfCellJ)%nbNodesOfCellJ]
				rNodes = rId
				rPlus1Nodes = rPlus1Id
				reduction0 = self._sumR0(reduction0, self._det(self.X[rNodes], self.X[rPlus1Nodes]))
			self.V[jCells] = 0.5 * reduction0

	"""
	 Job iniCenter called @1.0 in simulate method.
	 In variables: X
	 Out variables: center
	"""
	@dace.method
	def _iniCenter(self):
		startIndex = 0
		reduction0 = dace.ndarray([2], dtype=dace.float64)
		for jCells in range(startIndex, self._nbCells):
			jId = jCells
			for i in range(2):
				reduction0[i] = 0.0
			nodesOfCellJ = mesh.getNodesOfCell(jId)
			nbNodesOfCellJ = nodesOfCellJ.size
			startIndex = 0
			for rNodesOfCellJ in range(startIndex, nbNodesOfCellJ):
				rId = nodesOfCellJ[rNodesOfCellJ]
				rNodes = rId
				reduction0 = self._operatorAdd(reduction0, self.X)
			self.center[jCells] = self._operatorMult(0.25, reduction0)

	"""
	 Job iniF called @1.0 in simulate method.
	 In variables: 
	 Out variables: f
	"""
	@dace.method
	def _iniF(self):
		startIndex = 0
		for jCells in range(startIndex, self._nbCells):
			self.f[jCells] = 0.0

	"""
	 Job iniTime called @1.0 in simulate method.
	 In variables: 
	 Out variables: t_n0
	"""
	def _iniTime(self):
		self.t_n0 = 0.0

	"""
	 Job computeUn called @2.0 in executeTimeLoopN method.
	 In variables: deltat, f, outgoingFlux, u_n
	 Out variables: u_nplus1
	"""
	@dace.method
	def _computeUn(self):
		startIndex = 0
		for jCells in range(startIndex, self._nbCells):
			self.u_nplus1[jCells] = self.f[jCells] * self.deltat + self.u_n[jCells] + self.outgoingFlux[jCells]

	"""
	 Job iniUn called @2.0 in simulate method.
	 In variables: PI, alpha, center
	 Out variables: u_n
	"""
	@dace.method
	def _iniUn(self):
		startIndex = 0
		for jCells in range(startIndex, self._nbCells):
			self.u_n[jCells] = math.cos(2 * self.PI * self.alpha * self.center[jCells, 0])

	"""
	 Job setUpTimeLoopN called @2.0 in simulate method.
	 In variables: t_n0
	 Out variables: t_n
	"""
	def _setUpTimeLoopN(self):
		self.t_n = self.t_n0

	"""
	 Job executeTimeLoopN called @3.0 in simulate method.
	 In variables: lastDump, maxIterations, n, outputPeriod, stopTime, t_n, t_nplus1, u_n
	 Out variables: t_nplus1, u_nplus1
	"""
	def _executeTimeLoopN(self):
		self.n = 0
		self.t_n = 0.0
		continueLoop = True
		while continueLoop:
			self.n += 1
			print("START ITERATION n: %5d - t: %5.5f - deltat: %5.5f\n" % (self.n, self.t_n, self.deltat))
			if (self.n >= self.lastDump + self.outputPeriod):
				self._dumpVariables(self.n)

			self._computeOutgoingFlux() # @1.0
			self._computeTn() # @1.0
			self._computeUn() # @2.0
		
			# Evaluate loop condition with variables at time n
			continueLoop = (self.t_nplus1 < self.stopTime  and  self.n + 1 < self.maxIterations)
		
			self.t_n = self.t_nplus1
			startIndex = 0
			for i1Cells in range(startIndex, self._nbCells):
				self.u_n[i1Cells] = self.u_nplus1[i1Cells]
		
		print("FINAL TIME: %5.5f - deltat: %5.5f\n" % (self.t_n, self.deltat))
		self._dumpVariables(self.n+1);

	@dace.method
	def _det(self, a, b):
		return (a[0] * b[1] - a[1] * b[0])

	@dace.method
	def _norm(self, a):
		return math.sqrt(self._dot(a, a))

	@dace.method
	def _dot(self, a, b):
		result = 0.0
		startIndex = 0
		for i in range(startIndex, a.size):
			result = result + (a[i] * b[i])
		return result

	@dace.method
	def _sumR1(self, a, b, row):
		return self._operatorAdd(a, b, row)

	@dace.method
	def _sumR0(self, a, b):
		return a + b

	@dace.method
	def _operatorAdd(self, a, b, row):
		for ix0 in range(a.size):
			a[ix0] = a[ix0] + b[row][ix0]
		return a

	@dace.method
	def _operatorMult(self, a, b):
		result = dace.ndarray([b.size], dtype=dace.float64)
		for ix0 in range(b.size):
			result[ix0] = a * b[ix0]
		return result

	@dace.method
	def _operatorSub(self, a, b):
		result = dace.ndarray([2], dtype=dace.float64)
		startIndex = 0
		for ix0 in range(startIndex, a.size):
			result[ix0] = a[ix0] - b[ix0]
		return result

	def simulate(self):
		print("Start execution of heatEquation")
		self._computeSurface() # @1.0
		self._computeV() # @1.0
		self._iniCenter() # @1.0
		self._iniF() # @1.0
		self._iniTime() # @1.0
		self._iniUn() # @2.0
		self._setUpTimeLoopN() # @2.0
		self._executeTimeLoopN() # @3.0
		print("End of execution of heatEquation")

	def _dumpVariables(self, iteration):
		if not self._writer.disabled:
			quads = mesh.geometry.quads
			self._writer.startVtpFile(iteration, self.t_n, self.X, quads)
			self._writer.openNodeData()
			self._writer.closeNodeData()
			self._writer.openCellData()
			self._writer.openCellArray("Temperature", 0);
			for i in range(self._nbCells):
				self._writer.write(self.u_n[i])
			self._writer.closeCellArray()
			self._writer.closeCellData()
			self._writer.closeVtpFile()
			self.lastDump = self.n

if __name__ == '__main__':
	args = sys.argv[1:]
	
	if len(args) == 1:
		f = open(args[0])
		data = json.load(f)
		f.close()

		# Mesh instanciation
		mesh = CartesianMesh2D()
		mesh.jsonInit(data["mesh"])

		# Module instanciation
		heatEquation = HeatEquation(mesh)
		heatEquation.jsonInit(data["heatEquation"])

		# Start simulation
		heatEquation.simulate()
	else:
		print("[ERROR] Wrong number of arguments: expected 1, actual " + str(len(args)), file=sys.stderr)
		print("        Expecting user data file name, for example HeatEquation.json", file=sys.stderr)
		exit(1)
