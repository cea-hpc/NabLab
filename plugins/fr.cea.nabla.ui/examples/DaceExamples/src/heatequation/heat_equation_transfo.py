"""
DO NOT EDIT THIS FILE - it is machine generated
"""
import sys
import json
import numpy as np
import math
import dace
import time
import timeit
from dace.sdfg import SDFG
from dataclasses import dataclass
from cartesianmesh2d import CartesianMesh2D
from pvdfilewriter2d import PvdFileWriter2D
from dace.transformation.auto.auto_optimize import auto_optimize
from dace.transformation.dataflow import Vectorization

@dataclass()
class HeatEquation:
    PI = 3.1415926
    alpha = 1.0
    deltat = 0.001

    def __init__(self, mesh):
        self._mesh = mesh
        self._nbNodes = mesh.nbNodes
        self._nbCells = mesh.nbCells
        self._nbFaces = mesh.nbFaces

    def jsonInit(self, jsonContent):
        self._outputPath = jsonContent["outputPath"]
        self._writer = PvdFileWriter2D("HeatEquation", self._outputPath)
        self.outputPeriod = jsonContent["outputPeriod"]
        self.lastDump = -sys.maxsize - 1
        self.n = 0
        self.stopTime = jsonContent["stopTime"]
        self.maxIterations = jsonContent["maxIterations"]
        self.X = np.empty((self._nbNodes, 2), dtype=np.double)
        self.center = np.empty((self._nbCells, 2), dtype=np.double)
        self.u_n = np.empty((self._nbCells), dtype=np.double)
        self.u_nplus1 = np.empty((self._nbCells), dtype=np.double)
        self.V = np.empty((self._nbCells), dtype=np.double)
        self.f = np.empty((self._nbCells), dtype=np.double)
        self.outgoingFlux = np.empty((self._nbCells), dtype=np.double)
        self.surface = np.empty((self._nbFaces), dtype=np.double)

        # Copy node coordinates
        gNodes = mesh.geometry.nodes
        for rNodes in dace.map[0:self._nbNodes]:
            self.X[rNodes] = gNodes[rNodes]
        
    '''@dace.method(auto_optimize=True)
    def _computeCoord(self):
        gNodes = mesh.geometry.nodes
        for rNodes in dace.map[0:self._nbNodes]:
            self.X[rNodes] = gNodes[rNodes]
        return self.X'''
            
    """
     Job computeOutgoingFlux called @1.0 in executeTimeLoopN method.
     In variables: V, center, deltat, surface, u_n
     Out variables: outgoingFlux
    """
    @dace.method
    def _computeOutgoingFlux(self):
        for j1Cells in range(self._nbCells):
            j1Id = j1Cells
            reduction0 = 0.0
            neighbourCellsJ1 = mesh.getNeighbourCells(j1Id)
            tmpArray = neighbourCellsJ1
            nbNeighbourCellsJ1 = neighbourCellsJ1.size
            if(neighbourCellsJ1[0]==-1):
                if(neighbourCellsJ1[1]==-1):
                    for j2NeighbourCellsJ1 in range(2,nbNeighbourCellsJ1):
                        j2Id = neighbourCellsJ1[j2NeighbourCellsJ1]
                        j2Cells = j2Id
                        cfId = mesh.getCommonFace(j1Id, j2Id)
                        cfFaces = cfId
                        reduction1 = (self.u_n[j2Cells] - self.u_n[j1Cells]) / self._norm(self._operatorSub(self.center[j2Cells], self.center[j1Cells])) * self.surface[cfFaces[0]]
                        reduction0 = self._sumR0(reduction0, reduction1)
                    self.outgoingFlux[j1Cells] = self.deltat / self.V[j1Cells] * reduction0
                else:
                    for j2NeighbourCellsJ1 in range(1,nbNeighbourCellsJ1):
                        j2Id = neighbourCellsJ1[j2NeighbourCellsJ1]
                        j2Cells = j2Id
                        cfId = mesh.getCommonFace(j1Id, j2Id)
                        cfFaces = cfId
                        reduction1 = (self.u_n[j2Cells] - self.u_n[j1Cells]) / self._norm(self._operatorSub(self.center[j2Cells], self.center[j1Cells])) * self.surface[cfFaces[0]]
                        reduction0 = self._sumR0(reduction0, reduction1)
                    self.outgoingFlux[j1Cells] = self.deltat / self.V[j1Cells] * reduction0
                    
            else:
                for j2NeighbourCellsJ1 in range(nbNeighbourCellsJ1):
                    j2Id = neighbourCellsJ1[j2NeighbourCellsJ1]
                    j2Cells = j2Id
                    cfId = mesh.getCommonFace(j1Id, j2Id)
                    cfFaces = cfId
                    reduction1 = (self.u_n[j2Cells] - self.u_n[j1Cells]) / self._norm(self._operatorSub(self.center[j2Cells], self.center[j1Cells])) * self.surface[cfFaces[0]]
                    reduction0 = self._sumR0(reduction0, reduction1)
                self.outgoingFlux[j1Cells] = self.deltat / self.V[j1Cells] * reduction0
        return self.outgoingFlux
            
    
    """
     Job computeSurface called @1.0 in simulate method.
     In variables: X
     Out variables: surface
    """
    @dace.method
    def _computeSurface(self):
        for fFaces in range(self._nbFaces):
            fId = fFaces
            reduction0 = 0.0
            nodesOfFaceF = mesh.getNodesOfFace(fId)
            nbNodesOfFaceF = nodesOfFaceF.size
            for rNodesOfFaceF in range(nbNodesOfFaceF):
                rId = nodesOfFaceF[rNodesOfFaceF]
                rPlus1Id = nodesOfFaceF[(rNodesOfFaceF+1+nbNodesOfFaceF)%nbNodesOfFaceF]
                rNodes = rId
                rPlus1Nodes = rPlus1Id
                resultatOperatorSub = self._operatorSub(self.X[rNodes], self.X[rPlus1Nodes])
                reduction0 = self._sumR0(reduction0, self._norm(self._operatorSub(self.X[rNodes], self.X[rPlus1Nodes])))
            self.surface[fFaces] = 0.5 * reduction0 
        return self.surface
            
    """
     Job computeTn called @1.0 in executeTimeLoopN method.
     In variables: deltat, t_n
     Out variables: t_nplus1
    """
    def _computeTn(self):
        self.t_nplus1 = self.t_n + self.deltat
    
    """
     Job computeV called @1.0 in simulate method.
     In variables: X
     Out variables: V
    """       
    @dace.method
    def _computeV(self):
        for jCells in range(self._nbCells):
            jId = jCells
            reduction0 = 0.0
            nodesOfCellJ = mesh.getNodesOfCell(jId)
            nbNodesOfCellJ = nodesOfCellJ.size
            for rNodesOfCellJ in range(nbNodesOfCellJ):
                rId = nodesOfCellJ[rNodesOfCellJ]
                rPlus1Id = nodesOfCellJ[(rNodesOfCellJ+1+nbNodesOfCellJ)%nbNodesOfCellJ]
                rNodes = rId
                rPlus1Nodes = rPlus1Id
                reduction0 = self._sumR0(reduction0, self._det(self.X[rNodes], self.X[rPlus1Nodes]))
            self.V[jCells] = 0.5 * reduction0   
        print("self.V , ", self.V)
    
    """
     Job iniCenter called @1.0 in simulate method.
     In variables: X
     Out variables: center
    """   
    @dace.method
    def _iniCenter(self):
        reduction0 = dace.ndarray([2], dtype=dace.float64)
        for jCells in range(self._nbCells):
            jId = jCells
            for i in range(2):
                reduction0[i] = 0.0
            nodesOfCellJ = mesh.getNodesOfCell(jId)
            nbNodesOfCellJ = nodesOfCellJ.size
            for rNodesOfCellJ in range(nbNodesOfCellJ):
                rId = nodesOfCellJ[rNodesOfCellJ]
                rNodes = rId
                reduction0 = self._operatorAdd(reduction0, self.X, rNodes)
            self.center[jCells] = self._operatorMult(0.25, reduction0)
        return self.center
    
    
    """
     Job iniF called @1.0 in simulate method.
     In variables: 
     Out variables: f
    """           
    @dace.method
    def _iniF(self):
        for jCells in range(self._nbCells):
            self.f[jCells] = 0.0
            
    """
     Job iniTime called @1.0 in simulate method.
     In variables: 
     Out variables: t_n0
    """
    def _iniTime(self):
        self.t_n0 = 0.0
        
    """
     Job computeUn called @2.0 in executeTimeLoopN method.
     In variables: deltat, f, outgoingFlux, u_n
     Out variables: u_nplus1
    """
    @dace.method
    def _computeUn(self):
        for jCells in range(self._nbCells):
            self.u_nplus1[jCells] = self.f[jCells] * self.deltat + self.u_n[jCells] + self.outgoingFlux[jCells]
        print("self.u_nplus1 : ",self.u_nplus1)
    
    """
     Job iniUn called @2.0 in simulate method.
     In variables: PI, alpha, center
     Out variables: u_n
    """
    @dace.method
    def _iniUn(self):
        for jCells in range(self._nbCells):
            self.u_n[jCells] = math.cos(2* self.PI * self.alpha * self.center[jCells, 0])
        return self.u_n
    
    """
     Job setUpTimeLoopN called @2.0 in simulate method.
     In variables: t_n0
     Out variables: t_n
    """        
    def _setUpTimeLoopN(self):
        self.t_n = self.t_n0
    
    """
     Job executeTimeLoopN called @3.0 in simulate method.
     In variables: lastDump, maxIterations, n, outputPeriod, stopTime, t_n, t_nplus1, u_n
     Out variables: t_nplus1, u_nplus1
    """           
    def _executeTimeLoopN(self):
        self.n = 0
        self.t_n = 0.0
        continueLoop = True
        while continueLoop:
            self.n += 1 
            print("START ITERATION n: %5d - t: %5.5f - deltat: %5.5f\n" % (self.n, self.t_n, self.deltat))
            if (self.n >= self.lastDump + self.outputPeriod):
                self._dumpVariables(self.n)
            self._computeOutgoingFlux() # @1.0
            self._computeTn() # @1.0
            self._computeUn() # @2.0
        
            # Evaluate loop condition with variables at time n
            continueLoop = (self.t_nplus1 < self.stopTime  and  self.n + 1 < self.maxIterations)
        
            self.t_n = self.t_nplus1
            for i1Cells in range(self._nbCells):
                self.u_n[i1Cells] = self.u_nplus1[i1Cells]
        
        print("FINAL TIME: %5.5f - deltat: %5.5f\n" % (self.t_n, self.deltat))
        self._dumpVariables(self.n+1);
        
    @dace.method(auto_optimize=True)
    def _det(self, a, b):
        return (a[0] * b[1] - a[1] * b[0])
    
    @dace.method(auto_optimize=True)
    def _norm(self, a):
        result = math.sqrt(self._dot(a, a))
        return result
    
    @dace.method(auto_optimize=True)
    def _dot(self, a, b):
        result = 0.0
        for i in range(a.size):
            result = result + (a[i] * b[i])
        return result

    @dace.method(auto_optimize=True)
    def _sumR1(self, a, b, row):
        return self._operatorAdd(a, b, row)
    
    @dace.method(auto_optimize=True)
    def _sumR0(self, a, b): 
        return a + b
    
    @dace.method(auto_optimize=True)
    def _operatorAdd(self, a, b, row):
        for ix0 in range(a.size):
            a[ix0] = a[ix0] + b[row][ix0]
        return a
    
    @dace.method(auto_optimize=True)
    def _operatorMult(self, a, b):
        result = dace.ndarray([b.size], dtype=dace.float64)
        for ix0 in dace.map[0:b.size]:
            result[ix0] = a*b[ix0]
        return result
    
    @dace.method(auto_optimize=True)
    def _operatorSub(self, a, b):
        result = dace.ndarray([2], dtype=dace.float64)
        for ix0 in range(a.size):
            result[ix0] = a[ix0] - b[ix0]
        return result
    
    def simulate(self):
        print("Start execution of heatEquation")
        self._computeSurface() # @1.0
        self._computeV() # @1.0
        self._iniCenter() # @1.0
        self._iniF() # @1.0
        self._iniTime() # @1.0
        self._iniUn() # @2.0
        self._setUpTimeLoopN() # @2.0
        self._executeTimeLoopN() # @3.0
        print("End of execution of heatEquation")
        
    def test_vectorization(self):
        '''sdfgComputeCoord: dace.SDFG = self._computeCoord.to_sdfg()
        sdfgComputeCoord.apply_transformations(Vectorization)
        sdfgComputeCoord.validate()
        csdfgComputeCoord = sdfgComputeCoord.compile()
        csdfgComputeCoord()'''
        
        sdfgComputeSurface = self._computeSurface.to_sdfg()
        sdfgComputeSurface.apply_transformations(Vectorization)
        #csdfgComputeSurface = sdfgComputeSurface.compile()
        sdfgComputeSurface.compile()
        #csdfgComputeSurface()
        #print(self.surface)
        
        '''sdfgComputeV: dace.SDFG = self._computeV.to_sdfg()
        sdfgComputeV.apply_transformations(Vectorization)
        csdfgComputeV = sdfgComputeV.compile()
        csdfgComputeV()'''

    def _dumpVariables(self, iteration):
        if not self._writer.disabled:
            quads = mesh.geometry.quads
            self._writer.startVtpFile(iteration, self.t_n, self.X, quads)
            self._writer.openNodeData()
            self._writer.closeNodeData()
            self._writer.openCellData()
            self._writer.openCellArray("Temperature", 0);
            for i in range(self._nbCells):
                self._writer.write(self.u_n[i])
            self._writer.closeCellArray()
            self._writer.closeCellData()
            self._writer.closeVtpFile()
            self.lastDump = self.n

if __name__ == '__main__':
    args = sys.argv[1:]
    
    if len(args) == 1:
        f = open(args[0])
        data = json.load(f)
        f.close()

        # Mesh instanciation
        mesh = CartesianMesh2D()
        mesh.jsonInit(data["mesh"])

        # Module instanciation
        heatEquation = HeatEquation(mesh)
        heatEquation.jsonInit(data["heatEquation"])

        # Start simulation
        heatEquation.simulate()
        #execution_time = timeit.timeit("heatEquation.simulate()", setup="from __main__ import heatEquation", number=100)
        #print("execution_time : ", execution_time, "seconds")
        
        raw_time_list = timeit.repeat(stmt="heatEquation.simulate()", setup="from __main__ import heatEquation", repeat=100)
        raw_time = np.median(raw_time_list)
        print("execution_time : ", raw_time, "seconds")
        
        heatEquation.test_vectorization()

    else:
        print("[ERROR] Wrong number of arguments: expected 1, actual " + str(len(args)), file=sys.stderr)
        print("        Expecting user data file name, for example HeatEquation.json", file=sys.stderr)
        exit(1)