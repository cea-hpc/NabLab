/* DO NOT EDIT THIS FILE - it is machine generated */

#include "ExplicitHeatEquationModule.h"
#include <arcane/Concurrency.h>
#include <arcane/ITimeLoopMng.h>

using namespace Arcane;

/*** Free functions **********************************************************/

namespace explicitheatequationfreefuncs
{
	Real norm(RealArrayVariant a)
	{
		return std::sqrt(explicitheatequationfreefuncs::dot(a, a));
	}
	
	Real dot(RealArrayVariant a, RealArrayVariant b)
	{
		Real result(0.0);
		for (Int32 i=0; i<a.size(); i++)
		{
			result = result + a(i) * b(i);
		}
		return result;
	}
	
	Real det(RealArrayVariant a, RealArrayVariant b)
	{
		return (a[0] * b[1] - a[1] * b[0]);
	}
	
	RealArrayVariant sumR1(RealArrayVariant a, RealArrayVariant b)
	{
		return explicitheatequationfreefuncs::operatorAdd(a, b);
	}
	
	Real minR0(Real a, Real b)
	{
		return std::min(a, b);
	}
	
	Real sumR0(Real a, Real b)
	{
		return a + b;
	}
	
	Real prodR0(Real a, Real b)
	{
		return a * b;
	}
	
	RealArrayVariant operatorAdd(RealArrayVariant a, RealArrayVariant b)
	{
		NumArray<Real,MDDim1> result(a.size());
		for (Int32 ix0=0; ix0<a.size(); ix0++)
		{
			result(ix0) = a(ix0) + b(ix0);
		}
		return result;
	}
	
	RealArrayVariant operatorMult(Real a, RealArrayVariant b)
	{
		NumArray<Real,MDDim1> result(b.size());
		for (Int32 ix0=0; ix0<b.size(); ix0++)
		{
			result(ix0) = a * b(ix0);
		}
		return result;
	}
	
	RealArrayVariant operatorSub(RealArrayVariant a, RealArrayVariant b)
	{
		NumArray<Real,MDDim1> result(a.size());
		for (Int32 ix0=0; ix0<a.size(); ix0++)
		{
			result(ix0) = a(ix0) - b(ix0);
		}
		return result;
	}
}

/*** Module/Service **********************************************************/

ExplicitHeatEquationModule::ExplicitHeatEquationModule(const ModuleBuildInfo& bi)
: ArcaneExplicitHeatEquationObject(bi)
, m_default_queue(subDomain()->acceleratorMng()->defaultQueue())
{}

void ExplicitHeatEquationModule::init()
{
	// initialization of mesh attributes
	m_mesh = CartesianMesh2D::createInstance(mesh());

	// initialization of other attributes
	m_lastDump = numeric_limits<int>::min();
	m_n = 0;
	m_delta_t = 0.001;
	m_alpha.resize(nbCell());

	// calling jobs
	computeFaceLength(); // @1.0
	computeV(); // @1.0
	initD(); // @1.0
	initTime(); // @1.0
	initXc(); // @1.0
	computeDeltaTn(); // @2.0
	computeFaceConductivity(); // @2.0
	initU(); // @2.0
	setUpTimeLoopN(); // @2.0
	computeAlphaCoeff(); // @3.0
}

/**
 * Job computeFaceLength called @1.0 in simulate method.
 * In variables: X
 * Out variables: faceLength
 */
void ExplicitHeatEquationModule::computeFaceLength()
{
	auto command = makeCommand(m_default_queue);
	auto in_X = ax::viewIn(command, m_X);
	auto out_faceLength = ax::viewOut(command, m_faceLength);
	command << RUNCOMMAND_ENUMERATE(Face, fFaces, allFaces())
	{
		const auto fId(fFaces);
		Real reduction0(0.0);
		{
			const auto nodesOfFaceF(m_mesh->getNodesOfFace(fId));
			const Int32 nbNodesOfFaceF(nodesOfFaceF.size());
			for (Int32 pNodesOfFaceF=0; pNodesOfFaceF<nbNodesOfFaceF; pNodesOfFaceF++)
			{
				const auto pId(nodesOfFaceF[pNodesOfFaceF]);
				const auto pPlus1Id(nodesOfFaceF[(pNodesOfFaceF+1+nbNodesOfFaceF)%nbNodesOfFaceF]);
				const auto pNodes(pId);
				const auto pPlus1Nodes(pPlus1Id);
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operatorSub(in_X[pNodes], in_X[pPlus1Nodes])));
			}
		}
		out_faceLength[fFaces] = 0.5 * reduction0;
	};
}

/**
 * Job computeTn called @1.0 in executeTimeLoopN method.
 * In variables: delta_t, t_n
 * Out variables: t_nplus1
 */
void ExplicitHeatEquationModule::computeTn()
{
	m_t_nplus1 = m_t_n + m_delta_t;
}

/**
 * Job computeV called @1.0 in simulate method.
 * In variables: X
 * Out variables: V
 */
void ExplicitHeatEquationModule::computeV()
{
	auto command = makeCommand(m_default_queue);
	auto in_X = ax::viewIn(command, m_X);
	auto out_V = ax::viewOut(command, m_V);
	command << RUNCOMMAND_ENUMERATE(Cell, cCells, allCells())
	{
		const auto cId(cCells);
		Real reduction0(0.0);
		{
			const auto nodesOfCellC(m_mesh->getNodesOfCell(cId));
			const Int32 nbNodesOfCellC(nodesOfCellC.size());
			for (Int32 pNodesOfCellC=0; pNodesOfCellC<nbNodesOfCellC; pNodesOfCellC++)
			{
				const auto pId(nodesOfCellC[pNodesOfCellC]);
				const auto pPlus1Id(nodesOfCellC[(pNodesOfCellC+1+nbNodesOfCellC)%nbNodesOfCellC]);
				const auto pNodes(pId);
				const auto pPlus1Nodes(pPlus1Id);
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::det(in_X[pNodes], in_X[pPlus1Nodes]));
			}
		}
		out_V[cCells] = 0.5 * reduction0;
	};
}

/**
 * Job initD called @1.0 in simulate method.
 * In variables: 
 * Out variables: D
 */
void ExplicitHeatEquationModule::initD()
{
	auto command = makeCommand(m_default_queue);
	auto out_D = ax::viewOut(command, m_D);
	command << RUNCOMMAND_ENUMERATE(Cell, cCells, allCells())
	{
		out_D[cCells] = 1.0;
	};
}

/**
 * Job initTime called @1.0 in simulate method.
 * In variables: 
 * Out variables: t_n0
 */
void ExplicitHeatEquationModule::initTime()
{
	m_t_n0 = 0.0;
}

/**
 * Job initXc called @1.0 in simulate method.
 * In variables: X
 * Out variables: Xc
 */
void ExplicitHeatEquationModule::initXc()
{
	auto command = makeCommand(m_default_queue);
	auto in_X = ax::viewIn(command, m_X);
	auto out_Xc = ax::viewOut(command, m_Xc);
	command << RUNCOMMAND_ENUMERATE(Cell, cCells, allCells())
	{
		const auto cId(cCells);
		Real2 reduction0{0.0, 0.0};
		{
			const auto nodesOfCellC(m_mesh->getNodesOfCell(cId));
			const Int32 nbNodesOfCellC(nodesOfCellC.size());
			for (Int32 pNodesOfCellC=0; pNodesOfCellC<nbNodesOfCellC; pNodesOfCellC++)
			{
				const auto pId(nodesOfCellC[pNodesOfCellC]);
				const auto pNodes(pId);
				reduction0 = explicitheatequationfreefuncs::sumR1(reduction0, in_X[pNodes]);
			}
		}
		out_Xc[cCells] = explicitheatequationfreefuncs::operatorMult(0.25, reduction0);
	};
}

/**
 * Job updateU called @1.0 in executeTimeLoopN method.
 * In variables: alpha, u_n
 * Out variables: u_nplus1
 */
void ExplicitHeatEquationModule::updateU()
{
	auto command = makeCommand(m_default_queue);
	auto in_alpha = ax::viewIn(command, m_alpha);
	auto in_u_n = ax::viewIn(command, m_u_n);
	auto out_u_nplus1 = ax::viewOut(command, m_u_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, cCells, allCells())
	{
		const auto cId(cCells);
		Real reduction0(0.0);
		{
			const auto neighbourCellsC(m_mesh->getNeighbourCells(cId));
			const Int32 nbNeighbourCellsC(neighbourCellsC.size());
			for (Int32 dNeighbourCellsC=0; dNeighbourCellsC<nbNeighbourCellsC; dNeighbourCellsC++)
			{
				const auto dId(neighbourCellsC[dNeighbourCellsC]);
				const auto dCells(dId);
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, in_alpha[cCells][dCells] * in_u_n[dCells]);
			}
		}
		out_u_nplus1[cCells] = in_alpha[cCells][cCells] * in_u_n[cCells] + reduction0;
	};
}

/**
 * Job computeDeltaTn called @2.0 in simulate method.
 * In variables: D, V
 * Out variables: delta_t
 */
void ExplicitHeatEquationModule::computeDeltaTn()
{
	Real reduction0(numeric_limits<double>::max());
	{
		auto command = makeCommand(m_default_queue);
		auto in_V = ax::viewIn(command, m_V);
		auto in_D = ax::viewIn(command, m_D);
		ax::ReducerMin<Real> reducer(command);
		command << RUNCOMMAND_ENUMERATE(Cell, cCells, allCells())
		{
			reducer.min(in_V[cCells] / in_D[cCells]);
		};
		reduction0 = reducer.reduce();
	}
	m_delta_t = reduction0 * 0.24;
	m_global_deltat = m_delta_t;
}

/**
 * Job computeFaceConductivity called @2.0 in simulate method.
 * In variables: D
 * Out variables: faceConductivity
 */
void ExplicitHeatEquationModule::computeFaceConductivity()
{
	auto command = makeCommand(m_default_queue);
	auto in_D = ax::viewIn(command, m_D);
	auto out_faceConductivity = ax::viewOut(command, m_faceConductivity);
	command << RUNCOMMAND_ENUMERATE(Face, fFaces, allFaces())
	{
		const auto fId(fFaces);
		Real reduction0(1.0);
		{
			const auto cellsOfFaceF(m_mesh->getCellsOfFace(fId));
			const Int32 nbCellsOfFaceF(cellsOfFaceF.size());
			for (Int32 c1CellsOfFaceF=0; c1CellsOfFaceF<nbCellsOfFaceF; c1CellsOfFaceF++)
			{
				const auto c1Id(cellsOfFaceF[c1CellsOfFaceF]);
				const auto c1Cells(c1Id);
				reduction0 = explicitheatequationfreefuncs::prodR0(reduction0, in_D[c1Cells]);
			}
		}
		Real reduction1(0.0);
		{
			const auto cellsOfFaceF(m_mesh->getCellsOfFace(fId));
			const Int32 nbCellsOfFaceF(cellsOfFaceF.size());
			for (Int32 c2CellsOfFaceF=0; c2CellsOfFaceF<nbCellsOfFaceF; c2CellsOfFaceF++)
			{
				const auto c2Id(cellsOfFaceF[c2CellsOfFaceF]);
				const auto c2Cells(c2Id);
				reduction1 = explicitheatequationfreefuncs::sumR0(reduction1, in_D[c2Cells]);
			}
		}
		out_faceConductivity[fFaces] = 2.0 * reduction0 / reduction1;
	};
}

/**
 * Job initU called @2.0 in simulate method.
 * In variables: Xc, u0, vectOne
 * Out variables: u_n
 */
void ExplicitHeatEquationModule::initU()
{
	auto command = makeCommand(m_default_queue);
	auto in_Xc = ax::viewIn(command, m_Xc);
	auto in_vectOne = m_vectOne;
	auto in_u0 = m_u0;
	auto out_u_n = ax::viewOut(command, m_u_n);
	command << RUNCOMMAND_ENUMERATE(Cell, cCells, allCells())
	{
		if (explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operatorSub(in_Xc[cCells], in_vectOne)) < 0.5) 
			out_u_n[cCells] = in_u0;
		else
			out_u_n[cCells] = 0.0;
	};
}

/**
 * Job setUpTimeLoopN called @2.0 in simulate method.
 * In variables: t_n0
 * Out variables: t_n
 */
void ExplicitHeatEquationModule::setUpTimeLoopN()
{
	m_t_n = m_t_n0;
}

/**
 * Job computeAlphaCoeff called @3.0 in simulate method.
 * In variables: V, Xc, delta_t, faceConductivity, faceLength
 * Out variables: alpha
 */
void ExplicitHeatEquationModule::computeAlphaCoeff()
{
	auto command = makeCommand(m_default_queue);
	auto in_delta_t = m_delta_t;
	auto in_V = ax::viewIn(command, m_V);
	auto in_faceLength = ax::viewIn(command, m_faceLength);
	auto in_faceConductivity = ax::viewIn(command, m_faceConductivity);
	auto in_Xc = ax::viewIn(command, m_Xc);
	auto out_alpha = ax::viewOut(command, m_alpha);
	command << RUNCOMMAND_ENUMERATE(Cell, cCells, allCells())
	{
		const auto cId(cCells);
		Real alpha_Diag(0.0);
		{
			const auto neighbourCellsC(m_mesh->getNeighbourCells(cId));
			const Int32 nbNeighbourCellsC(neighbourCellsC.size());
			for (Int32 dNeighbourCellsC=0; dNeighbourCellsC<nbNeighbourCellsC; dNeighbourCellsC++)
			{
				const auto dId(neighbourCellsC[dNeighbourCellsC]);
				const auto dCells(dId);
				const auto fId(m_mesh->getCommonFace(cId, dId));
				const auto fFaces(fId);
				const Real alpha_ExtraDiag(in_delta_t / in_V[cCells] * (in_faceLength[fFaces] * in_faceConductivity[fFaces]) / explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operatorSub(in_Xc[cCells], in_Xc[dCells])));
				out_alpha[cCells][dCells] = alpha_ExtraDiag;
				alpha_Diag = alpha_Diag + alpha_ExtraDiag;
			}
		}
		out_alpha[cCells][cCells] = 1 - alpha_Diag;
	};
}

/**
 * Job executeTimeLoopN called @4.0 in simulate method.
 * In variables: lastDump, maxIterations, n, outputPeriod, stopTime, t_n, t_nplus1, u_n
 * Out variables: t_nplus1, u_nplus1
 */
void ExplicitHeatEquationModule::executeTimeLoopN()
{
	m_n++;
	computeTn(); // @1.0
	updateU(); // @1.0
	
	// Evaluate loop condition with variables at time n
	bool continueLoop = (m_t_nplus1 < options()->stopTime() && m_n + 1 < options()->maxIterations());
	
	m_t_n = m_t_nplus1;
	{
		auto command = makeCommand(m_default_queue);
		auto in_u_nplus1 = ax::viewIn(command, m_u_nplus1);
		auto out_u_n = ax::viewOut(command, m_u_n);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			out_u_n[i1Cells] = in_u_nplus1[i1Cells];
		};
	}
	
	if (!continueLoop)
		subDomain()->timeLoopMng()->stopComputeLoop(true);
}

ARCANE_REGISTER_MODULE_EXPLICITHEATEQUATION(ExplicitHeatEquationModule);
