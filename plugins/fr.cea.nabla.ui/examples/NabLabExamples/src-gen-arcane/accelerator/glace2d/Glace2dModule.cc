/* DO NOT EDIT THIS FILE - it is machine generated */

#include "Glace2dModule.h"
#include <arcane/Concurrency.h>
#include <arcane/ITimeLoopMng.h>

using namespace Arcane;

/*** Free functions **********************************************************/

namespace glace2dfreefuncs
{
	Real det(RealArray2Variant a)
	{
		return a[0][0] * a[1][1] - a[0][1] * a[1][0];
	}
	
	RealArrayVariant perp(RealArrayVariant a)
	{
		return Real2{a[1], -a[0]};
	}
	
	Real dot(RealArrayVariant a, RealArrayVariant b)
	{
		Real result(0.0);
		for (Int32 i=0; i<a.size(); i++)
		{
			result = result + a(i) * b(i);
		}
		return result;
	}
	
	Real norm(RealArrayVariant a)
	{
		return std::sqrt(glace2dfreefuncs::dot(a, a));
	}
	
	RealArray2Variant tensProduct(RealArrayVariant a, RealArrayVariant b)
	{
		NumArray<Real,MDDim2> result(a.size(), a.size());
		for (Int32 ia=0; ia<a.size(); ia++)
		{
			for (Int32 ib=0; ib<a.size(); ib++)
			{
				result(ia, ib) = a(ia) * b(ib);
			}
		}
		return result;
	}
	
	RealArrayVariant matVectProduct(RealArray2Variant a, RealArrayVariant b)
	{
		NumArray<Real,MDDim1> result(a.dim1Size());
		for (Int32 ix=0; ix<a.dim1Size(); ix++)
		{
			NumArray<Real,MDDim1> tmp(a.dim2Size());
			for (Int32 iy=0; iy<a.dim2Size(); iy++)
			{
				tmp(iy) = a(ix, iy);
			}
			result(ix) = glace2dfreefuncs::dot(tmp, b);
		}
		return result;
	}
	
	Real trace(RealArray2Variant a)
	{
		Real result(0.0);
		for (Int32 ia=0; ia<a.dim1Size(); ia++)
		{
			result = result + a(ia, ia);
		}
		return result;
	}
	
	RealArray2Variant inverse(RealArray2Variant a)
	{
		const Real alpha(1.0 / glace2dfreefuncs::det(a));
		return Real2x2{Real2{a[1][1] * alpha, -a[0][1] * alpha}, Real2{-a[1][0] * alpha, a[0][0] * alpha}};
	}
	
	RealArrayVariant sumR1(RealArrayVariant a, RealArrayVariant b)
	{
		return glace2dfreefuncs::operatorAdd(a, b);
	}
	
	Real sumR0(Real a, Real b)
	{
		return a + b;
	}
	
	RealArray2Variant sumR2(RealArray2Variant a, RealArray2Variant b)
	{
		return glace2dfreefuncs::operatorAdd(a, b);
	}
	
	Real minR0(Real a, Real b)
	{
		return std::min(a, b);
	}
	
	RealArrayVariant operatorAdd(RealArrayVariant a, RealArrayVariant b)
	{
		NumArray<Real,MDDim1> result(a.size());
		for (Int32 ix0=0; ix0<a.size(); ix0++)
		{
			result(ix0) = a(ix0) + b(ix0);
		}
		return result;
	}
	
	RealArray2Variant operatorAdd(RealArray2Variant a, RealArray2Variant b)
	{
		NumArray<Real,MDDim2> result(a.dim1Size(), a.dim2Size());
		for (Int32 ix0=0; ix0<a.dim1Size(); ix0++)
		{
			for (Int32 ix1=0; ix1<a.dim2Size(); ix1++)
			{
				result(ix0, ix1) = a(ix0, ix1) + b(ix0, ix1);
			}
		}
		return result;
	}
	
	RealArrayVariant operatorMult(Real a, RealArrayVariant b)
	{
		NumArray<Real,MDDim1> result(b.size());
		for (Int32 ix0=0; ix0<b.size(); ix0++)
		{
			result(ix0) = a * b(ix0);
		}
		return result;
	}
	
	RealArrayVariant operatorSub(RealArrayVariant a, RealArrayVariant b)
	{
		NumArray<Real,MDDim1> result(a.size());
		for (Int32 ix0=0; ix0<a.size(); ix0++)
		{
			result(ix0) = a(ix0) - b(ix0);
		}
		return result;
	}
	
	RealArray2Variant operatorMult(Real a, RealArray2Variant b)
	{
		NumArray<Real,MDDim2> result(b.dim1Size(), b.dim2Size());
		for (Int32 ix0=0; ix0<b.dim1Size(); ix0++)
		{
			for (Int32 ix1=0; ix1<b.dim2Size(); ix1++)
			{
				result(ix0, ix1) = a * b(ix0, ix1);
			}
		}
		return result;
	}
	
	RealArray2Variant operatorSub(RealArray2Variant a, RealArray2Variant b)
	{
		NumArray<Real,MDDim2> result(a.dim1Size(), a.dim2Size());
		for (Int32 ix0=0; ix0<a.dim1Size(); ix0++)
		{
			for (Int32 ix1=0; ix1<a.dim2Size(); ix1++)
			{
				result(ix0, ix1) = a(ix0, ix1) - b(ix0, ix1);
			}
		}
		return result;
	}
	
	RealArray2Variant operatorMult(RealArray2Variant a, RealArray2Variant b)
	{
		NumArray<Real,MDDim2> result(a.dim1Size(), a.dim2Size());
		for (Int32 ix0=0; ix0<a.dim1Size(); ix0++)
		{
			for (Int32 ix1=0; ix1<a.dim2Size(); ix1++)
			{
				result(ix0, ix1) = a(ix0, ix1) * b(ix0, ix1);
			}
		}
		return result;
	}
	
	RealArray2Variant operatorMult(RealArray2Variant a, Real b)
	{
		NumArray<Real,MDDim2> result(a.dim1Size(), a.dim2Size());
		for (Int32 ix0=0; ix0<a.dim1Size(); ix0++)
		{
			for (Int32 ix1=0; ix1<a.dim2Size(); ix1++)
			{
				result(ix0, ix1) = a(ix0, ix1) * b;
			}
		}
		return result;
	}
}

/*** Module/Service **********************************************************/

Glace2dModule::Glace2dModule(const ModuleBuildInfo& bi)
: ArcaneGlace2dObject(bi)
, m_default_queue(subDomain()->acceleratorMng()->defaultQueue())
{}

void Glace2dModule::init()
{
	// initialization of mesh attributes
	m_mesh = CartesianMesh2D::createInstance(mesh());

	// initialization of other attributes
	m_lastDump = numeric_limits<int>::min();
	m_n = 0;
	m_l.resize(4);
	m_Cjr_ic.resize(4);
	m_C.resize(4);
	m_F.resize(4);
	m_Ajr.resize(4);

	// Copy node coordinates
	ENUMERATE_NODE(inode, allNodes())
	{
		m_X_n0[inode][0] = m_X_n[inode][0];
		m_X_n0[inode][1] = m_X_n[inode][1];
	}

	// calling jobs
	iniCjrIc(); // @1.0
	iniTime(); // @1.0
	initialize(); // @2.0
	setUpTimeLoopN(); // @2.0
}

/**
 * Job computeCjr called @1.0 in executeTimeLoopN method.
 * In variables: X_n
 * Out variables: C
 */
void Glace2dModule::computeCjr()
{
	auto command = makeCommand(m_default_queue);
	auto in_X_n = ax::viewIn(command, m_X_n);
	auto out_C = ax::viewOut(command, m_C);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				const auto rPlus1Id(nodesOfCellJ[(rNodesOfCellJ+1+nbNodesOfCellJ)%nbNodesOfCellJ]);
				const auto rMinus1Id(nodesOfCellJ[(rNodesOfCellJ-1+nbNodesOfCellJ)%nbNodesOfCellJ]);
				const auto rPlus1Nodes(rPlus1Id);
				const auto rMinus1Nodes(rMinus1Id);
				out_C[jCells][rNodesOfCellJ] = glace2dfreefuncs::operatorMult(0.5, glace2dfreefuncs::perp(glace2dfreefuncs::operatorSub(in_X_n[rPlus1Nodes], in_X_n[rMinus1Nodes])));
			}
		}
	};
}

/**
 * Job computeInternalEnergy called @1.0 in executeTimeLoopN method.
 * In variables: E_n, uj_n
 * Out variables: e
 */
void Glace2dModule::computeInternalEnergy()
{
	auto command = makeCommand(m_default_queue);
	auto in_E_n = ax::viewIn(command, m_E_n);
	auto in_uj_n = ax::viewIn(command, m_uj_n);
	auto out_e = ax::viewOut(command, m_e);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_e[jCells] = in_E_n[jCells] - 0.5 * glace2dfreefuncs::dot(in_uj_n[jCells], in_uj_n[jCells]);
	};
}

/**
 * Job iniCjrIc called @1.0 in simulate method.
 * In variables: X_n0
 * Out variables: Cjr_ic
 */
void Glace2dModule::iniCjrIc()
{
	auto command = makeCommand(m_default_queue);
	auto in_X_n0 = ax::viewIn(command, m_X_n0);
	auto out_Cjr_ic = ax::viewOut(command, m_Cjr_ic);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				const auto rPlus1Id(nodesOfCellJ[(rNodesOfCellJ+1+nbNodesOfCellJ)%nbNodesOfCellJ]);
				const auto rMinus1Id(nodesOfCellJ[(rNodesOfCellJ-1+nbNodesOfCellJ)%nbNodesOfCellJ]);
				const auto rPlus1Nodes(rPlus1Id);
				const auto rMinus1Nodes(rMinus1Id);
				out_Cjr_ic[jCells][rNodesOfCellJ] = glace2dfreefuncs::operatorMult(0.5, glace2dfreefuncs::perp(glace2dfreefuncs::operatorSub(in_X_n0[rPlus1Nodes], in_X_n0[rMinus1Nodes])));
			}
		}
	};
}

/**
 * Job iniTime called @1.0 in simulate method.
 * In variables: 
 * Out variables: t_n0
 */
void Glace2dModule::iniTime()
{
	m_t_n0 = 0.0;
}

/**
 * Job computeLjr called @2.0 in executeTimeLoopN method.
 * In variables: C
 * Out variables: l
 */
void Glace2dModule::computeLjr()
{
	auto command = makeCommand(m_default_queue);
	auto in_C = ax::viewIn(command, m_C);
	auto out_l = ax::viewOut(command, m_l);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				out_l[jCells][rNodesOfCellJ] = glace2dfreefuncs::norm(in_C[jCells][rNodesOfCellJ]);
			}
		}
	};
}

/**
 * Job computeV called @2.0 in executeTimeLoopN method.
 * In variables: C, X_n
 * Out variables: V
 */
void Glace2dModule::computeV()
{
	auto command = makeCommand(m_default_queue);
	auto in_C = ax::viewIn(command, m_C);
	auto in_X_n = ax::viewIn(command, m_X_n);
	auto out_V = ax::viewOut(command, m_V);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		Real reduction0(0.0);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				const auto rId(nodesOfCellJ[rNodesOfCellJ]);
				const auto rNodes(rId);
				reduction0 = glace2dfreefuncs::sumR0(reduction0, glace2dfreefuncs::dot(in_C[jCells][rNodesOfCellJ], in_X_n[rNodes]));
			}
		}
		out_V[jCells] = 0.5 * reduction0;
	};
}

/**
 * Job initialize called @2.0 in simulate method.
 * In variables: Cjr_ic, X_n0, gamma, pIniZd, pIniZg, rho_IniZd, rho_IniZg, xInterface
 * Out variables: E_n, m, p, rho, uj_n
 */
void Glace2dModule::initialize()
{
	auto command = makeCommand(m_default_queue);
	auto in_X_n0 = ax::viewIn(command, m_X_n0);
	auto in_xInterface = m_xInterface;
	auto in_rho_IniZg = m_rho_IniZg;
	auto in_pIniZg = m_pIniZg;
	auto in_rho_IniZd = m_rho_IniZd;
	auto in_pIniZd = m_pIniZd;
	auto in_Cjr_ic = ax::viewIn(command, m_Cjr_ic);
	auto in_gamma = m_gamma;
	auto out_m = ax::viewOut(command, m_m);
	auto out_p = ax::viewOut(command, m_p);
	auto out_rho = ax::viewOut(command, m_rho);
	auto out_E_n = ax::viewOut(command, m_E_n);
	auto out_uj_n = ax::viewOut(command, m_uj_n);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		Real rho_ic;
		Real p_ic;
		Real2 reduction0{0.0, 0.0};
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				const auto rId(nodesOfCellJ[rNodesOfCellJ]);
				const auto rNodes(rId);
				reduction0 = glace2dfreefuncs::sumR1(reduction0, in_X_n0[rNodes]);
			}
		}
		const Real2 center(glace2dfreefuncs::operatorMult(0.25, reduction0));
		if (center[0] < in_xInterface) 
		{
			rho_ic = in_rho_IniZg;
			p_ic = in_pIniZg;
		}
		else
		{
			rho_ic = in_rho_IniZd;
			p_ic = in_pIniZd;
		}
		Real reduction1(0.0);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				const auto rId(nodesOfCellJ[rNodesOfCellJ]);
				const auto rNodes(rId);
				reduction1 = glace2dfreefuncs::sumR0(reduction1, glace2dfreefuncs::dot(in_Cjr_ic[jCells][rNodesOfCellJ], in_X_n0[rNodes]));
			}
		}
		const Real V_ic(0.5 * reduction1);
		out_m[jCells] = rho_ic * V_ic;
		out_p[jCells] = p_ic;
		out_rho[jCells] = rho_ic;
		out_E_n[jCells] = p_ic / ((in_gamma - 1.0) * rho_ic);
		out_uj_n[jCells] = Real2{0.0, 0.0};
	};
}

/**
 * Job setUpTimeLoopN called @2.0 in simulate method.
 * In variables: X_n0, t_n0
 * Out variables: X_n, t_n
 */
void Glace2dModule::setUpTimeLoopN()
{
	m_t_n = m_t_n0;
	{
		auto command = makeCommand(m_default_queue);
		auto in_X_n0 = ax::viewIn(command, m_X_n0);
		auto out_X_n = ax::viewOut(command, m_X_n);
		command << RUNCOMMAND_ENUMERATE(Node, i1Nodes, allNodes())
		{
			for (Int32 i1=0; i1<2; i1++)
			{
				out_X_n[i1Nodes][i1] = in_X_n0[i1Nodes][i1];
			}
		};
	}
}

/**
 * Job computeDensity called @3.0 in executeTimeLoopN method.
 * In variables: V, m
 * Out variables: rho
 */
void Glace2dModule::computeDensity()
{
	auto command = makeCommand(m_default_queue);
	auto in_m = ax::viewIn(command, m_m);
	auto in_V = ax::viewIn(command, m_V);
	auto out_rho = ax::viewOut(command, m_rho);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_rho[jCells] = in_m[jCells] / in_V[jCells];
	};
}

/**
 * Job executeTimeLoopN called @3.0 in simulate method.
 * In variables: E_n, X_n, lastDump, maxIterations, n, outputPeriod, stopTime, t_n, t_nplus1, uj_n
 * Out variables: E_nplus1, X_nplus1, t_nplus1, uj_nplus1
 */
void Glace2dModule::executeTimeLoopN()
{
	m_n++;
	computeCjr(); // @1.0
	computeInternalEnergy(); // @1.0
	computeLjr(); // @2.0
	computeV(); // @2.0
	computeDensity(); // @3.0
	computeEOSp(); // @4.0
	computeEOSc(); // @5.0
	computeAjr(); // @6.0
	computedeltatj(); // @6.0
	computeAr(); // @7.0
	computeBr(); // @7.0
	computeDt(); // @7.0
	computeBoundaryConditions(); // @8.0
	computeBt(); // @8.0
	computeMt(); // @8.0
	computeTn(); // @8.0
	computeU(); // @9.0
	computeFjr(); // @10.0
	computeXn(); // @10.0
	computeEn(); // @11.0
	computeUn(); // @11.0
	
	// Evaluate loop condition with variables at time n
	bool continueLoop = (m_t_nplus1 < options()->stopTime() && m_n + 1 < options()->maxIterations());
	
	m_t_n = m_t_nplus1;
	{
		auto command = makeCommand(m_default_queue);
		auto in_X_nplus1 = ax::viewIn(command, m_X_nplus1);
		auto out_X_n = ax::viewOut(command, m_X_n);
		command << RUNCOMMAND_ENUMERATE(Node, i1Nodes, allNodes())
		{
			for (Int32 i1=0; i1<2; i1++)
			{
				out_X_n[i1Nodes][i1] = in_X_nplus1[i1Nodes][i1];
			}
		};
	}
	{
		auto command = makeCommand(m_default_queue);
		auto in_E_nplus1 = ax::viewIn(command, m_E_nplus1);
		auto out_E_n = ax::viewOut(command, m_E_n);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			out_E_n[i1Cells] = in_E_nplus1[i1Cells];
		};
	}
	{
		auto command = makeCommand(m_default_queue);
		auto in_uj_nplus1 = ax::viewIn(command, m_uj_nplus1);
		auto out_uj_n = ax::viewOut(command, m_uj_n);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			for (Int32 i1=0; i1<2; i1++)
			{
				out_uj_n[i1Cells][i1] = in_uj_nplus1[i1Cells][i1];
			}
		};
	}
	
	if (!continueLoop)
		subDomain()->timeLoopMng()->stopComputeLoop(true);
}

/**
 * Job computeEOSp called @4.0 in executeTimeLoopN method.
 * In variables: e, gamma, rho
 * Out variables: p
 */
void Glace2dModule::computeEOSp()
{
	auto command = makeCommand(m_default_queue);
	auto in_gamma = m_gamma;
	auto in_rho = ax::viewIn(command, m_rho);
	auto in_e = ax::viewIn(command, m_e);
	auto out_p = ax::viewOut(command, m_p);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_p[jCells] = (in_gamma - 1.0) * in_rho[jCells] * in_e[jCells];
	};
}

/**
 * Job computeEOSc called @5.0 in executeTimeLoopN method.
 * In variables: gamma, p, rho
 * Out variables: c
 */
void Glace2dModule::computeEOSc()
{
	auto command = makeCommand(m_default_queue);
	auto in_gamma = m_gamma;
	auto in_p = ax::viewIn(command, m_p);
	auto in_rho = ax::viewIn(command, m_rho);
	auto out_c = ax::viewOut(command, m_c);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_c[jCells] = std::sqrt(in_gamma * in_p[jCells] / in_rho[jCells]);
	};
}

/**
 * Job computeAjr called @6.0 in executeTimeLoopN method.
 * In variables: C, c, l, rho
 * Out variables: Ajr
 */
void Glace2dModule::computeAjr()
{
	auto command = makeCommand(m_default_queue);
	auto in_rho = ax::viewIn(command, m_rho);
	auto in_c = ax::viewIn(command, m_c);
	auto in_l = ax::viewIn(command, m_l);
	auto in_C = ax::viewIn(command, m_C);
	auto out_Ajr = ax::viewOut(command, m_Ajr);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				out_Ajr[jCells][rNodesOfCellJ] = glace2dfreefuncs::operatorMult(((in_rho[jCells] * in_c[jCells]) / in_l[jCells][rNodesOfCellJ]), glace2dfreefuncs::tensProduct(in_C[jCells][rNodesOfCellJ], in_C[jCells][rNodesOfCellJ]));
			}
		}
	};
}

/**
 * Job computedeltatj called @6.0 in executeTimeLoopN method.
 * In variables: V, c, l
 * Out variables: delta_tj
 */
void Glace2dModule::computedeltatj()
{
	auto command = makeCommand(m_default_queue);
	auto in_l = ax::viewIn(command, m_l);
	auto in_V = ax::viewIn(command, m_V);
	auto in_c = ax::viewIn(command, m_c);
	auto out_delta_tj = ax::viewOut(command, m_delta_tj);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		Real reduction0(0.0);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				reduction0 = glace2dfreefuncs::sumR0(reduction0, in_l[jCells][rNodesOfCellJ]);
			}
		}
		out_delta_tj[jCells] = 2.0 * in_V[jCells] / (in_c[jCells] * reduction0);
	};
}

/**
 * Job computeAr called @7.0 in executeTimeLoopN method.
 * In variables: Ajr
 * Out variables: Ar
 */
void Glace2dModule::computeAr()
{
	auto command = makeCommand(m_default_queue);
	auto in_Ajr = ax::viewIn(command, m_Ajr);
	auto out_Ar = ax::viewOut(command, m_Ar);
	command << RUNCOMMAND_ENUMERATE(Node, rNodes, allNodes())
	{
		const auto rId(rNodes);
		Real2x2 reduction0{0.0, 0.0, 0.0, 0.0};
		{
			const auto cellsOfNodeR(m_mesh->getCellsOfNode(rId));
			const Int32 nbCellsOfNodeR(cellsOfNodeR.size());
			for (Int32 jCellsOfNodeR=0; jCellsOfNodeR<nbCellsOfNodeR; jCellsOfNodeR++)
			{
				const auto jId(cellsOfNodeR[jCellsOfNodeR]);
				const auto jCells(jId);
				const auto rNodesOfCellJ(m_mesh->indexOf(m_mesh->getNodesOfCell(jId), rId));
				reduction0 = glace2dfreefuncs::sumR2(reduction0, in_Ajr[jCells][rNodesOfCellJ]);
			}
		}
		for (Int32 i1=0; i1<2; i1++)
		{
			for (Int32 i2=0; i2<2; i2++)
			{
				out_Ar[rNodes][i1][i2] = reduction0[i1][i2];
			}
		}
	};
}

/**
 * Job computeBr called @7.0 in executeTimeLoopN method.
 * In variables: Ajr, C, p, uj_n
 * Out variables: b
 */
void Glace2dModule::computeBr()
{
	auto command = makeCommand(m_default_queue);
	auto in_p = ax::viewIn(command, m_p);
	auto in_C = ax::viewIn(command, m_C);
	auto in_Ajr = ax::viewIn(command, m_Ajr);
	auto in_uj_n = ax::viewIn(command, m_uj_n);
	auto out_b = ax::viewOut(command, m_b);
	command << RUNCOMMAND_ENUMERATE(Node, rNodes, allNodes())
	{
		const auto rId(rNodes);
		Real2 reduction0{0.0, 0.0};
		{
			const auto cellsOfNodeR(m_mesh->getCellsOfNode(rId));
			const Int32 nbCellsOfNodeR(cellsOfNodeR.size());
			for (Int32 jCellsOfNodeR=0; jCellsOfNodeR<nbCellsOfNodeR; jCellsOfNodeR++)
			{
				const auto jId(cellsOfNodeR[jCellsOfNodeR]);
				const auto jCells(jId);
				const auto rNodesOfCellJ(m_mesh->indexOf(m_mesh->getNodesOfCell(jId), rId));
				reduction0 = glace2dfreefuncs::sumR1(reduction0, glace2dfreefuncs::operatorAdd(glace2dfreefuncs::operatorMult(in_p[jCells], in_C[jCells][rNodesOfCellJ]), glace2dfreefuncs::matVectProduct(in_Ajr[jCells][rNodesOfCellJ], in_uj_n[jCells])));
			}
		}
		for (Int32 i1=0; i1<2; i1++)
		{
			out_b[rNodes][i1] = reduction0[i1];
		}
	};
}

/**
 * Job computeDt called @7.0 in executeTimeLoopN method.
 * In variables: delta_tCfl, delta_tj, stopTime, t_n
 * Out variables: delta_t
 */
void Glace2dModule::computeDt()
{
	Real reduction0(numeric_limits<double>::max());
	{
		auto command = makeCommand(m_default_queue);
		auto in_delta_tj = ax::viewIn(command, m_delta_tj);
		ax::ReducerMin<Real> reducer(command);
		command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
		{
			reducer.min(in_delta_tj[jCells]);
		};
		reduction0 = reducer.reduce();
	}
	m_delta_t = std::min((m_delta_tCfl * reduction0), (options()->stopTime() - m_t_n));
	m_global_deltat = m_delta_t;
}

/**
 * Job computeBoundaryConditions called @8.0 in executeTimeLoopN method.
 * In variables: Ar, b
 * Out variables: Mt, bt
 */
void Glace2dModule::computeBoundaryConditions()
{
	const Real2x2 I(Real2x2{Real2{1.0, 0.0}, Real2{0.0, 1.0}});
	{
		auto command = makeCommand(m_default_queue);
		auto in_b = ax::viewIn(command, m_b);
		auto in_Ar = ax::viewIn(command, m_Ar);
		auto out_bt = ax::viewOut(command, m_bt);
		auto out_Mt = ax::viewOut(command, m_Mt);
		command << RUNCOMMAND_ENUMERATE(Node, rTopNodes, NodeGroup(m_mesh->getGroup("TopNodes")))
		{
			const auto rId(rTopNodes);
			const auto rNodes(rId);
			const Real2 N(Real2{0.0, 1.0});
			const Real2x2 NxN(glace2dfreefuncs::tensProduct(N, N));
			const Real2x2 IcP(glace2dfreefuncs::operatorSub(I, NxN));
			out_bt[rNodes] = glace2dfreefuncs::matVectProduct(IcP, in_b[rNodes]);
			out_Mt[rNodes] = glace2dfreefuncs::operatorAdd(glace2dfreefuncs::operatorMult(IcP, (glace2dfreefuncs::operatorMult(in_Ar[rNodes], IcP))), glace2dfreefuncs::operatorMult(NxN, glace2dfreefuncs::trace(in_Ar[rNodes])));
		};
	}
	{
		auto command = makeCommand(m_default_queue);
		auto in_b = ax::viewIn(command, m_b);
		auto in_Ar = ax::viewIn(command, m_Ar);
		auto out_bt = ax::viewOut(command, m_bt);
		auto out_Mt = ax::viewOut(command, m_Mt);
		command << RUNCOMMAND_ENUMERATE(Node, rBottomNodes, NodeGroup(m_mesh->getGroup("BottomNodes")))
		{
			const auto rId(rBottomNodes);
			const auto rNodes(rId);
			const Real2 N(Real2{0.0, -1.0});
			const Real2x2 NxN(glace2dfreefuncs::tensProduct(N, N));
			const Real2x2 IcP(glace2dfreefuncs::operatorSub(I, NxN));
			out_bt[rNodes] = glace2dfreefuncs::matVectProduct(IcP, in_b[rNodes]);
			out_Mt[rNodes] = glace2dfreefuncs::operatorAdd(glace2dfreefuncs::operatorMult(IcP, (glace2dfreefuncs::operatorMult(in_Ar[rNodes], IcP))), glace2dfreefuncs::operatorMult(NxN, glace2dfreefuncs::trace(in_Ar[rNodes])));
		};
	}
	{
		auto command = makeCommand(m_default_queue);
		auto out_Mt = ax::viewOut(command, m_Mt);
		auto out_bt = ax::viewOut(command, m_bt);
		command << RUNCOMMAND_ENUMERATE(Node, rLeftNodes, NodeGroup(m_mesh->getGroup("LeftNodes")))
		{
			const auto rId(rLeftNodes);
			const auto rNodes(rId);
			for (Int32 i1=0; i1<2; i1++)
			{
				for (Int32 i2=0; i2<2; i2++)
				{
					out_Mt[rNodes][i1][i2] = I[i1][i2];
				}
			}
			out_bt[rNodes] = Real2{0.0, 0.0};
		};
	}
	{
		auto command = makeCommand(m_default_queue);
		auto out_Mt = ax::viewOut(command, m_Mt);
		auto out_bt = ax::viewOut(command, m_bt);
		command << RUNCOMMAND_ENUMERATE(Node, rRightNodes, NodeGroup(m_mesh->getGroup("RightNodes")))
		{
			const auto rId(rRightNodes);
			const auto rNodes(rId);
			for (Int32 i1=0; i1<2; i1++)
			{
				for (Int32 i2=0; i2<2; i2++)
				{
					out_Mt[rNodes][i1][i2] = I[i1][i2];
				}
			}
			out_bt[rNodes] = Real2{0.0, 0.0};
		};
	}
}

/**
 * Job computeBt called @8.0 in executeTimeLoopN method.
 * In variables: b
 * Out variables: bt
 */
void Glace2dModule::computeBt()
{
	auto command = makeCommand(m_default_queue);
	auto in_b = ax::viewIn(command, m_b);
	auto out_bt = ax::viewOut(command, m_bt);
	command << RUNCOMMAND_ENUMERATE(Node, rInnerNodes, NodeGroup(m_mesh->getGroup("InnerNodes")))
	{
		const auto rId(rInnerNodes);
		const auto rNodes(rId);
		for (Int32 i1=0; i1<2; i1++)
		{
			out_bt[rNodes][i1] = in_b[rNodes][i1];
		}
	};
}

/**
 * Job computeMt called @8.0 in executeTimeLoopN method.
 * In variables: Ar
 * Out variables: Mt
 */
void Glace2dModule::computeMt()
{
	auto command = makeCommand(m_default_queue);
	auto in_Ar = ax::viewIn(command, m_Ar);
	auto out_Mt = ax::viewOut(command, m_Mt);
	command << RUNCOMMAND_ENUMERATE(Node, rInnerNodes, NodeGroup(m_mesh->getGroup("InnerNodes")))
	{
		const auto rId(rInnerNodes);
		const auto rNodes(rId);
		for (Int32 i1=0; i1<2; i1++)
		{
			for (Int32 i2=0; i2<2; i2++)
			{
				out_Mt[rNodes][i1][i2] = in_Ar[rNodes][i1][i2];
			}
		}
	};
}

/**
 * Job computeTn called @8.0 in executeTimeLoopN method.
 * In variables: delta_t, t_n
 * Out variables: t_nplus1
 */
void Glace2dModule::computeTn()
{
	m_t_nplus1 = m_t_n + m_delta_t;
}

/**
 * Job computeU called @9.0 in executeTimeLoopN method.
 * In variables: Mt, bt
 * Out variables: ur
 */
void Glace2dModule::computeU()
{
	auto command = makeCommand(m_default_queue);
	auto in_Mt = ax::viewIn(command, m_Mt);
	auto in_bt = ax::viewIn(command, m_bt);
	auto out_ur = ax::viewOut(command, m_ur);
	command << RUNCOMMAND_ENUMERATE(Node, rNodes, allNodes())
	{
		out_ur[rNodes] = glace2dfreefuncs::matVectProduct(glace2dfreefuncs::inverse(in_Mt[rNodes]), in_bt[rNodes]);
	};
}

/**
 * Job computeFjr called @10.0 in executeTimeLoopN method.
 * In variables: Ajr, C, p, uj_n, ur
 * Out variables: F
 */
void Glace2dModule::computeFjr()
{
	auto command = makeCommand(m_default_queue);
	auto in_p = ax::viewIn(command, m_p);
	auto in_C = ax::viewIn(command, m_C);
	auto in_Ajr = ax::viewIn(command, m_Ajr);
	auto in_uj_n = ax::viewIn(command, m_uj_n);
	auto in_ur = ax::viewIn(command, m_ur);
	auto out_F = ax::viewOut(command, m_F);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				const auto rId(nodesOfCellJ[rNodesOfCellJ]);
				const auto rNodes(rId);
				out_F[jCells][rNodesOfCellJ] = glace2dfreefuncs::operatorAdd(glace2dfreefuncs::operatorMult(in_p[jCells], in_C[jCells][rNodesOfCellJ]), glace2dfreefuncs::matVectProduct(in_Ajr[jCells][rNodesOfCellJ], (glace2dfreefuncs::operatorSub(in_uj_n[jCells], in_ur[rNodes]))));
			}
		}
	};
}

/**
 * Job computeXn called @10.0 in executeTimeLoopN method.
 * In variables: X_n, delta_t, ur
 * Out variables: X_nplus1
 */
void Glace2dModule::computeXn()
{
	auto command = makeCommand(m_default_queue);
	auto in_X_n = ax::viewIn(command, m_X_n);
	auto in_delta_t = m_delta_t;
	auto in_ur = ax::viewIn(command, m_ur);
	auto out_X_nplus1 = ax::viewOut(command, m_X_nplus1);
	command << RUNCOMMAND_ENUMERATE(Node, rNodes, allNodes())
	{
		out_X_nplus1[rNodes] = glace2dfreefuncs::operatorAdd(in_X_n[rNodes], glace2dfreefuncs::operatorMult(in_delta_t, in_ur[rNodes]));
	};
}

/**
 * Job computeEn called @11.0 in executeTimeLoopN method.
 * In variables: E_n, F, delta_t, m, ur
 * Out variables: E_nplus1
 */
void Glace2dModule::computeEn()
{
	auto command = makeCommand(m_default_queue);
	auto in_F = ax::viewIn(command, m_F);
	auto in_ur = ax::viewIn(command, m_ur);
	auto in_E_n = ax::viewIn(command, m_E_n);
	auto in_delta_t = m_delta_t;
	auto in_m = ax::viewIn(command, m_m);
	auto out_E_nplus1 = ax::viewOut(command, m_E_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		Real reduction0(0.0);
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				const auto rId(nodesOfCellJ[rNodesOfCellJ]);
				const auto rNodes(rId);
				reduction0 = glace2dfreefuncs::sumR0(reduction0, glace2dfreefuncs::dot(in_F[jCells][rNodesOfCellJ], in_ur[rNodes]));
			}
		}
		out_E_nplus1[jCells] = in_E_n[jCells] - (in_delta_t / in_m[jCells]) * reduction0;
	};
}

/**
 * Job computeUn called @11.0 in executeTimeLoopN method.
 * In variables: F, delta_t, m, uj_n
 * Out variables: uj_nplus1
 */
void Glace2dModule::computeUn()
{
	auto command = makeCommand(m_default_queue);
	auto in_F = ax::viewIn(command, m_F);
	auto in_uj_n = ax::viewIn(command, m_uj_n);
	auto in_delta_t = m_delta_t;
	auto in_m = ax::viewIn(command, m_m);
	auto out_uj_nplus1 = ax::viewOut(command, m_uj_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const auto jId(jCells);
		Real2 reduction0{0.0, 0.0};
		{
			const auto nodesOfCellJ(m_mesh->getNodesOfCell(jId));
			const Int32 nbNodesOfCellJ(nodesOfCellJ.size());
			for (Int32 rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				reduction0 = glace2dfreefuncs::sumR1(reduction0, in_F[jCells][rNodesOfCellJ]);
			}
		}
		out_uj_nplus1[jCells] = glace2dfreefuncs::operatorSub(in_uj_n[jCells], glace2dfreefuncs::operatorMult((in_delta_t / in_m[jCells]), reduction0));
	};
}

ARCANE_REGISTER_MODULE_GLACE2D(Glace2dModule);
