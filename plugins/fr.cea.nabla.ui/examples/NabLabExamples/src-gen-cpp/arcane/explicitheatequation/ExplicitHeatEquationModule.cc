/* DO NOT EDIT THIS FILE - it is machine generated */

#include "ExplicitHeatEquationModule.h"
#include <arcane/Concurrency.h>

using namespace Arcane;

/******************** Free functions definitions ********************/

namespace explicitheatequationfreefuncs
{
const Real norm(ConstArrayView<Real> a)
{
	return std::sqrt(explicitheatequationfreefuncs::dot(a, a));
}

const Real dot(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	Real result(0.0);
	for (Integer i=0; i<a.size(); i++)
	{
		result = result + a[i] * b[i];
	}
	return result;
}

const Real det(const Real2 a, const Real2 b)
{
	return (a[0] * b[1] - a[1] * b[0]);
}

ConstArrayView<Real> sumR1(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	return explicitheatequationfreefuncs::operator+(a, b);
}

const Real minR0(const Real a, const Real b)
{
	return std::min(a, b);
}

const Real sumR0(const Real a, const Real b)
{
	return a + b;
}

const Real prodR0(const Real a, const Real b)
{
	return a * b;
}

ConstArrayView<Real> operator+(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	ArrayView<Real> result;
	for (Integer ix0=0; ix0<a.size(); ix0++)
	{
		result[ix0] = a[ix0] + b[ix0];
	}
	return result;
}

const Real2 operator-(const Real2 a, const Real2 b)
{
	Real2 result;
	for (Integer i0=0; i0<2; i0++)
	{
		result[i0] = a[i0] - b[i0];
	}
	return result;
}

const Real2 operator*(const Real a, const Real2 b)
{
	Real2 result;
	for (Integer i0=0; i0<2; i0++)
	{
		result[i0] = a * b[i0];
	}
	return result;
}
}


/******************** Module entry points ********************/

void ExplicitHeatEquationModule::init()
{
	// mesh initialisation
	m_mesh = CartesianMesh2D::createInstance(mesh());

	computeFaceLength(); // @1.0
	computeV(); // @1.0
	initD(); // @1.0
	initTime(); // @1.0
	initXc(); // @1.0
	computeDeltaTn(); // @2.0
	computeFaceConductivity(); // @2.0
	initU(); // @2.0
	setUpTimeLoopN(); // @2.0
	computeAlphaCoeff(); // @3.0
}

void ExplicitHeatEquationModule::compute()
{
	computeTn(); // @1.0
	updateU(); // @1.0
}


/******************** Module methods ********************/

/**
 * Job computeFaceLength called @1.0 in simulate method.
 * In variables: X
 * Out variables: faceLength
 */
void ExplicitHeatEquationModule::computeFaceLength()
{
	arcaneParallelForeach(m_mesh->getFaces(), [&](FaceVectorView view)
	{
		ENUMERATE_FACE(f, view)
		{
			auto fId(f.itemLocalId());
			Real reduction0(0.0);
			{
				const auto nodesOfFaceF(m_mesh->getNodesOfFace(*f));
				const size_t nbNodesOfFaceF(nodesOfFaceF.size());
				for (size_t pNodesOfFaceF=0; pNodesOfFaceF<nbNodesOfFaceF; pNodesOfFaceF++)
				{
					auto pId(nodesOfFaceF[pNodesOfFaceF]);
					auto pPlus1Id(nodesOfFaceF[(pNodesOfFaceF+1+nbNodesOfFaceF)%nbNodesOfFaceF]);
					reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operator-(m_x[p], m_x[p])));
				}
			}
			m_face_length[f] = 0.5 * reduction0;
		}
	});
}

/**
 * Job computeTn called @1.0 in executeTimeLoopN method.
 * In variables: deltat, t_n
 * Out variables: t_nplus1
 */
void ExplicitHeatEquationModule::computeTn()
{
	m_t_nplus1 = m_t_n() + m_deltat();
}

/**
 * Job computeV called @1.0 in simulate method.
 * In variables: X
 * Out variables: V
 */
void ExplicitHeatEquationModule::computeV()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			auto cId(c.itemLocalId());
			Real reduction0(0.0);
			{
				const auto nodesOfCellC(m_mesh->getNodesOfCell(*c));
				const size_t nbNodesOfCellC(nodesOfCellC.size());
				for (size_t pNodesOfCellC=0; pNodesOfCellC<nbNodesOfCellC; pNodesOfCellC++)
				{
					auto pId(nodesOfCellC[pNodesOfCellC]);
					auto pPlus1Id(nodesOfCellC[(pNodesOfCellC+1+nbNodesOfCellC)%nbNodesOfCellC]);
					reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::det(m_x[p], m_x[p]));
				}
			}
			m_v[c] = 0.5 * reduction0;
		}
	});
}

/**
 * Job initD called @1.0 in simulate method.
 * In variables: 
 * Out variables: D
 */
void ExplicitHeatEquationModule::initD()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			m_d[c] = 1.0;
		}
	});
}

/**
 * Job initTime called @1.0 in simulate method.
 * In variables: 
 * Out variables: t_n0
 */
void ExplicitHeatEquationModule::initTime()
{
	m_t_n0 = 0.0;
}

/**
 * Job initXc called @1.0 in simulate method.
 * In variables: X
 * Out variables: Xc
 */
void ExplicitHeatEquationModule::initXc()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			auto cId(c.itemLocalId());
			Real2 reduction0{0.0, 0.0};
			{
				const auto nodesOfCellC(m_mesh->getNodesOfCell(*c));
				const size_t nbNodesOfCellC(nodesOfCellC.size());
				for (size_t pNodesOfCellC=0; pNodesOfCellC<nbNodesOfCellC; pNodesOfCellC++)
				{
					auto pId(nodesOfCellC[pNodesOfCellC]);
					reduction0 = explicitheatequationfreefuncs::sumR1(reduction0, m_x[p]);
				}
			}
			m_xc[c] = explicitheatequationfreefuncs::operator*(0.25, reduction0);
		}
	});
}

/**
 * Job updateU called @1.0 in executeTimeLoopN method.
 * In variables: alpha, u_n
 * Out variables: u_nplus1
 */
void ExplicitHeatEquationModule::updateU()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			auto cId(c.itemLocalId());
			Real reduction0(0.0);
			{
				const auto neighbourCellsC(m_mesh->getNeighbourCells(*c));
				const size_t nbNeighbourCellsC(neighbourCellsC.size());
				for (size_t dNeighbourCellsC=0; dNeighbourCellsC<nbNeighbourCellsC; dNeighbourCellsC++)
				{
					auto dId(neighbourCellsC[dNeighbourCellsC]);
					reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, m_alpha[c][d] * m_u_n[d]);
				}
			}
			m_u_nplus1[c] = m_alpha[c][c] * m_u_n[c] + reduction0;
		}
	});
}

/**
 * Job computeDeltaTn called @2.0 in simulate method.
 * In variables: D, V
 * Out variables: deltat
 */
void ExplicitHeatEquationModule::computeDeltaTn()
{
	Real reduction0(numeric_limits<double>::max());
	ENUMERATE_CELL(c, m_mesh->getCells())
	{
		reduction0 = explicitheatequationfreefuncs::minR0(reduction0, m_v[c] / m_d[c]);
	}
	m_deltat = reduction0 * 0.24;
}

/**
 * Job computeFaceConductivity called @2.0 in simulate method.
 * In variables: D
 * Out variables: faceConductivity
 */
void ExplicitHeatEquationModule::computeFaceConductivity()
{
	arcaneParallelForeach(m_mesh->getFaces(), [&](FaceVectorView view)
	{
		ENUMERATE_FACE(f, view)
		{
			auto fId(f.itemLocalId());
			Real reduction0(1.0);
			{
				const auto cellsOfFaceF(m_mesh->getCellsOfFace(*f));
				const size_t nbCellsOfFaceF(cellsOfFaceF.size());
				for (size_t c1CellsOfFaceF=0; c1CellsOfFaceF<nbCellsOfFaceF; c1CellsOfFaceF++)
				{
					auto c1Id(cellsOfFaceF[c1CellsOfFaceF]);
					reduction0 = explicitheatequationfreefuncs::prodR0(reduction0, m_d[c1]);
				}
			}
			Real reduction1(0.0);
			{
				const auto cellsOfFaceF(m_mesh->getCellsOfFace(*f));
				const size_t nbCellsOfFaceF(cellsOfFaceF.size());
				for (size_t c2CellsOfFaceF=0; c2CellsOfFaceF<nbCellsOfFaceF; c2CellsOfFaceF++)
				{
					auto c2Id(cellsOfFaceF[c2CellsOfFaceF]);
					reduction1 = explicitheatequationfreefuncs::sumR0(reduction1, m_d[c2]);
				}
			}
			m_face_conductivity[f] = 2.0 * reduction0 / reduction1;
		}
	});
}

/**
 * Job initU called @2.0 in simulate method.
 * In variables: Xc, u0, vectOne
 * Out variables: u_n
 */
void ExplicitHeatEquationModule::initU()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			if (explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operator-(m_xc[c], m_vect_one)) < 0.5) 
				m_u_n[c] = options.u0();
			else
				m_u_n[c] = 0.0;
		}
	});
}

/**
 * Job setUpTimeLoopN called @2.0 in simulate method.
 * In variables: t_n0
 * Out variables: t_n
 */
void ExplicitHeatEquationModule::setUpTimeLoopN()
{
	m_t_n = m_t_n0();
}

/**
 * Job computeAlphaCoeff called @3.0 in simulate method.
 * In variables: V, Xc, deltat, faceConductivity, faceLength
 * Out variables: alpha
 */
void ExplicitHeatEquationModule::computeAlphaCoeff()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			auto cId(c.itemLocalId());
			Real alpha_diag(0.0);
			{
				const auto neighbourCellsC(m_mesh->getNeighbourCells(*c));
				const size_t nbNeighbourCellsC(neighbourCellsC.size());
				for (size_t dNeighbourCellsC=0; dNeighbourCellsC<nbNeighbourCellsC; dNeighbourCellsC++)
				{
					auto dId(neighbourCellsC[dNeighbourCellsC]);
					auto fId(m_mesh->getCommonFace(*c, *d));
					const Real alpha_extra_diag(m_deltat() / m_v[c] * (m_face_length[f] * m_face_conductivity[f]) / explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operator-(m_xc[c], m_xc[d])));
					m_alpha[c][d] = alpha_extra_diag;
					alpha_diag = alpha_diag + alpha_extra_diag;
				}
			}
			m_alpha[c][c] = 1 - alpha_diag;
		}
	});
}
