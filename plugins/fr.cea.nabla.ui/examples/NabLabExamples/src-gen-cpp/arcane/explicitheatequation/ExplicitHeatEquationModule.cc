/* DO NOT EDIT THIS FILE - it is machine generated */

#include "ExplicitHeatEquationModule.h"
#include <arcane/Concurrency.h>

using namespace Arcane;

/******************** Free functions definitions ********************/

namespace explicitheatequationfreefuncs
{
const Real norm(ConstArrayView<Real> a)
{
	return std::sqrt(explicitheatequationfreefuncs::dot(a, a));
}

const Real dot(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	Real result(0.0);
	for (Integer i=0; i<a.size(); i++)
	{
		result = result + a[i] * b[i];
	}
	return result;
}

const Real det(const Real2 a, const Real2 b)
{
	return (a[0] * b[1] - a[1] * b[0]);
}

ConstArrayView<Real> sumR1(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	return explicitheatequationfreefuncs::operator+(a, b);
}

const Real minR0(const Real a, const Real b)
{
	return std::min(a, b);
}

const Real sumR0(const Real a, const Real b)
{
	return a + b;
}

const Real prodR0(const Real a, const Real b)
{
	return a * b;
}

ConstArrayView<Real> operator+(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	ArrayView<Real> result;
	for (Integer ix0=0; ix0<a.size(); ix0++)
	{
		result[ix0] = a[ix0] + b[ix0];
	}
	return result;
}

const Real2 operator-(const Real2 a, const Real2 b)
{
	Real2 result;
	for (Integer i0=0; i0<2; i0++)
	{
		result[i0] = a[i0] - b[i0];
	}
	return result;
}

const Real2 operator*(const Real a, const Real2 b)
{
	Real2 result;
	for (Integer i0=0; i0<2; i0++)
	{
		result[i0] = a * b[i0];
	}
	return result;
}
}


/******************** Module entry points ********************/

void ExplicitHeatEquationModule::init()
{
	// mesh initialisation
	m_mesh = CartesianMesh2D::createInstance(mesh());

	computeFaceLength(); // @1.0
	computeV(); // @1.0
	initD(); // @1.0
	initTime(); // @1.0
	initXc(); // @1.0
	computeDeltaTn(); // @2.0
	computeFaceConductivity(); // @2.0
	initU(); // @2.0
	setUpTimeLoopN(); // @2.0
	computeAlphaCoeff(); // @3.0
}

void ExplicitHeatEquationModule::compute()
{
	computeTn(); // @1.0
	updateU(); // @1.0
}


/******************** Module methods ********************/

/**
 * Job computeFaceLength called @1.0 in simulate method.
 * In variables: X
 * Out variables: faceLength
 */
void ExplicitHeatEquationModule::computeFaceLength()
{
	arcaneParallelForeach(m_mesh->getFaces(), [&](FaceVectorView view)
	{
		ENUMERATE_FACE(f, view)
		{
			final int fId = fFaces;
			Real reduction0(0.0);
			for (NodeLocalId p : m_mesh->getNodesOfFace(*f))
			{
				final int pId = nodesOfFaceF[pNodesOfFaceF];
				final int pPlus1Id = nodesOfFaceF[(pNodesOfFaceF+1+maxNodesOfFace)%maxNodesOfFace];
				const size_t pNodes(pId);
				const size_t pPlus1Nodes(pPlus1Id);
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operator-(m_x[p], m_x[p])));
			}
			m_face_length[f] = 0.5 * reduction0;
		}
	});
}

/**
 * Job computeTn called @1.0 in executeTimeLoopN method.
 * In variables: deltat, t_n
 * Out variables: t_nplus1
 */
void ExplicitHeatEquationModule::computeTn()
{
	m_t_nplus1 = m_t_n() + m_deltat();
}

/**
 * Job computeV called @1.0 in simulate method.
 * In variables: X
 * Out variables: V
 */
void ExplicitHeatEquationModule::computeV()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			final int cId = cCells;
			Real reduction0(0.0);
			for (NodeLocalId p : m_mesh->getNodesOfCell(*c))
			{
				final int pId = nodesOfCellC[pNodesOfCellC];
				final int pPlus1Id = nodesOfCellC[(pNodesOfCellC+1+maxNodesOfCell)%maxNodesOfCell];
				const size_t pNodes(pId);
				const size_t pPlus1Nodes(pPlus1Id);
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::det(m_x[p], m_x[p]));
			}
			m_v[c] = 0.5 * reduction0;
		}
	});
}

/**
 * Job initD called @1.0 in simulate method.
 * In variables: 
 * Out variables: D
 */
void ExplicitHeatEquationModule::initD()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			m_d[c] = 1.0;
		}
	});
}

/**
 * Job initTime called @1.0 in simulate method.
 * In variables: 
 * Out variables: t_n0
 */
void ExplicitHeatEquationModule::initTime()
{
	m_t_n0 = 0.0;
}

/**
 * Job initXc called @1.0 in simulate method.
 * In variables: X
 * Out variables: Xc
 */
void ExplicitHeatEquationModule::initXc()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			final int cId = cCells;
			Real2 reduction0{0.0, 0.0};
			for (NodeLocalId p : m_mesh->getNodesOfCell(*c))
			{
				final int pId = nodesOfCellC[pNodesOfCellC];
				const size_t pNodes(pId);
				reduction0 = explicitheatequationfreefuncs::sumR1(reduction0, m_x[p]);
			}
			m_xc[c] = explicitheatequationfreefuncs::operator*(0.25, reduction0);
		}
	});
}

/**
 * Job updateU called @1.0 in executeTimeLoopN method.
 * In variables: alpha, u_n
 * Out variables: u_nplus1
 */
void ExplicitHeatEquationModule::updateU()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			final int cId = cCells;
			Real reduction0(0.0);
			for (CellLocalId d : m_mesh->getNeighbourCells(*c))
			{
				final int dId = neighbourCellsC[dNeighbourCellsC];
				const size_t dCells(dId);
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, m_alpha[c][d] * m_u_n[d]);
			}
			m_u_nplus1[c] = m_alpha[c][c] * m_u_n[c] + reduction0;
		}
	});
}

/**
 * Job computeDeltaTn called @2.0 in simulate method.
 * In variables: D, V
 * Out variables: deltat
 */
void ExplicitHeatEquationModule::computeDeltaTn()
{
	Real reduction0(numeric_limits<double>::max());
	ENUMERATE_CELL(c, m_mesh->getCells())
	{
		reduction0 = explicitheatequationfreefuncs::minR0(reduction0, m_v[c] / m_d[c]);
	}
	m_deltat = reduction0 * 0.24;
}

/**
 * Job computeFaceConductivity called @2.0 in simulate method.
 * In variables: D
 * Out variables: faceConductivity
 */
void ExplicitHeatEquationModule::computeFaceConductivity()
{
	arcaneParallelForeach(m_mesh->getFaces(), [&](FaceVectorView view)
	{
		ENUMERATE_FACE(f, view)
		{
			final int fId = fFaces;
			Real reduction0(1.0);
			for (CellLocalId c1 : m_mesh->getCellsOfFace(*f))
			{
				final int c1Id = cellsOfFaceF[c1CellsOfFaceF];
				const size_t c1Cells(c1Id);
				reduction0 = explicitheatequationfreefuncs::prodR0(reduction0, m_d[c1]);
			}
			Real reduction1(0.0);
			for (CellLocalId c2 : m_mesh->getCellsOfFace(*f))
			{
				final int c2Id = cellsOfFaceF[c2CellsOfFaceF];
				const size_t c2Cells(c2Id);
				reduction1 = explicitheatequationfreefuncs::sumR0(reduction1, m_d[c2]);
			}
			m_face_conductivity[f] = 2.0 * reduction0 / reduction1;
		}
	});
}

/**
 * Job initU called @2.0 in simulate method.
 * In variables: Xc, u0, vectOne
 * Out variables: u_n
 */
void ExplicitHeatEquationModule::initU()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			if (explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operator-(m_xc[c], m_vect_one)) < 0.5) 
				m_u_n[c] = options.u0();
			else
				m_u_n[c] = 0.0;
		}
	});
}

/**
 * Job setUpTimeLoopN called @2.0 in simulate method.
 * In variables: t_n0
 * Out variables: t_n
 */
void ExplicitHeatEquationModule::setUpTimeLoopN()
{
	m_t_n = m_t_n0();
}

/**
 * Job computeAlphaCoeff called @3.0 in simulate method.
 * In variables: V, Xc, deltat, faceConductivity, faceLength
 * Out variables: alpha
 */
void ExplicitHeatEquationModule::computeAlphaCoeff()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			final int cId = cCells;
			Real alpha_diag(0.0);
			for (CellLocalId d : m_mesh->getNeighbourCells(*c))
			{
				final int dId = neighbourCellsC[dNeighbourCellsC];
				const size_t dCells(dId);
				final int fId = mesh.getCommonFace(cId, dId);
				const size_t fFaces(fId);
				const Real alpha_extra_diag(m_deltat() / m_v[c] * (m_face_length[f] * m_face_conductivity[f]) / explicitheatequationfreefuncs::norm(explicitheatequationfreefuncs::operator-(m_xc[c], m_xc[d])));
				m_alpha[c][d] = alpha_extra_diag;
				alpha_diag = alpha_diag + alpha_extra_diag;
			}
			m_alpha[c][c] = 1 - alpha_diag;
		}
	});
}
