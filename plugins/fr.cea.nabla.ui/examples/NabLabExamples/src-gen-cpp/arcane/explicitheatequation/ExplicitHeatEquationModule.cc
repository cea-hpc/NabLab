/* DO NOT EDIT THIS FILE - it is machine generated */

#include "ExplicitHeatEquationModule.h"
#include <arcane/Concurrency.h>

using namespace Arcane;

/******************** Free functions definitions ********************/

namespace explicitheatequationfreefuncs
{
Real norm(ConstArrayView<Real> a)
{
	return std::sqrt(explicitheatequationfreefuncs::dot(a, a));
}

Real dot(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	Real result(0.0);
	for (Integer i=0; i<a.size(); i++)
	{
		result = result + a[i] * b[i];
	}
	return result;
}

Real det(Real2 a, Real2 b)
{
	return (a[0] * b[1] - a[1] * b[0]);
}

ConstArrayView<Real> sumR1(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	return a + b;
}

Real minR0(Real a, Real b)
{
	return std::min(a, b);
}

Real sumR0(Real a, Real b)
{
	return a + b;
}

Real prodR0(Real a, Real b)
{
	return a * b;
}
}


/******************** Module entry points ********************/

void ExplicitHeatEquationModule::init()
{
	// mesh initialisation
	m_mesh = CartesianMesh2D::create(mesh);

	computeFaceLength(); // @1.0
	computeV(); // @1.0
	initD(); // @1.0
	initTime(); // @1.0
	initXc(); // @1.0
	computeDeltaTn(); // @2.0
	computeFaceConductivity(); // @2.0
	initU(); // @2.0
	setUpTimeLoopN(); // @2.0
	computeAlphaCoeff(); // @3.0
}

void ExplicitHeatEquationModule::compute()
{
	computeTn(); // @1.0
	updateU(); // @1.0
}


/******************** Module methods ********************/

/**
 * Job computeFaceLength called @1.0 in simulate method.
 * In variables: X
 * Out variables: faceLength
 */
void ExplicitHeatEquationModule::computeFaceLength()
{
	arcaneParallelForeach(m_mesh->getFaces(), [&](FaceVectorView view)
	{
		ENUMERATE_FACE(f, view)
		{
			Real reduction0(0.0);
			for (NodeLocalId p : m_mesh->getNodesOfFace(f))
			{
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::norm(m_x[p] - m_x[p]));
			}
			m_face_length[f] = 0.5 * reduction0;
		}
	});
}

/**
 * Job computeTn called @1.0 in executeTimeLoopN method.
 * In variables: deltat, t_n
 * Out variables: t_nplus1
 */
void ExplicitHeatEquationModule::computeTn()
{
	m_t_nplus1 = m_t_n + m_deltat;
}

/**
 * Job computeV called @1.0 in simulate method.
 * In variables: X
 * Out variables: V
 */
void ExplicitHeatEquationModule::computeV()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			Real reduction0(0.0);
			for (NodeLocalId p : m_mesh->getNodesOfCell(c))
			{
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::det(m_x[p], m_x[p]));
			}
			m_v[c] = 0.5 * reduction0;
		}
	});
}

/**
 * Job initD called @1.0 in simulate method.
 * In variables: 
 * Out variables: D
 */
void ExplicitHeatEquationModule::initD()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			m_d[c] = 1.0;
		}
	});
}

/**
 * Job initTime called @1.0 in simulate method.
 * In variables: 
 * Out variables: t_n0
 */
void ExplicitHeatEquationModule::initTime()
{
	m_t_n0 = 0.0;
}

/**
 * Job initXc called @1.0 in simulate method.
 * In variables: X
 * Out variables: Xc
 */
void ExplicitHeatEquationModule::initXc()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			Real2 reduction0({0.0, 0.0});
			for (NodeLocalId p : m_mesh->getNodesOfCell(c))
			{
				reduction0 = explicitheatequationfreefuncs::sumR1(reduction0, m_x[p]);
			}
			m_xc[c] = 0.25 * reduction0;
		}
	});
}

/**
 * Job updateU called @1.0 in executeTimeLoopN method.
 * In variables: alpha, u_n
 * Out variables: u_nplus1
 */
void ExplicitHeatEquationModule::updateU()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			Real reduction0(0.0);
			for (CellLocalId d : m_mesh->getNeighbourCells(c))
			{
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, m_alpha[c][d] * m_u_n[d]);
			}
			m_u_nplus1[c] = m_alpha[c][c] * m_u_n[c] + reduction0;
		}
	});
}

/**
 * Job computeDeltaTn called @2.0 in simulate method.
 * In variables: D, V
 * Out variables: deltat
 */
void ExplicitHeatEquationModule::computeDeltaTn()
{
	Real reduction0(numeric_limits<double>::max());
	for (CellLocalId c : m_mesh->getCells())
	{
		reduction0 = explicitheatequationfreefuncs::minR0(reduction0, m_v[c] / m_d[c]);
	}
	m_deltat = reduction0 * 0.24;
}

/**
 * Job computeFaceConductivity called @2.0 in simulate method.
 * In variables: D
 * Out variables: faceConductivity
 */
void ExplicitHeatEquationModule::computeFaceConductivity()
{
	arcaneParallelForeach(m_mesh->getFaces(), [&](FaceVectorView view)
	{
		ENUMERATE_FACE(f, view)
		{
			Real reduction0(1.0);
			for (CellLocalId c1 : m_mesh->getCellsOfFace(f))
			{
				reduction0 = explicitheatequationfreefuncs::prodR0(reduction0, m_d[c1]);
			}
			Real reduction1(0.0);
			for (CellLocalId c2 : m_mesh->getCellsOfFace(f))
			{
				reduction1 = explicitheatequationfreefuncs::sumR0(reduction1, m_d[c2]);
			}
			m_face_conductivity[f] = 2.0 * reduction0 / reduction1;
		}
	});
}

/**
 * Job initU called @2.0 in simulate method.
 * In variables: Xc, u0, vectOne
 * Out variables: u_n
 */
void ExplicitHeatEquationModule::initU()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			if (explicitheatequationfreefuncs::norm(m_xc[c] - m_vect_one) < 0.5) 
				m_u_n[c] = options.u0;
			else
				m_u_n[c] = 0.0;
		}
	});
}

/**
 * Job setUpTimeLoopN called @2.0 in simulate method.
 * In variables: t_n0
 * Out variables: t_n
 */
void ExplicitHeatEquationModule::setUpTimeLoopN()
{
	m_t_n = m_t_n0;
}

/**
 * Job computeAlphaCoeff called @3.0 in simulate method.
 * In variables: V, Xc, deltat, faceConductivity, faceLength
 * Out variables: alpha
 */
void ExplicitHeatEquationModule::computeAlphaCoeff()
{
	arcaneParallelForeach(m_mesh->getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			Real alphaDiag(0.0);
			for (CellLocalId d : m_mesh->getNeighbourCells(c))
			{
				const Real alphaExtraDiag(m_deltat / m_v[c] * (m_face_length[f] * m_face_conductivity[f]) / explicitheatequationfreefuncs::norm(m_xc[c] - m_xc[d]));
				m_alpha[c][d] = alpha_extra_diag;
				alpha_diag = alpha_diag + alpha_extra_diag;
			}
			m_alpha[c][c] = 1 - alpha_diag;
		}
	});
}
