{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is NabLab ? Presentation of the project NabLab is a open-source research project led by HPC initiative of the CEA . It aims is to provide a productive development way for exascale HPC technologies, flexible enough to be competitive in terms of performances. It is composed of: a numerical analysis Domain Specific Language (DSL) to improve applied mathematicians productivity throughput and enables new algorithmic developments for the construction of hierarchical and composable high-performance scientific applications. an full-fledged environment to edit, interpret, debug specific numerical-analysis sources and to generate optimized code for various C++ targets. Motivation Addressing the major challenges of software productivity and performance portability is becoming necessary to take advantage of emerging extreme-scale computing architectures. As software development costs will continuously increase to address exascale hardware issues, higher-level programming abstraction will facilitate the path to go. There is a growing demand for new programming environments in order to improve scientific productivity, to facilitate the design and implementation, and to optimize large production codes. How it works NabLab is based on Eclipse Modeling Framework (EMF) . The Nabla DSL is realized with Xtext that allows to offer a rich textual editor with syntax coloring, code completion, quick fixes... The code in the editor has an internal EMF model representation. This representation, close to the language, is transformed into a numerical analysis specific Intermediate Representation (IR) also implemented as an Ecore metamodel. The concepts of the IR facilitate the code generation. Currently Kokkos , Open MP and STL based threads C++ backends are implemented. Publications Fostering metamodels and grammars within a dedicated environment for HPC: the NabLab environment Applying Model-Driven Engineering to High-Performance Computing: Experience Report, Lessons Learned, and Remaining Challenges Licence and copyright This program and the accompanying materials are made available under the terms of the Eclipse Public License v. 2.0 . SPDX-License-Identifier: EPL-2.0. Please refer to the license for details. Written by CEA and Contributors. (C) Copyright 2021, by CEA. All rights reserved. All content is the property of the respective authors or their employers. For more information regarding authorship of content, please consult the listed source code repository logs.","title":"What is NabLab"},{"location":"#what-is-nablab","text":"","title":"What is NabLab ?"},{"location":"#presentation-of-the-project","text":"NabLab is a open-source research project led by HPC initiative of the CEA . It aims is to provide a productive development way for exascale HPC technologies, flexible enough to be competitive in terms of performances. It is composed of: a numerical analysis Domain Specific Language (DSL) to improve applied mathematicians productivity throughput and enables new algorithmic developments for the construction of hierarchical and composable high-performance scientific applications. an full-fledged environment to edit, interpret, debug specific numerical-analysis sources and to generate optimized code for various C++ targets.","title":"Presentation of the project"},{"location":"#motivation","text":"Addressing the major challenges of software productivity and performance portability is becoming necessary to take advantage of emerging extreme-scale computing architectures. As software development costs will continuously increase to address exascale hardware issues, higher-level programming abstraction will facilitate the path to go. There is a growing demand for new programming environments in order to improve scientific productivity, to facilitate the design and implementation, and to optimize large production codes.","title":"Motivation"},{"location":"#how-it-works","text":"NabLab is based on Eclipse Modeling Framework (EMF) . The Nabla DSL is realized with Xtext that allows to offer a rich textual editor with syntax coloring, code completion, quick fixes... The code in the editor has an internal EMF model representation. This representation, close to the language, is transformed into a numerical analysis specific Intermediate Representation (IR) also implemented as an Ecore metamodel. The concepts of the IR facilitate the code generation. Currently Kokkos , Open MP and STL based threads C++ backends are implemented.","title":"How it works"},{"location":"#publications","text":"Fostering metamodels and grammars within a dedicated environment for HPC: the NabLab environment Applying Model-Driven Engineering to High-Performance Computing: Experience Report, Lessons Learned, and Remaining Challenges","title":"Publications"},{"location":"#licence-and-copyright","text":"This program and the accompanying materials are made available under the terms of the Eclipse Public License v. 2.0 . SPDX-License-Identifier: EPL-2.0. Please refer to the license for details. Written by CEA and Contributors. (C) Copyright 2021, by CEA. All rights reserved. All content is the property of the respective authors or their employers. For more information regarding authorship of content, please consult the listed source code repository logs.","title":"Licence and copyright"},{"location":"debug/","text":"Monitoring and debugging NabLab debugger is part of the Debug4Science project . Coming soon...","title":"Monitoring and debugging"},{"location":"debug/#monitoring-and-debugging","text":"NabLab debugger is part of the Debug4Science project . Coming soon...","title":"Monitoring and debugging"},{"location":"firstextension/","text":"My first extension Coming soon...","title":"My first extension"},{"location":"firstextension/#my-first-extension","text":"Coming soon...","title":"My first extension"},{"location":"firstmodule/","text":"My first module Presentation of the problem The aim of this tutorial is to implement a simple equation of diffusion in NabLab: \\[ \\begin{equation} \\begin{cases} \\partial_t u - div(K \\nabla u) &= f \\text{ in } \\Omega \\\\ (K \\nabla u)n &= g \\text{ on } \\partial \\Omega \\end{cases} \\end{equation} \\] In this tutorial the equation is discretized with a finite volume scheme on a 2D cartesian mesh. A constant approximation of u by cell gives: \\[ \\begin{equation} \\begin{aligned} \\frac{u_M^{n+1} - u_M^n}{\\Delta t} &= f_M + \\frac{1}{V_M}\\int_{M}{div(K \\nabla u^n)} \\\\ &= f_M + \\frac{1}{V_M}\\int_{\\partial M}{div(K \\nabla u^n)} \\nu \\\\ &= f_M + \\frac{1}{V_M}\\sum_{M' \\text{neighbor of } M}{K_{MM'} \\frac{u_{M'}^n - u_{M}^n}{MM'}} \\end{aligned} \\end{equation} \\] with \\[ \\begin{equation} K_{MM'} = K \\text{ on } M \\cap M' \\end{equation} \\] Consequently \\[ \\begin{equation} \\begin{aligned} u_M^{n+1} &= \\Delta t f_M + 1 + \\frac{\\Delta t}{V_M} + \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'}}{MM'}} . u_M^n \\\\ &- \\frac{\\Delta t}{V_M} \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'} u_{M'}^n}{MM'}} \\end{aligned} \\end{equation} \\] Creating the project Just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and a module name: Enter Tutorial as project name and HeatEquation as module name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( HeatEquation.n , and HeatEquation.ngen ) in the Tutorial/src/heatequation/ folder: Implementation Items and connectivities TO BE CONTINUED","title":"My first module"},{"location":"firstmodule/#my-first-module","text":"","title":"My first module"},{"location":"firstmodule/#presentation-of-the-problem","text":"The aim of this tutorial is to implement a simple equation of diffusion in NabLab: \\[ \\begin{equation} \\begin{cases} \\partial_t u - div(K \\nabla u) &= f \\text{ in } \\Omega \\\\ (K \\nabla u)n &= g \\text{ on } \\partial \\Omega \\end{cases} \\end{equation} \\] In this tutorial the equation is discretized with a finite volume scheme on a 2D cartesian mesh. A constant approximation of u by cell gives: \\[ \\begin{equation} \\begin{aligned} \\frac{u_M^{n+1} - u_M^n}{\\Delta t} &= f_M + \\frac{1}{V_M}\\int_{M}{div(K \\nabla u^n)} \\\\ &= f_M + \\frac{1}{V_M}\\int_{\\partial M}{div(K \\nabla u^n)} \\nu \\\\ &= f_M + \\frac{1}{V_M}\\sum_{M' \\text{neighbor of } M}{K_{MM'} \\frac{u_{M'}^n - u_{M}^n}{MM'}} \\end{aligned} \\end{equation} \\] with \\[ \\begin{equation} K_{MM'} = K \\text{ on } M \\cap M' \\end{equation} \\] Consequently \\[ \\begin{equation} \\begin{aligned} u_M^{n+1} &= \\Delta t f_M + 1 + \\frac{\\Delta t}{V_M} + \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'}}{MM'}} . u_M^n \\\\ &- \\frac{\\Delta t}{V_M} \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'} u_{M'}^n}{MM'}} \\end{aligned} \\end{equation} \\]","title":"Presentation of the problem"},{"location":"firstmodule/#creating-the-project","text":"Just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and a module name: Enter Tutorial as project name and HeatEquation as module name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( HeatEquation.n , and HeatEquation.ngen ) in the Tutorial/src/heatequation/ folder:","title":"Creating the project"},{"location":"firstmodule/#implementation","text":"","title":"Implementation"},{"location":"firstmodule/#items-and-connectivities","text":"TO BE CONTINUED","title":"Items and connectivities"},{"location":"gettingstarted/","text":"Getting started Download and install Prerequisite NabLab requires Java 11 or later to build & run. Do not forget to set the JAVA_HOME variable to the java installation directory and to update your path. Installing NabLab The latest NabLab environment can be downloaded here . Download the file corresponding to your platform, unzip it and lauch the NabLab executable in the root directory. For Mac users, depending on your security configuration, you have to enter the following command to execute NabLab: xattr -d com.apple.quarantine NabLab.app . Installing NabLab debugger NabLab debugger is part of the Debug4Science project . It is based on GraalVM and Monilog . It is still under development. The temporary installation process is: Download GraalVM community edition 21.0.0 here and extract it in the directory of your choice. Install Graalpython in following the instructions available here . Note that numpy is a supported package of GraalVM: just replace pandas by numpy in the package installation instructions . For Monilog and GraalVM support of NabLab, download the 3 files available here . To install the NabLab and Monilog languages support for GraalVM, type the following command: /path/to/graalvm/bin/gu -L install -f nabla-component.jar . Then create the folder /path/to/graalvm/tools/monilogger and copy the file monilogger.jar into it. Into your NabLab product, click on the menu Help > Install New Software... , a dialog box appears, clic on Add... > Archive and select the graalvm-integration.zip file. In the root directory of your NabLab installation, add the following option to the NabLab.ini file -vm /path/to/graalvm-ce-java11-21.0.0/bin/java . Build via Maven 3.x If you need to build NabLab products (Windows/Linux/MacOS and Eclipse update-site) from the source code (instead of downloading it), run the following command from the root of the repository: mvn clean; mvn verify . Note the ';' after mvn clean . The products resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/products/NabLab-X.Y.Z.yyyymmddHHMM-YOUR_PLATFORM.zip . The Eclipse update-site resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/fr.cea.nabla.updatesite-X.Y.Z.yyyymmddHHMM.zip . If you want to skip tests execution, you can run the following command: mvn clean; mvn verify -Dmaven.test.skip=true First step in the environment Perspective Once the NabLab environment has been launched, the NabLab perspective should be selected. If it is not the case, just select the NabLab perspective from the Window > Perspective > Open Perspective > Other ... > NabLab menu. The NabLab perspective provides a set of Views and wizards shortcuts allowing to easily create and develop NabLab projects. Examples project Just click on the main menu From the File > New > NabLab Examples to import the examples project: A new wizard is launched: Just click on the Finish button to import the examples project that becomes available in the Model Explorer view on the left of the perspective. It contains a set of examples including Glace2D, HeatEquation, ExplicitHeatEquation, IterativeHeatEquation and ImplicitHeatEquation. Code generation To launch code generation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Generate Code Java and C++ source code files are generated in src-gen-java and src-gen-cpp folders respectively. For each C++ folder a CMakeLists.txt file is generated. A LaTeX file containing the content of the jobs and an example of json data file are also generated in the src-gen folder. LaTeX view The LaTeX View is located on the bottom of the NabLab environment. It allows to visualize in an elegant way the formulas contained in a .n file. If you do not use the NabLab perspective the The LaTeX View is not visible. You can access it through the Window > Show View > Other... > NabLab > LaTeX View main menu. This view is automatically updated and synchronized with the selection in the current NabLab editor. Job graph view The Job Graph View can be opened from a ngen file containing an Application , by clicking on F1. It allows to quickly visualize the data flow graph of the application described in the ngen file. Job graph editor NabLab offers another way of visualizing the data flow graph of an application. The Job Graph Editor can be opened from a ngen file containing an Application , by clicking on F2. It allows to visualize bigger graphs than the Job Graph View thanks to an efficient layout.","title":"Getting started"},{"location":"gettingstarted/#getting-started","text":"","title":"Getting started"},{"location":"gettingstarted/#download-and-install","text":"","title":"Download and install"},{"location":"gettingstarted/#prerequisite","text":"NabLab requires Java 11 or later to build & run. Do not forget to set the JAVA_HOME variable to the java installation directory and to update your path.","title":"Prerequisite"},{"location":"gettingstarted/#installing-nablab","text":"The latest NabLab environment can be downloaded here . Download the file corresponding to your platform, unzip it and lauch the NabLab executable in the root directory. For Mac users, depending on your security configuration, you have to enter the following command to execute NabLab: xattr -d com.apple.quarantine NabLab.app .","title":"Installing NabLab"},{"location":"gettingstarted/#installing-nablab-debugger","text":"NabLab debugger is part of the Debug4Science project . It is based on GraalVM and Monilog . It is still under development. The temporary installation process is: Download GraalVM community edition 21.0.0 here and extract it in the directory of your choice. Install Graalpython in following the instructions available here . Note that numpy is a supported package of GraalVM: just replace pandas by numpy in the package installation instructions . For Monilog and GraalVM support of NabLab, download the 3 files available here . To install the NabLab and Monilog languages support for GraalVM, type the following command: /path/to/graalvm/bin/gu -L install -f nabla-component.jar . Then create the folder /path/to/graalvm/tools/monilogger and copy the file monilogger.jar into it. Into your NabLab product, click on the menu Help > Install New Software... , a dialog box appears, clic on Add... > Archive and select the graalvm-integration.zip file. In the root directory of your NabLab installation, add the following option to the NabLab.ini file -vm /path/to/graalvm-ce-java11-21.0.0/bin/java .","title":"Installing NabLab debugger"},{"location":"gettingstarted/#build-via-maven-3x","text":"If you need to build NabLab products (Windows/Linux/MacOS and Eclipse update-site) from the source code (instead of downloading it), run the following command from the root of the repository: mvn clean; mvn verify . Note the ';' after mvn clean . The products resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/products/NabLab-X.Y.Z.yyyymmddHHMM-YOUR_PLATFORM.zip . The Eclipse update-site resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/fr.cea.nabla.updatesite-X.Y.Z.yyyymmddHHMM.zip . If you want to skip tests execution, you can run the following command: mvn clean; mvn verify -Dmaven.test.skip=true","title":"Build via Maven 3.x"},{"location":"gettingstarted/#first-step-in-the-environment","text":"","title":"First step in the environment"},{"location":"gettingstarted/#perspective","text":"Once the NabLab environment has been launched, the NabLab perspective should be selected. If it is not the case, just select the NabLab perspective from the Window > Perspective > Open Perspective > Other ... > NabLab menu. The NabLab perspective provides a set of Views and wizards shortcuts allowing to easily create and develop NabLab projects.","title":"Perspective"},{"location":"gettingstarted/#examples-project","text":"Just click on the main menu From the File > New > NabLab Examples to import the examples project: A new wizard is launched: Just click on the Finish button to import the examples project that becomes available in the Model Explorer view on the left of the perspective. It contains a set of examples including Glace2D, HeatEquation, ExplicitHeatEquation, IterativeHeatEquation and ImplicitHeatEquation.","title":"Examples project"},{"location":"gettingstarted/#code-generation","text":"To launch code generation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Generate Code Java and C++ source code files are generated in src-gen-java and src-gen-cpp folders respectively. For each C++ folder a CMakeLists.txt file is generated. A LaTeX file containing the content of the jobs and an example of json data file are also generated in the src-gen folder.","title":"Code generation"},{"location":"gettingstarted/#latex-view","text":"The LaTeX View is located on the bottom of the NabLab environment. It allows to visualize in an elegant way the formulas contained in a .n file. If you do not use the NabLab perspective the The LaTeX View is not visible. You can access it through the Window > Show View > Other... > NabLab > LaTeX View main menu. This view is automatically updated and synchronized with the selection in the current NabLab editor.","title":"LaTeX view"},{"location":"gettingstarted/#job-graph-view","text":"The Job Graph View can be opened from a ngen file containing an Application , by clicking on F1. It allows to quickly visualize the data flow graph of the application described in the ngen file.","title":"Job graph view"},{"location":"gettingstarted/#job-graph-editor","text":"NabLab offers another way of visualizing the data flow graph of an application. The Job Graph Editor can be opened from a ngen file containing an Application , by clicking on F2. It allows to visualize bigger graphs than the Job Graph View thanks to an efficient layout.","title":"Job graph editor"},{"location":"modulecomposition/","text":"Composing modules Coming soon...","title":"Composing modules"},{"location":"modulecomposition/#composing-modules","text":"Coming soon...","title":"Composing modules"},{"location":"nablablanguage/","text":"NabLab language Module and extensions A NabLab file, extension n , can be a module or an extension . Module A module represents a NabLab program and its definition strictly follows the following sequence: Imports Item types and connectivities Reductions Functions Variables and options Time iterators Jobs A module is generally associated with a NabLab application . Several modules can also be composed into a single application: see module composition documentation. Extension An extension is a way to extent the language with external functions. Its definition strictly follows the following sequence: Imports Reductions Functions Functions of an extension can be called from a NabLab module. To use an extension X, a module has to import the extension with the instruction with X.*; (see below). Note The extension and extension provider mechanisms are the way to call legacy libraries, like linear algebra libraries, from NabLab applications. Extensions provide external functions, i.e. functions with no NabLab body. Those functions are implemented in an another language, generally C or C++. To link NabLab function declaration to its native definition, providers have to be defined: see NabLab extension providers for details. Imports The with keyword allows to import NabLab extensions, libraries of reductions and functions external to the module. NabLab provides two native extensions: Math and Linear Algebra (follow the link to see the available functions and reductions). To use them in your own module, just create an import section as follow: module ImplicitHeatEquation; with Math.*; with LinearAlgebra.*; Items and connectivities Items are elements of a set, typically mesh elements. The various types of items are defined in a set. itemtypes { node, cell, face } Note Sets are surrounded by curly brackets and separated by a comma. A connectivity declaration id defined by a name, its inputs items and an output item or a set of output items. connectivity nodes: \u2192 {node}; // mesh nodes connectivity cells: \u2192 {cell}; // mesh cells connectivity faces: \u2192 {face}; // mesh faces connectivity neighborCells: cell \u2192 {cell}; // neighbor cells of a cell connectivity nodesOfFace: face \u2192 {node}; // nodes of a face connectivity nodesOfCell: cell \u2192 {node}; // nodes of a cell connectivity commonFace: cell \u00d7 cell \u2192 face; // common face of two cells Reductions and functions Reductions Reductions are defined by their name, neutral element (seed of the reduction) and type corresponding to the type off their arguments and also their return type. They can be overloaded: it is possible to create multiple reductions with same name and different type. def \u2211, 0.0: \u211d, (a, b) \u2192 return a + b; def \u2211, 0.0: x | \u211d[x], (a, b) \u2192 return a + b; Functions Functions are defined by their name, input arguments, return type and body. They can be overloaded: it is possible to create multiple functions with same name and different input arguments. Function's body is a unique instruction or a block of instructions. It can not refer to global variables. That is the reason why functions are declared before variables. def one: \u2192 \u2115, () \u2192 return 1; // function with no in arg def inc: \u2115 \u2192 \u2115, (a) \u2192 return a+1; // overloaded function inc on \u2115 def inc: \u211d \u2192 \u211d, (a) \u2192 return a+1.0; // overloaded function inc on \u211d def dot: x | \u211d[x] \u00d7 \u211d[x] \u2192 \u211d, (a , b) \u2192 { let \u211d result = 0.0; \u2200 i \u2208 [0;x[, result = result + a[i]*b[i]; return result; } In an extension, functions can be external, without body definition. In this case the definition of an extension provider allows to call a native function (C, C++...). This mechanism allows to use legacy libraries, like linear algebra libraries. Note External functions, i.e. functions with no body, are not allowed in modules, only in extensions. Global variables Global variables are defined by their type, name and eventually one or several supports representing the connectivity on which the variable lives. Note UTF-8 characters for variable names are supported to fit domain scientists classical notations, for example \u03b4t, \u03c1... The type of the variable is one of the 3 NabLab base types: boolean \u213e , integer \u2115 or real \u211d . It can be scalar or array. Arrays are defined by giving a comma separated list of sizes between brackets. Note NabLab text editor offers a contextual code completion and interactive ASCII template sequences to enter UTF-8 keywords. \u213e is_ok; // boolean \u2115 i, j; // integers \u211d t, \u03b4t; // reals \u211d[2] x; // 1 dimension real array \u211d[2, 2] xx; // 2 dimensions real array \u211d[2] X{nodes}; // array of 2 reals on each node \u211d[2, 2] Ajr{cells, nodesOfCell}; // 2x2 matrix on each node of each cell Multiple variables can be declared in the same instruction into a comma separated list. \u211d t, \u03b4t; \u211d c{cells}, m{cells}, p{cells}; A variable initialized with a default value is preceded by the let keyword. It is not possible to assign several variables in one definition. A user option is preceded by the option keyword. The option can be set in a Json data file. If the option has a default value it becomes optional in the data file otherwise the execution will produce an error if the option has no default value and is not found in the data file. let \u211d \u03b3 = 3.0; // real scalar let \u211d[2] N = [0.0, 1.0]; // 1 dimension real array let \u211d[2, 2] N = [ [0.0, 1.0], N ]; // 2 dimensions real array let \u2115[2,2] I = [ [1, 0], [0, 1] ]; // 2 dimensions int array option \u2115 maxIter = 200; // optional integer user option option \u211d maxTime; // mandatory real user option Time iterators The iterate section is used to define time iterators and the stop conditions of their time loop. // definition of time iterator n iterate n while (residual > \u03b5); Variables can be referenced with defined iterators. In the above example defining a n time iterator, a variable can be referenced at n=0 , n and n+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} and t^{n+1} . Note For the moment, only the +1 increment of the iterator is allowed. Is is possible to define several time iterators into a comma separated list: the iterator of index k+1 is then nested into the iterator of index k . // definition of time iterators n and k. iterate n while (t^{n+1} < stopTime && n+1 < maxIterations), k while (residual > \u03b5 && check(k+1 < maxIterationsK)); In case of several iterators, variables can be referenced by a list of defined time iterators, respecting the order of inclusion. In the above example defining n and k inside n, a variable can be referenced by n=0 , n , n+1 , n+1, k=0 , n+1, n , and n+1, k+1 . variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} , t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} . It is also possible to define a block of inner iterators to define several loops included in a main time loop. iterate n while (t^{n+1} < maxTime && n+1 < maxIter), { k while (k+1 < maxIterK); l while (l+1 < maxIterL); } In the above example defining n, k inside n and l inside n, a variable can be referenced by n=0 , n , n+1 and either n+1, k=0 , n+1, n , n+1, k+1 or n+1, l=0 , n+1, l , n+1, l+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} and either t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} or t^{n+1, l=0} , t^{n+1, l} , t^{n+1, l+1} . Note For a time iterator n , if a variable is initialized at n=0 , NabLab automatically initializes n with n=0 value of the variable at the beginning of the time loop and with n+1 value during loop iterations. Jobs Jobs are identified by a name, starting with an upper case. They are composed of an instruction, or a block of instructions. Ini: j = 0; IniTime: t^{n=0} = 0.0; ComputeDensity: \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; The execution of a NabLab program does not start at its beginning and jobs execution order does not correspond to their position in the file. During the compilation phase, the data flow graph of the program is computed according to input and output variables of each job. Jobs are annotated with a at statement corresponding to its hierarchical logical time (HLT). The HLT concept is explicitly expressed to go beyond the classical single-program-multiple-data or bulk-synchronous-parallel programming models. The at logical timestamp explicitly declares the task-based parallelism of jobs. However, this way to schedule jobs imposes to have a dedicated tool to visualize the graph representing the program execution. This feature has been developed and integrated into the NabLab environment (see getting started documentation for details). Instructions The main instructions of the language are: local variable and set definitions, affectations, blocks, loops, conditionals. An instruction ends with the ; character except blocks surrounded by curly brackets. Local variables and set definitions Local variables can be defined with the same syntax than global ones but local definitions include neither variables with supports nor user options. Set of items can be defined locally by calling a connectivity, like this: set my_cells = cells(); Affectations An affectation is composed of a variable reference, the = character and an expression. \u03c1_ic = \u03c1IniZg; t^{n=0} = 0.0; N = [0.0, 1.0]; Cjr_ic{j,r} = 0.5 * perp(X^{n=0}{r+1} - X^{n=0}{r-1}); Blocks A block is a list of instructions. It follows the Composite Design Pattern : The block is an instruction and contains itself a list of instructions. The block is surrounded with curly brackets. { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; } Loops NabLab provides two instructions for loops: while and \u2200 . The while is composed of a condition, which is an expression, and an instruction that can be a block. while (t^{n} < 5.0) x = 0; while (residual > \u03b5) { alpha = 1.0 / det(a); I = [ [1.0, 0.0], [0.0, 1.0] ]; } The \u2200 loop provides two kinds of iteration blocks: interval and space iterators. Interval are going from 0 to n-1 with n an integer result of an expression. \u2200i\u2208[0;5[, x = 0; \u2200i\u2208[0;x+4[, { beta = i * a; A = [i, 0]; } Space iterators allows to loop on connectivity sets. // loop on cells \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; // loop on topNodes \u2200r\u2208topNodes(), { let \u211d[2] N = [0.0, 1.0]; let \u211d[2,2] NxN = tensProduct(N,N); let \u211d[2,2] IcP = I - NxN; bt{r} = matVectProduct(IcP, b{r}); } // loop on cells with a reduction on nodesOfCell \u2200j\u2208cells(), V{j} = 0.5 * \u2211{r\u2208nodesOfCell(j)}(dot(C{j,r}, X^{n}{r})); // loop on cells and inner loop on nodesOfCell \u2200j\u2208cells(), \u2200r\u2208nodesOfCell(j), Ajr{j,r} = ((\u03c1{j} * c{j}) / l{j,r}) * tensProduct(C{j,r}, C{j,r}); It is possible to define a loop iterator counter viewed as an integer local variable. \u2200j, ij \u2208cells(), \u03c1{j} = V{j} * ij; Conditionals Conditionals are defined with the classical if , else sequence. The condition in the if instruction is an expression, like for the while instruction. The else clause is optional. if (center[0] < xInterface) { \u03c1_ic = \u03c1IniZg; p_ic = pIniZg; } else { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; } Expressions Expressions are composed of the following elements: Unary operators minus - and not ! Binary operators add + , substract - , multiply * , divide / and modulo % Comparison operators greater than > , greater than or equal >= , less than < , less than or equal <= , equal == , not equal != Boolean operators and && and or || Contracted if operator (condition) ? true : false Min and max constants for integer and real base types: \u2115.MinValue , \u2115.MaxValue , \u211d.MinValue , \u211d.MaxValue Array initializations by comma separated list of expressions between brackets, for example [1, 2+3, -5] for \u2115[3] , [ [1.1, 1.2], [2.1, 2.2], [3.1, 3.2] ] for \u211d[3,2] Argument/variable references and reduction/function calls detailed below. Arguments and variable references Function arguments and variables are referenced by their name that can be followed by: A list of time iterators surrounded by the ^{ } and separated by a comma: t^{n+1} , t^{n+1, k} For variables with a support, a list of space iterators surrounded by the { } and separated by a comma: P{j} , Ajr{j, r} . Iterators are defined by loops and reductions. Iterators can have an increment, like X{r+1} or X{r-1} , to access the item before or after the original iterator in the set where it is defined. For arrays, a list of indices surrounded by [ ] and separated by a comma: X[0] , Y[i, 0] . Indices are expressions. Reduction and function calls A reduction call includes an iteration on a set or interval, like for a space iterator loop, and an expression of the type of the reduction. For example, to compute the sum of a real variable P defined on cells, the call includes the cells set iterator and the variable reference P{j} : let \u211d sum = \u2211{j\u2208cells()}(P{j}); A function call is defined by the name of the function and the right number and type of input arguments as expressions: let \u211d my_cos = cos(3.14 + 3.14);","title":"NabLab language reference"},{"location":"nablablanguage/#nablab-language","text":"","title":"NabLab language"},{"location":"nablablanguage/#module-and-extensions","text":"A NabLab file, extension n , can be a module or an extension .","title":"Module and extensions"},{"location":"nablablanguage/#module","text":"A module represents a NabLab program and its definition strictly follows the following sequence: Imports Item types and connectivities Reductions Functions Variables and options Time iterators Jobs A module is generally associated with a NabLab application . Several modules can also be composed into a single application: see module composition documentation.","title":"Module"},{"location":"nablablanguage/#extension","text":"An extension is a way to extent the language with external functions. Its definition strictly follows the following sequence: Imports Reductions Functions Functions of an extension can be called from a NabLab module. To use an extension X, a module has to import the extension with the instruction with X.*; (see below). Note The extension and extension provider mechanisms are the way to call legacy libraries, like linear algebra libraries, from NabLab applications. Extensions provide external functions, i.e. functions with no NabLab body. Those functions are implemented in an another language, generally C or C++. To link NabLab function declaration to its native definition, providers have to be defined: see NabLab extension providers for details.","title":"Extension"},{"location":"nablablanguage/#imports","text":"The with keyword allows to import NabLab extensions, libraries of reductions and functions external to the module. NabLab provides two native extensions: Math and Linear Algebra (follow the link to see the available functions and reductions). To use them in your own module, just create an import section as follow: module ImplicitHeatEquation; with Math.*; with LinearAlgebra.*;","title":"Imports"},{"location":"nablablanguage/#items-and-connectivities","text":"Items are elements of a set, typically mesh elements. The various types of items are defined in a set. itemtypes { node, cell, face } Note Sets are surrounded by curly brackets and separated by a comma. A connectivity declaration id defined by a name, its inputs items and an output item or a set of output items. connectivity nodes: \u2192 {node}; // mesh nodes connectivity cells: \u2192 {cell}; // mesh cells connectivity faces: \u2192 {face}; // mesh faces connectivity neighborCells: cell \u2192 {cell}; // neighbor cells of a cell connectivity nodesOfFace: face \u2192 {node}; // nodes of a face connectivity nodesOfCell: cell \u2192 {node}; // nodes of a cell connectivity commonFace: cell \u00d7 cell \u2192 face; // common face of two cells","title":"Items and connectivities"},{"location":"nablablanguage/#reductions-and-functions","text":"","title":"Reductions and functions"},{"location":"nablablanguage/#reductions","text":"Reductions are defined by their name, neutral element (seed of the reduction) and type corresponding to the type off their arguments and also their return type. They can be overloaded: it is possible to create multiple reductions with same name and different type. def \u2211, 0.0: \u211d, (a, b) \u2192 return a + b; def \u2211, 0.0: x | \u211d[x], (a, b) \u2192 return a + b;","title":"Reductions"},{"location":"nablablanguage/#functions","text":"Functions are defined by their name, input arguments, return type and body. They can be overloaded: it is possible to create multiple functions with same name and different input arguments. Function's body is a unique instruction or a block of instructions. It can not refer to global variables. That is the reason why functions are declared before variables. def one: \u2192 \u2115, () \u2192 return 1; // function with no in arg def inc: \u2115 \u2192 \u2115, (a) \u2192 return a+1; // overloaded function inc on \u2115 def inc: \u211d \u2192 \u211d, (a) \u2192 return a+1.0; // overloaded function inc on \u211d def dot: x | \u211d[x] \u00d7 \u211d[x] \u2192 \u211d, (a , b) \u2192 { let \u211d result = 0.0; \u2200 i \u2208 [0;x[, result = result + a[i]*b[i]; return result; } In an extension, functions can be external, without body definition. In this case the definition of an extension provider allows to call a native function (C, C++...). This mechanism allows to use legacy libraries, like linear algebra libraries. Note External functions, i.e. functions with no body, are not allowed in modules, only in extensions.","title":"Functions"},{"location":"nablablanguage/#global-variables","text":"Global variables are defined by their type, name and eventually one or several supports representing the connectivity on which the variable lives. Note UTF-8 characters for variable names are supported to fit domain scientists classical notations, for example \u03b4t, \u03c1... The type of the variable is one of the 3 NabLab base types: boolean \u213e , integer \u2115 or real \u211d . It can be scalar or array. Arrays are defined by giving a comma separated list of sizes between brackets. Note NabLab text editor offers a contextual code completion and interactive ASCII template sequences to enter UTF-8 keywords. \u213e is_ok; // boolean \u2115 i, j; // integers \u211d t, \u03b4t; // reals \u211d[2] x; // 1 dimension real array \u211d[2, 2] xx; // 2 dimensions real array \u211d[2] X{nodes}; // array of 2 reals on each node \u211d[2, 2] Ajr{cells, nodesOfCell}; // 2x2 matrix on each node of each cell Multiple variables can be declared in the same instruction into a comma separated list. \u211d t, \u03b4t; \u211d c{cells}, m{cells}, p{cells}; A variable initialized with a default value is preceded by the let keyword. It is not possible to assign several variables in one definition. A user option is preceded by the option keyword. The option can be set in a Json data file. If the option has a default value it becomes optional in the data file otherwise the execution will produce an error if the option has no default value and is not found in the data file. let \u211d \u03b3 = 3.0; // real scalar let \u211d[2] N = [0.0, 1.0]; // 1 dimension real array let \u211d[2, 2] N = [ [0.0, 1.0], N ]; // 2 dimensions real array let \u2115[2,2] I = [ [1, 0], [0, 1] ]; // 2 dimensions int array option \u2115 maxIter = 200; // optional integer user option option \u211d maxTime; // mandatory real user option","title":"Global variables"},{"location":"nablablanguage/#time-iterators","text":"The iterate section is used to define time iterators and the stop conditions of their time loop. // definition of time iterator n iterate n while (residual > \u03b5); Variables can be referenced with defined iterators. In the above example defining a n time iterator, a variable can be referenced at n=0 , n and n+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} and t^{n+1} . Note For the moment, only the +1 increment of the iterator is allowed. Is is possible to define several time iterators into a comma separated list: the iterator of index k+1 is then nested into the iterator of index k . // definition of time iterators n and k. iterate n while (t^{n+1} < stopTime && n+1 < maxIterations), k while (residual > \u03b5 && check(k+1 < maxIterationsK)); In case of several iterators, variables can be referenced by a list of defined time iterators, respecting the order of inclusion. In the above example defining n and k inside n, a variable can be referenced by n=0 , n , n+1 , n+1, k=0 , n+1, n , and n+1, k+1 . variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} , t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} . It is also possible to define a block of inner iterators to define several loops included in a main time loop. iterate n while (t^{n+1} < maxTime && n+1 < maxIter), { k while (k+1 < maxIterK); l while (l+1 < maxIterL); } In the above example defining n, k inside n and l inside n, a variable can be referenced by n=0 , n , n+1 and either n+1, k=0 , n+1, n , n+1, k+1 or n+1, l=0 , n+1, l , n+1, l+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} and either t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} or t^{n+1, l=0} , t^{n+1, l} , t^{n+1, l+1} . Note For a time iterator n , if a variable is initialized at n=0 , NabLab automatically initializes n with n=0 value of the variable at the beginning of the time loop and with n+1 value during loop iterations.","title":"Time iterators"},{"location":"nablablanguage/#jobs","text":"Jobs are identified by a name, starting with an upper case. They are composed of an instruction, or a block of instructions. Ini: j = 0; IniTime: t^{n=0} = 0.0; ComputeDensity: \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; The execution of a NabLab program does not start at its beginning and jobs execution order does not correspond to their position in the file. During the compilation phase, the data flow graph of the program is computed according to input and output variables of each job. Jobs are annotated with a at statement corresponding to its hierarchical logical time (HLT). The HLT concept is explicitly expressed to go beyond the classical single-program-multiple-data or bulk-synchronous-parallel programming models. The at logical timestamp explicitly declares the task-based parallelism of jobs. However, this way to schedule jobs imposes to have a dedicated tool to visualize the graph representing the program execution. This feature has been developed and integrated into the NabLab environment (see getting started documentation for details).","title":"Jobs"},{"location":"nablablanguage/#instructions","text":"The main instructions of the language are: local variable and set definitions, affectations, blocks, loops, conditionals. An instruction ends with the ; character except blocks surrounded by curly brackets.","title":"Instructions"},{"location":"nablablanguage/#local-variables-and-set-definitions","text":"Local variables can be defined with the same syntax than global ones but local definitions include neither variables with supports nor user options. Set of items can be defined locally by calling a connectivity, like this: set my_cells = cells();","title":"Local variables and set definitions"},{"location":"nablablanguage/#affectations","text":"An affectation is composed of a variable reference, the = character and an expression. \u03c1_ic = \u03c1IniZg; t^{n=0} = 0.0; N = [0.0, 1.0]; Cjr_ic{j,r} = 0.5 * perp(X^{n=0}{r+1} - X^{n=0}{r-1});","title":"Affectations"},{"location":"nablablanguage/#blocks","text":"A block is a list of instructions. It follows the Composite Design Pattern : The block is an instruction and contains itself a list of instructions. The block is surrounded with curly brackets. { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; }","title":"Blocks"},{"location":"nablablanguage/#loops","text":"NabLab provides two instructions for loops: while and \u2200 . The while is composed of a condition, which is an expression, and an instruction that can be a block. while (t^{n} < 5.0) x = 0; while (residual > \u03b5) { alpha = 1.0 / det(a); I = [ [1.0, 0.0], [0.0, 1.0] ]; } The \u2200 loop provides two kinds of iteration blocks: interval and space iterators. Interval are going from 0 to n-1 with n an integer result of an expression. \u2200i\u2208[0;5[, x = 0; \u2200i\u2208[0;x+4[, { beta = i * a; A = [i, 0]; } Space iterators allows to loop on connectivity sets. // loop on cells \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; // loop on topNodes \u2200r\u2208topNodes(), { let \u211d[2] N = [0.0, 1.0]; let \u211d[2,2] NxN = tensProduct(N,N); let \u211d[2,2] IcP = I - NxN; bt{r} = matVectProduct(IcP, b{r}); } // loop on cells with a reduction on nodesOfCell \u2200j\u2208cells(), V{j} = 0.5 * \u2211{r\u2208nodesOfCell(j)}(dot(C{j,r}, X^{n}{r})); // loop on cells and inner loop on nodesOfCell \u2200j\u2208cells(), \u2200r\u2208nodesOfCell(j), Ajr{j,r} = ((\u03c1{j} * c{j}) / l{j,r}) * tensProduct(C{j,r}, C{j,r}); It is possible to define a loop iterator counter viewed as an integer local variable. \u2200j, ij \u2208cells(), \u03c1{j} = V{j} * ij;","title":"Loops"},{"location":"nablablanguage/#conditionals","text":"Conditionals are defined with the classical if , else sequence. The condition in the if instruction is an expression, like for the while instruction. The else clause is optional. if (center[0] < xInterface) { \u03c1_ic = \u03c1IniZg; p_ic = pIniZg; } else { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; }","title":"Conditionals"},{"location":"nablablanguage/#expressions","text":"Expressions are composed of the following elements: Unary operators minus - and not ! Binary operators add + , substract - , multiply * , divide / and modulo % Comparison operators greater than > , greater than or equal >= , less than < , less than or equal <= , equal == , not equal != Boolean operators and && and or || Contracted if operator (condition) ? true : false Min and max constants for integer and real base types: \u2115.MinValue , \u2115.MaxValue , \u211d.MinValue , \u211d.MaxValue Array initializations by comma separated list of expressions between brackets, for example [1, 2+3, -5] for \u2115[3] , [ [1.1, 1.2], [2.1, 2.2], [3.1, 3.2] ] for \u211d[3,2] Argument/variable references and reduction/function calls detailed below.","title":"Expressions"},{"location":"nablablanguage/#arguments-and-variable-references","text":"Function arguments and variables are referenced by their name that can be followed by: A list of time iterators surrounded by the ^{ } and separated by a comma: t^{n+1} , t^{n+1, k} For variables with a support, a list of space iterators surrounded by the { } and separated by a comma: P{j} , Ajr{j, r} . Iterators are defined by loops and reductions. Iterators can have an increment, like X{r+1} or X{r-1} , to access the item before or after the original iterator in the set where it is defined. For arrays, a list of indices surrounded by [ ] and separated by a comma: X[0] , Y[i, 0] . Indices are expressions.","title":"Arguments and variable references"},{"location":"nablablanguage/#reduction-and-function-calls","text":"A reduction call includes an iteration on a set or interval, like for a space iterator loop, and an expression of the type of the reduction. For example, to compute the sum of a real variable P defined on cells, the call includes the cells set iterator and the variable reference P{j} : let \u211d sum = \u2211{j\u2208cells()}(P{j}); A function call is defined by the name of the function and the right number and type of input arguments as expressions: let \u211d my_cos = cos(3.14 + 3.14);","title":"Reduction and function calls"},{"location":"ngenlanguage/","text":"Ngen language Coming soon...","title":"Ngen language reference"},{"location":"ngenlanguage/#ngen-language","text":"Coming soon...","title":"Ngen language"}]}