{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is NabLab ? Presentation of the project NabLab is a open-source research project led by HPC initiative of the CEA . It aims is to provide a productive development way for exascale HPC technologies, flexible enough to be competitive in terms of performances. It is composed of: a numerical analysis Domain Specific Language (DSL) to improve applied mathematicians productivity throughput and enables new algorithmic developments for the construction of hierarchical and composable high-performance scientific applications. an full-fledged environment to edit, interpret, debug specific numerical-analysis sources and to generate optimized code for various C++ targets. Motivation Addressing the major challenges of software productivity and performance portability is becoming necessary to take advantage of emerging extreme-scale computing architectures. As software development costs will continuously increase to address exascale hardware issues, higher-level programming abstraction will facilitate the path to go. There is a growing demand for new programming environments in order to improve scientific productivity, to facilitate the design and implementation, and to optimize large production codes. How it works NabLab is based on Eclipse Modeling Framework (EMF) . The Nabla DSL is realized with Xtext that allows to offer a rich textual editor with syntax coloring, code completion, quick fixes... The code in the editor has an internal EMF model representation. This representation, close to the language, is transformed into a numerical analysis specific Intermediate Representation (IR) also implemented as an Ecore metamodel. The concepts of the IR facilitate the code generation. Currently Kokkos , Open MP and STL based threads C++ backends are implemented. Publications Fostering metamodels and grammars within a dedicated environment for HPC: the NabLab environment Applying Model-Driven Engineering to High-Performance Computing: Experience Report, Lessons Learned, and Remaining Challenges Licence and copyright This program and the accompanying materials are made available under the terms of the Eclipse Public License v. 2.0 . SPDX-License-Identifier: EPL-2.0. Please refer to the license for details. Written by CEA and Contributors. (C) Copyright 2021, by CEA. All rights reserved. All content is the property of the respective authors or their employers. For more information regarding authorship of content, please consult the listed source code repository logs.","title":"What is NabLab"},{"location":"#what-is-nablab","text":"","title":"What is NabLab ?"},{"location":"#presentation-of-the-project","text":"NabLab is a open-source research project led by HPC initiative of the CEA . It aims is to provide a productive development way for exascale HPC technologies, flexible enough to be competitive in terms of performances. It is composed of: a numerical analysis Domain Specific Language (DSL) to improve applied mathematicians productivity throughput and enables new algorithmic developments for the construction of hierarchical and composable high-performance scientific applications. an full-fledged environment to edit, interpret, debug specific numerical-analysis sources and to generate optimized code for various C++ targets.","title":"Presentation of the project"},{"location":"#motivation","text":"Addressing the major challenges of software productivity and performance portability is becoming necessary to take advantage of emerging extreme-scale computing architectures. As software development costs will continuously increase to address exascale hardware issues, higher-level programming abstraction will facilitate the path to go. There is a growing demand for new programming environments in order to improve scientific productivity, to facilitate the design and implementation, and to optimize large production codes.","title":"Motivation"},{"location":"#how-it-works","text":"NabLab is based on Eclipse Modeling Framework (EMF) . The Nabla DSL is realized with Xtext that allows to offer a rich textual editor with syntax coloring, code completion, quick fixes... The code in the editor has an internal EMF model representation. This representation, close to the language, is transformed into a numerical analysis specific Intermediate Representation (IR) also implemented as an Ecore metamodel. The concepts of the IR facilitate the code generation. Currently Kokkos , Open MP and STL based threads C++ backends are implemented.","title":"How it works"},{"location":"#publications","text":"Fostering metamodels and grammars within a dedicated environment for HPC: the NabLab environment Applying Model-Driven Engineering to High-Performance Computing: Experience Report, Lessons Learned, and Remaining Challenges","title":"Publications"},{"location":"#licence-and-copyright","text":"This program and the accompanying materials are made available under the terms of the Eclipse Public License v. 2.0 . SPDX-License-Identifier: EPL-2.0. Please refer to the license for details. Written by CEA and Contributors. (C) Copyright 2021, by CEA. All rights reserved. All content is the property of the respective authors or their employers. For more information regarding authorship of content, please consult the listed source code repository logs.","title":"Licence and copyright"},{"location":"debug/","text":"Monitoring and debugging NabLab debugger is part of the Debug4Science project . Coming soon...","title":"Monitoring and debugging"},{"location":"debug/#monitoring-and-debugging","text":"NabLab debugger is part of the Debug4Science project . Coming soon...","title":"Monitoring and debugging"},{"location":"firstextension/","text":"My first extension Presentation of the problem Let us imagine the NabLab Swan module simulating the effects of the propagation of seismic waves on sea surface. To wave height variable H and the depth sea variable D need to be initialized thanks to the following InitH and InitD jobs: // wave initialization InitH: \u2200ic\u2208innerCells(), H{ic} = nextWaveHeight(); // depth initialization InitD: if (DConst) \u2200ic\u2208innerCells(), D{ic} = Dini; else \u2200ic\u2208innerCells(), D{ic} = nextDepth(); The nextWaveHeight and nextDepth functions have to access shared scientific data provided by NetCDF in a C language library. The aim of this tutorial is to see how to create the NabLab extension containing the functions and how to implement and package a NabLab extension provider associated to this extension. Creating the project We will create a NabLab extension called BathyLib . The best practice consists in creating an independent project for the extension and its providers. To do that, just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and an extension name: Enter BathyLib as project name, select the Extension radio button and enter BathyLib as extension name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( BathyLib.n , and BathyLib.ngen ) in the Tutorial/src/bathylib/ folder: Note The extension can also be created into the same project as the application, into a separate folder. However, if you plan to share the extension between projects, creating a project for the extension remains the best solution. Defining the extension Double-click on the src/bathylib/BathyLib.n file to open it and declare the nextWaveHeight and nextDepth functions in the NabLab editor like this: extension BathyLib; def nextWaveHeight: \u2192 \u211d; def nextDepth: \u2192 \u211d; The Swan module containing the InitH and InitD jobs need to import the extension. At first the swan project must add the BathyLib project to its dependencies: double-click on the /swan/META-INF/MANIFEST.mf file in the explorer on the left of the window, select the Dependencies tab and click on Add... button in the middle of the panel. In the dialog box, select the BathyLib project and click on the Add button. The swan project depends now on the BathyLib one. Finally, import the BathyLib extension in the Swan.n file to use the BathyLib functions into the Swan module: module Swan; with BathyLib.*; It is noteworthy that the above functions have no body. We will see now how to create the C++ methods providing the glue code to call the NetCDF C functions. Declaring a provider The role of providers is to implement extensions. It is possible to implement several providers for an extension, for example a Java one and a C++ one. In this tutorial we will implement only one C++ provider for the BathyLib extension. The first step to define the provider is to create a ngen file containing the provider definition. Note The ngen file already exists in the project: it has been created by the wizard. If you need to create this ngen file on an existing project, NabLab provides a code generator for that: right-click on the BathyLib.n file and select the Generate nablagen provider file menu. Double-click on the BathyLib.ngen file to open the editor and suppress lines to let only a simple C++ provider as follows: Provider BathyLibCpp : BathyLib { target = StlThread; outputPath = \"/BathyLib/src-cpp/stl-thread\"; } The above example defines a provider named BathyLibCpp that implements BathyLib . This provider will be generated for the StlThread target in the provided outputPath . More information on generation targets are available in the Ngen language reference . Note The implemented extension and the available targets are available by contextual code completion with CTRL-Space keys. The output folder name is src-cpp rather than src-gen-cpp because the content of the folder is not totally generated: it will be filled by the user in the following section. Implementing the provider The aim of the previously defined provider is to implement the nextWaveHeight and nextDepth BathyLib functions. These functions have to be implemented as methods of a C++ class called BathyLibCpp , the name of the provider. To assist the provider implementation, NabLab offers a code generator. Right-click on the BathyLib.ngen file and select the Generate Code menu. Generated files can be observed in the outputPath folder, in our example \"/BathyLib/src-cpp/stl-thread\". The CMakeLists.txt file is full generated and contains recipes to build the library. The IBathyLib.h file contains the interface representing the BathyLib extension. This file is 100% generated: do not edit this file as it is written in the header comment. This file contains the C++ StlThread generator implementation of the NabLab BathyLib extension and a jsonInit method. Note Template functions can not be defined abstract in the interface. Consequently, if the extension implementation generates template functions, they appear as comment in the interface for information. Extension implementation The BathyLib.h and BathyLib.cc files define the C++ class implementing the BathyLib extension represented by the IBathyLib C++ interface. The body of their methods is empty and has to be implemented. In our example the methods will contain glue code in charge of calling the NetCDF functions. The BathyLib.h and BathyLib.cc files can be edited, they will not be overwritten: they are only generated if they do not already exist. If the extension changes, the generation of the provider will change the interface but not the implementation class (never overwritten). Consequently the implemented code will not compile. In this case, copy the signature of the interface's functions and paste them into the implementation class. This model follows the Generation Gap Pattern . Provider initialization using Json NabLab creates providers by calling the default constructor (with no argument). The jsonInit method allows to initialize the provider class if needed. When you implement a provider extension, you are free to inject the Json content you wish. At the beginning of the execution, when the Json data file is read, NabLab will look for Json fields corresponding to extension names with the first letter in lower case; in the above example, bathyLib . This file must be in the block of the module (or extension) using the extension; in the above example in the swan block. { \"swan\": { \"_outputPath_comment\":\"empty outputPath to disable output\", \"outputPath\":\"output\", \"outputPeriod\":10, \"maxIter\":2500000, \"stopTime\":50.0, \"bathyLib\": { \"waveFilename\":\"$ENV{HOME}/workspaces/swan/swan/data/swan/waveCanal.grd\", \"waveVarName\":\"z\" } }, \"mesh\": { \"nbXQuads\":1103, \"nbYQuads\":44, \"xSize\":200.0, \"ySize\":200.0 } } The Json block corresponding to an extension is injected as an argument to the jsonInit method of the extension. In the previous example, the value of the bathyLib field, becomes the value of the jsonContent argument in BathyLib::jsonInit(const char* jsonContent) method. This value is: { \"waveFilename\":\"$ENV{HOME}/workspaces/swan/swan/data/swan/waveCanal.grd\", \"waveVarName\":\"z\" } Configuring dependencies The CMakeLists.txt file generated with the provider is designed to be included in the CMakeLists.txt of the module using the extension, not to be called directly. It is totally generated and is overwritten during each generation: do not edit this file. Nevertheless, the provider sometimes need to add dependencies to external libraries. Fortunately, all NabLab generated CMakeLists.txt files allow to include the content of a Project.cmake file: # OPTIONAL USER OPTIONS IN Project.cmake if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/Project.cmake) include(${CMAKE_CURRENT_SOURCE_DIR}/Project.cmake) endif() The previously defined BathyLibCpp provider depends on NetCDF library. Thus, this dependency has to appear in a Project.cmake file like this: target_link_libraries(bathylibcpp PUBLIC netcdf) Application generation Extension and provider association So, now what do we have to do to inject the provider in an application that imports the extension? Most of the time, nothing! If the target of generation of the application (defined in the ngen file) matches the provider's target or one of its compatible targets (also defined in the ngen file) the matching between extension and provider is automatic. In the example, the Swan application has a unique StlThread generation target and it corresponds to the target field of the BathyLibCpp provider. During the generation of the Swan application, the NabLab console displays a message showing the default match: If several providers are included in the ngen file, the generation process will take the first one which matches the target conditions. To bypass this mechanism, the matching between extension and provider can be explicitly defined in the ngen file of an application for each generation target after the outputPath field. For the Swan application, this is done with the following instruction: StlThread { outputPath = \"/swan/src-gen-cpp/stl-thread\"; extension BathyLib providedBy BathyLibCpp; N_CXX_COMPILER = \"/usr/bin/g++\"; } Once again, the code completion (with CTRL-Space key) proposes the list of extension and the list of providers implementing the extension. Building the application The application can be built as usual: go into the generation directory containing the CMakeLists.txt file (in our example /swan/src-gen-cpp/stl-thread/swan ) and enter the following commands: mkdir build cd build cmake .. make -j4 All the linked libraries will be built in the build directory, including those of the providers. Application interpretation The interpreter operates as the generator to look for a provider matching an extension. The interpreter is written in Java and look for Java providers. Most of the time NabLab users only need C++ code generation and they implement C++ providers. Fortunately, NabLab provides a JNI generation mechanism to call C++ providers from the interpreter (or from a Java application). To trigger the JNI code generation, configure the interpreter target in the ngen file with the desired provider. In our Swan example, the ngen file has to define the following interpreter target: Interpreter { outputPath = \"/swan/src-gen-interpreter\"; extension BathyLib providedBy BathyLibCpp; } To get the JNI code for the interpreter, launch the generation as usual: right-click on the ngen file (in the example Swan.ngen ) and select Generate Code . The NabLab console displays information showing the JNI generation: The generation produces a folder for each JNI provider (name of the provider + jni) and a folder corresponding to the application. In our example, it corresponds to a bathylibcppjni folder for the bathylibcpp provider and a swan folder for the application. To build the generated code, just go into the folder application, /swan/src-gen-interpreter/swan in our example, and build the code as usual: mkdir build cd build cmake .. make -j4 The interpretation needs an additional installation step to provide libraries to the interpreter in: make install . Finally the interpretation process can be triggered as usual: right-click on the ngen file, select Run As > Start Interpretation . Note Do not forget that the JNI generation process is not necessary if your application does not use extension or if you already have a Java provider. In this case, interpretation can be done directly.","title":"My first extension"},{"location":"firstextension/#my-first-extension","text":"","title":"My first extension"},{"location":"firstextension/#presentation-of-the-problem","text":"Let us imagine the NabLab Swan module simulating the effects of the propagation of seismic waves on sea surface. To wave height variable H and the depth sea variable D need to be initialized thanks to the following InitH and InitD jobs: // wave initialization InitH: \u2200ic\u2208innerCells(), H{ic} = nextWaveHeight(); // depth initialization InitD: if (DConst) \u2200ic\u2208innerCells(), D{ic} = Dini; else \u2200ic\u2208innerCells(), D{ic} = nextDepth(); The nextWaveHeight and nextDepth functions have to access shared scientific data provided by NetCDF in a C language library. The aim of this tutorial is to see how to create the NabLab extension containing the functions and how to implement and package a NabLab extension provider associated to this extension.","title":"Presentation of the problem"},{"location":"firstextension/#creating-the-project","text":"We will create a NabLab extension called BathyLib . The best practice consists in creating an independent project for the extension and its providers. To do that, just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and an extension name: Enter BathyLib as project name, select the Extension radio button and enter BathyLib as extension name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( BathyLib.n , and BathyLib.ngen ) in the Tutorial/src/bathylib/ folder: Note The extension can also be created into the same project as the application, into a separate folder. However, if you plan to share the extension between projects, creating a project for the extension remains the best solution.","title":"Creating the project"},{"location":"firstextension/#defining-the-extension","text":"Double-click on the src/bathylib/BathyLib.n file to open it and declare the nextWaveHeight and nextDepth functions in the NabLab editor like this: extension BathyLib; def nextWaveHeight: \u2192 \u211d; def nextDepth: \u2192 \u211d; The Swan module containing the InitH and InitD jobs need to import the extension. At first the swan project must add the BathyLib project to its dependencies: double-click on the /swan/META-INF/MANIFEST.mf file in the explorer on the left of the window, select the Dependencies tab and click on Add... button in the middle of the panel. In the dialog box, select the BathyLib project and click on the Add button. The swan project depends now on the BathyLib one. Finally, import the BathyLib extension in the Swan.n file to use the BathyLib functions into the Swan module: module Swan; with BathyLib.*; It is noteworthy that the above functions have no body. We will see now how to create the C++ methods providing the glue code to call the NetCDF C functions.","title":"Defining the extension"},{"location":"firstextension/#declaring-a-provider","text":"The role of providers is to implement extensions. It is possible to implement several providers for an extension, for example a Java one and a C++ one. In this tutorial we will implement only one C++ provider for the BathyLib extension. The first step to define the provider is to create a ngen file containing the provider definition. Note The ngen file already exists in the project: it has been created by the wizard. If you need to create this ngen file on an existing project, NabLab provides a code generator for that: right-click on the BathyLib.n file and select the Generate nablagen provider file menu. Double-click on the BathyLib.ngen file to open the editor and suppress lines to let only a simple C++ provider as follows: Provider BathyLibCpp : BathyLib { target = StlThread; outputPath = \"/BathyLib/src-cpp/stl-thread\"; } The above example defines a provider named BathyLibCpp that implements BathyLib . This provider will be generated for the StlThread target in the provided outputPath . More information on generation targets are available in the Ngen language reference . Note The implemented extension and the available targets are available by contextual code completion with CTRL-Space keys. The output folder name is src-cpp rather than src-gen-cpp because the content of the folder is not totally generated: it will be filled by the user in the following section.","title":"Declaring a provider"},{"location":"firstextension/#implementing-the-provider","text":"The aim of the previously defined provider is to implement the nextWaveHeight and nextDepth BathyLib functions. These functions have to be implemented as methods of a C++ class called BathyLibCpp , the name of the provider. To assist the provider implementation, NabLab offers a code generator. Right-click on the BathyLib.ngen file and select the Generate Code menu. Generated files can be observed in the outputPath folder, in our example \"/BathyLib/src-cpp/stl-thread\". The CMakeLists.txt file is full generated and contains recipes to build the library. The IBathyLib.h file contains the interface representing the BathyLib extension. This file is 100% generated: do not edit this file as it is written in the header comment. This file contains the C++ StlThread generator implementation of the NabLab BathyLib extension and a jsonInit method. Note Template functions can not be defined abstract in the interface. Consequently, if the extension implementation generates template functions, they appear as comment in the interface for information.","title":"Implementing the provider"},{"location":"firstextension/#extension-implementation","text":"The BathyLib.h and BathyLib.cc files define the C++ class implementing the BathyLib extension represented by the IBathyLib C++ interface. The body of their methods is empty and has to be implemented. In our example the methods will contain glue code in charge of calling the NetCDF functions. The BathyLib.h and BathyLib.cc files can be edited, they will not be overwritten: they are only generated if they do not already exist. If the extension changes, the generation of the provider will change the interface but not the implementation class (never overwritten). Consequently the implemented code will not compile. In this case, copy the signature of the interface's functions and paste them into the implementation class. This model follows the Generation Gap Pattern .","title":"Extension implementation"},{"location":"firstextension/#provider-initialization-using-json","text":"NabLab creates providers by calling the default constructor (with no argument). The jsonInit method allows to initialize the provider class if needed. When you implement a provider extension, you are free to inject the Json content you wish. At the beginning of the execution, when the Json data file is read, NabLab will look for Json fields corresponding to extension names with the first letter in lower case; in the above example, bathyLib . This file must be in the block of the module (or extension) using the extension; in the above example in the swan block. { \"swan\": { \"_outputPath_comment\":\"empty outputPath to disable output\", \"outputPath\":\"output\", \"outputPeriod\":10, \"maxIter\":2500000, \"stopTime\":50.0, \"bathyLib\": { \"waveFilename\":\"$ENV{HOME}/workspaces/swan/swan/data/swan/waveCanal.grd\", \"waveVarName\":\"z\" } }, \"mesh\": { \"nbXQuads\":1103, \"nbYQuads\":44, \"xSize\":200.0, \"ySize\":200.0 } } The Json block corresponding to an extension is injected as an argument to the jsonInit method of the extension. In the previous example, the value of the bathyLib field, becomes the value of the jsonContent argument in BathyLib::jsonInit(const char* jsonContent) method. This value is: { \"waveFilename\":\"$ENV{HOME}/workspaces/swan/swan/data/swan/waveCanal.grd\", \"waveVarName\":\"z\" }","title":"Provider initialization using Json"},{"location":"firstextension/#configuring-dependencies","text":"The CMakeLists.txt file generated with the provider is designed to be included in the CMakeLists.txt of the module using the extension, not to be called directly. It is totally generated and is overwritten during each generation: do not edit this file. Nevertheless, the provider sometimes need to add dependencies to external libraries. Fortunately, all NabLab generated CMakeLists.txt files allow to include the content of a Project.cmake file: # OPTIONAL USER OPTIONS IN Project.cmake if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/Project.cmake) include(${CMAKE_CURRENT_SOURCE_DIR}/Project.cmake) endif() The previously defined BathyLibCpp provider depends on NetCDF library. Thus, this dependency has to appear in a Project.cmake file like this: target_link_libraries(bathylibcpp PUBLIC netcdf)","title":"Configuring dependencies"},{"location":"firstextension/#application-generation","text":"","title":"Application generation"},{"location":"firstextension/#extension-and-provider-association","text":"So, now what do we have to do to inject the provider in an application that imports the extension? Most of the time, nothing! If the target of generation of the application (defined in the ngen file) matches the provider's target or one of its compatible targets (also defined in the ngen file) the matching between extension and provider is automatic. In the example, the Swan application has a unique StlThread generation target and it corresponds to the target field of the BathyLibCpp provider. During the generation of the Swan application, the NabLab console displays a message showing the default match: If several providers are included in the ngen file, the generation process will take the first one which matches the target conditions. To bypass this mechanism, the matching between extension and provider can be explicitly defined in the ngen file of an application for each generation target after the outputPath field. For the Swan application, this is done with the following instruction: StlThread { outputPath = \"/swan/src-gen-cpp/stl-thread\"; extension BathyLib providedBy BathyLibCpp; N_CXX_COMPILER = \"/usr/bin/g++\"; } Once again, the code completion (with CTRL-Space key) proposes the list of extension and the list of providers implementing the extension.","title":"Extension and provider association"},{"location":"firstextension/#building-the-application","text":"The application can be built as usual: go into the generation directory containing the CMakeLists.txt file (in our example /swan/src-gen-cpp/stl-thread/swan ) and enter the following commands: mkdir build cd build cmake .. make -j4 All the linked libraries will be built in the build directory, including those of the providers.","title":"Building the application"},{"location":"firstextension/#application-interpretation","text":"The interpreter operates as the generator to look for a provider matching an extension. The interpreter is written in Java and look for Java providers. Most of the time NabLab users only need C++ code generation and they implement C++ providers. Fortunately, NabLab provides a JNI generation mechanism to call C++ providers from the interpreter (or from a Java application). To trigger the JNI code generation, configure the interpreter target in the ngen file with the desired provider. In our Swan example, the ngen file has to define the following interpreter target: Interpreter { outputPath = \"/swan/src-gen-interpreter\"; extension BathyLib providedBy BathyLibCpp; } To get the JNI code for the interpreter, launch the generation as usual: right-click on the ngen file (in the example Swan.ngen ) and select Generate Code . The NabLab console displays information showing the JNI generation: The generation produces a folder for each JNI provider (name of the provider + jni) and a folder corresponding to the application. In our example, it corresponds to a bathylibcppjni folder for the bathylibcpp provider and a swan folder for the application. To build the generated code, just go into the folder application, /swan/src-gen-interpreter/swan in our example, and build the code as usual: mkdir build cd build cmake .. make -j4 The interpretation needs an additional installation step to provide libraries to the interpreter in: make install . Finally the interpretation process can be triggered as usual: right-click on the ngen file, select Run As > Start Interpretation . Note Do not forget that the JNI generation process is not necessary if your application does not use extension or if you already have a Java provider. In this case, interpretation can be done directly.","title":"Application interpretation"},{"location":"firstmodule/","text":"My first module Presentation of the problem The aim of this tutorial is to implement a simple equation of diffusion in NabLab: \\[ \\begin{equation} \\begin{cases} \\partial_t u - div(K \\nabla u) &= f \\text{ in } \\Omega \\\\ (K \\nabla u)n &= g \\text{ on } \\partial \\Omega \\end{cases} \\end{equation} \\] In this tutorial the equation is discretized with a finite volume scheme on a 2D cartesian mesh. A constant approximation of u by cell gives: \\[ \\begin{equation} \\begin{aligned} \\frac{u_M^{n+1} - u_M^n}{\\Delta t} &= f_M + \\frac{1}{V_M}\\int_{M}{div(K \\nabla u^n)} \\\\ &= f_M + \\frac{1}{V_M}\\int_{\\partial M}{div(K \\nabla u^n)} \\nu \\\\ &= f_M + \\frac{1}{V_M}\\sum_{M' \\text{neighbor of } M}{K_{MM'} \\frac{u_{M'}^n - u_{M}^n}{MM'}} \\end{aligned} \\end{equation} \\] with \\[ \\begin{equation} K_{MM'} = K \\text{ on } M \\cap M' \\end{equation} \\] Consequently \\[ \\begin{equation} \\begin{aligned} u_M^{n+1} &= \\Delta t f_M + 1 + \\frac{\\Delta t}{V_M} + \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'}}{MM'}} . u_M^n \\\\ &- \\frac{\\Delta t}{V_M} \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'} u_{M'}^n}{MM'}} \\end{aligned} \\end{equation} \\] Creating the project Just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and a module name: Enter Tutorial as project name, select the Module radio button, enter HeatEquation as module name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( HeatEquation.n , and HeatEquation.ngen ) in the Tutorial/src/heatequation/ folder: Implementation Items and connectivities TO BE CONTINUED","title":"My first module"},{"location":"firstmodule/#my-first-module","text":"","title":"My first module"},{"location":"firstmodule/#presentation-of-the-problem","text":"The aim of this tutorial is to implement a simple equation of diffusion in NabLab: \\[ \\begin{equation} \\begin{cases} \\partial_t u - div(K \\nabla u) &= f \\text{ in } \\Omega \\\\ (K \\nabla u)n &= g \\text{ on } \\partial \\Omega \\end{cases} \\end{equation} \\] In this tutorial the equation is discretized with a finite volume scheme on a 2D cartesian mesh. A constant approximation of u by cell gives: \\[ \\begin{equation} \\begin{aligned} \\frac{u_M^{n+1} - u_M^n}{\\Delta t} &= f_M + \\frac{1}{V_M}\\int_{M}{div(K \\nabla u^n)} \\\\ &= f_M + \\frac{1}{V_M}\\int_{\\partial M}{div(K \\nabla u^n)} \\nu \\\\ &= f_M + \\frac{1}{V_M}\\sum_{M' \\text{neighbor of } M}{K_{MM'} \\frac{u_{M'}^n - u_{M}^n}{MM'}} \\end{aligned} \\end{equation} \\] with \\[ \\begin{equation} K_{MM'} = K \\text{ on } M \\cap M' \\end{equation} \\] Consequently \\[ \\begin{equation} \\begin{aligned} u_M^{n+1} &= \\Delta t f_M + 1 + \\frac{\\Delta t}{V_M} + \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'}}{MM'}} . u_M^n \\\\ &- \\frac{\\Delta t}{V_M} \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'} u_{M'}^n}{MM'}} \\end{aligned} \\end{equation} \\]","title":"Presentation of the problem"},{"location":"firstmodule/#creating-the-project","text":"Just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and a module name: Enter Tutorial as project name, select the Module radio button, enter HeatEquation as module name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( HeatEquation.n , and HeatEquation.ngen ) in the Tutorial/src/heatequation/ folder:","title":"Creating the project"},{"location":"firstmodule/#implementation","text":"","title":"Implementation"},{"location":"firstmodule/#items-and-connectivities","text":"TO BE CONTINUED","title":"Items and connectivities"},{"location":"gettingstarted/","text":"Getting started Download and install Prerequisite NabLab requires Java 11 or later to build & run. Do not forget to set the JAVA_HOME variable to the java installation directory and to update your path. Installing NabLab The latest NabLab environment can be downloaded here . Download the file corresponding to your platform, unzip it and lauch the NabLab executable in the root directory. For Mac users, depending on your security configuration, you have to enter the following command to execute NabLab: xattr -d com.apple.quarantine NabLab.app . Installing NabLab debugger NabLab debugger is part of the Debug4Science project . It is based on GraalVM and Monilog . It is still under development. The installation process is: To install the debugger, download monilog4nablab-0.4.0.zip here and follow the Monilog4NabLab installation instructions . As explained in the installation instructions, GraalVM is installed in the folder of your IDE. Install Graalpython in following the instructions available here . You can also install numpy which is a supported package of GraalVM: just replace pandas by numpy in the package installation instructions . Finally, in the root directory of your NabLab installation, add the following option to the NabLab.ini file -vm /path/to/graalvm-ce-java11-21.0.0/bin/java . Build via Maven 3.x If you need to build NabLab products (Windows/Linux/MacOS and Eclipse update-site) from the source code (instead of downloading it), run the following command from the root of the repository: mvn clean; mvn verify . Note the ';' after mvn clean . The products resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/products/NabLab-X.Y.Z.yyyymmddHHMM-YOUR_PLATFORM.zip . The Eclipse update-site resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/fr.cea.nabla.updatesite-X.Y.Z.yyyymmddHHMM.zip . If you want to skip tests execution, you can run the following command: mvn clean; mvn verify -Dmaven.test.skip=true First step in the environment Overview The NabLab environment is based on the Eclipse Modeling Framework (EMF). The central part of the NabLab environment displays a textual editor, based on Xtext which provides contextual code completion, code folding, syntax highlighting, error detection, quick fixes, variable scoping, and type checking. The left part of the environment proposes a model explorer and a dedicated interactive outline view to navigate easily through the textual editor. The bottom part is composed of several views including a rich LaTeX visualization of the selection in the editor. A graphical editor based on Sirius allows to visualize the data flow graph between jobs. Perspective Once the NabLab environment has been launched, the NabLab perspective should be selected. If it is not the case, just select the NabLab perspective from the Window > Perspective > Open Perspective > Other ... > NabLab menu. The NabLab perspective provides a set of Views and wizards shortcuts allowing to easily create and develop NabLab projects. Examples project Just click on the main menu From the File > New > NabLab Examples to import the examples project: A new wizard is launched: Just click on the Finish button to import the examples project that becomes available in the Model Explorer view on the left of the perspective. It contains a set of examples including Glace2D, HeatEquation, ExplicitHeatEquation, IterativeHeatEquation and ImplicitHeatEquation. Code generation To launch code generation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Generate Code Java and C++ source code files are generated in src-gen-java and src-gen-cpp folders respectively. For each C++ folder a CMakeLists.txt file is generated. A LaTeX file containing the content of the jobs and an example of json data file are also generated in the src-gen folder. Note A good practice is to name \"src-gen\" a directory containing only generated code. Interpretation To launch code interpretation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Run As > Start Interpretation . To change the Json file of your interpretation, right-click on the ngen file and select Run As > Run Configurations , select your configuration, for example ExplicitHeatEquation.ngen, and change the Json file in the dialog window. Note If you have installed and configured GraalVM for NabLab, you can interpret your module using GraalVM: just select Run As > Start Truffle-Based Interpretation instead of Run As > Start Interpretation . You can set configuration like previously and set the monilog file and python executable path. LaTeX view The LaTeX View is located on the bottom of the NabLab environment. It allows to visualize in an elegant way the formulas contained in a .n file. If you do not use the NabLab perspective the The LaTeX View is not visible. You can access it through the Window > Show View > Other... > NabLab > LaTeX View main menu. This view is automatically updated and synchronized with the selection in the current NabLab editor. Job graph NabLab offers 2 visualization modes for job graph: a fast rendering view and an editor with a more efficient layout. In case of job cycles, both of the modes will display the cycle graphically to highlight the error. Note In both visualization modes, let the mouse over a job node to display its input and output variables. View The Job Graph View can be opened from a ngen file containing an Application , by clicking on F1. It allows to quickly visualize the data flow graph of the application described in the ngen file. Editor NabLab offers another way of visualizing the data flow graph of an application. The Job Graph Editor can be opened from a ngen file containing an Application , by clicking on F2. It allows to visualize bigger graphs than the Job Graph View thanks to an efficient layout.","title":"Getting started"},{"location":"gettingstarted/#getting-started","text":"","title":"Getting started"},{"location":"gettingstarted/#download-and-install","text":"","title":"Download and install"},{"location":"gettingstarted/#prerequisite","text":"NabLab requires Java 11 or later to build & run. Do not forget to set the JAVA_HOME variable to the java installation directory and to update your path.","title":"Prerequisite"},{"location":"gettingstarted/#installing-nablab","text":"The latest NabLab environment can be downloaded here . Download the file corresponding to your platform, unzip it and lauch the NabLab executable in the root directory. For Mac users, depending on your security configuration, you have to enter the following command to execute NabLab: xattr -d com.apple.quarantine NabLab.app .","title":"Installing NabLab"},{"location":"gettingstarted/#installing-nablab-debugger","text":"NabLab debugger is part of the Debug4Science project . It is based on GraalVM and Monilog . It is still under development. The installation process is: To install the debugger, download monilog4nablab-0.4.0.zip here and follow the Monilog4NabLab installation instructions . As explained in the installation instructions, GraalVM is installed in the folder of your IDE. Install Graalpython in following the instructions available here . You can also install numpy which is a supported package of GraalVM: just replace pandas by numpy in the package installation instructions . Finally, in the root directory of your NabLab installation, add the following option to the NabLab.ini file -vm /path/to/graalvm-ce-java11-21.0.0/bin/java .","title":"Installing NabLab debugger"},{"location":"gettingstarted/#build-via-maven-3x","text":"If you need to build NabLab products (Windows/Linux/MacOS and Eclipse update-site) from the source code (instead of downloading it), run the following command from the root of the repository: mvn clean; mvn verify . Note the ';' after mvn clean . The products resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/products/NabLab-X.Y.Z.yyyymmddHHMM-YOUR_PLATFORM.zip . The Eclipse update-site resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/fr.cea.nabla.updatesite-X.Y.Z.yyyymmddHHMM.zip . If you want to skip tests execution, you can run the following command: mvn clean; mvn verify -Dmaven.test.skip=true","title":"Build via Maven 3.x"},{"location":"gettingstarted/#first-step-in-the-environment","text":"","title":"First step in the environment"},{"location":"gettingstarted/#overview","text":"The NabLab environment is based on the Eclipse Modeling Framework (EMF). The central part of the NabLab environment displays a textual editor, based on Xtext which provides contextual code completion, code folding, syntax highlighting, error detection, quick fixes, variable scoping, and type checking. The left part of the environment proposes a model explorer and a dedicated interactive outline view to navigate easily through the textual editor. The bottom part is composed of several views including a rich LaTeX visualization of the selection in the editor. A graphical editor based on Sirius allows to visualize the data flow graph between jobs.","title":"Overview"},{"location":"gettingstarted/#perspective","text":"Once the NabLab environment has been launched, the NabLab perspective should be selected. If it is not the case, just select the NabLab perspective from the Window > Perspective > Open Perspective > Other ... > NabLab menu. The NabLab perspective provides a set of Views and wizards shortcuts allowing to easily create and develop NabLab projects.","title":"Perspective"},{"location":"gettingstarted/#examples-project","text":"Just click on the main menu From the File > New > NabLab Examples to import the examples project: A new wizard is launched: Just click on the Finish button to import the examples project that becomes available in the Model Explorer view on the left of the perspective. It contains a set of examples including Glace2D, HeatEquation, ExplicitHeatEquation, IterativeHeatEquation and ImplicitHeatEquation.","title":"Examples project"},{"location":"gettingstarted/#code-generation","text":"To launch code generation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Generate Code Java and C++ source code files are generated in src-gen-java and src-gen-cpp folders respectively. For each C++ folder a CMakeLists.txt file is generated. A LaTeX file containing the content of the jobs and an example of json data file are also generated in the src-gen folder. Note A good practice is to name \"src-gen\" a directory containing only generated code.","title":"Code generation"},{"location":"gettingstarted/#interpretation","text":"To launch code interpretation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Run As > Start Interpretation . To change the Json file of your interpretation, right-click on the ngen file and select Run As > Run Configurations , select your configuration, for example ExplicitHeatEquation.ngen, and change the Json file in the dialog window. Note If you have installed and configured GraalVM for NabLab, you can interpret your module using GraalVM: just select Run As > Start Truffle-Based Interpretation instead of Run As > Start Interpretation . You can set configuration like previously and set the monilog file and python executable path.","title":"Interpretation"},{"location":"gettingstarted/#latex-view","text":"The LaTeX View is located on the bottom of the NabLab environment. It allows to visualize in an elegant way the formulas contained in a .n file. If you do not use the NabLab perspective the The LaTeX View is not visible. You can access it through the Window > Show View > Other... > NabLab > LaTeX View main menu. This view is automatically updated and synchronized with the selection in the current NabLab editor.","title":"LaTeX view"},{"location":"gettingstarted/#job-graph","text":"NabLab offers 2 visualization modes for job graph: a fast rendering view and an editor with a more efficient layout. In case of job cycles, both of the modes will display the cycle graphically to highlight the error. Note In both visualization modes, let the mouse over a job node to display its input and output variables.","title":"Job graph"},{"location":"gettingstarted/#view","text":"The Job Graph View can be opened from a ngen file containing an Application , by clicking on F1. It allows to quickly visualize the data flow graph of the application described in the ngen file.","title":"View"},{"location":"gettingstarted/#editor","text":"NabLab offers another way of visualizing the data flow graph of an application. The Job Graph Editor can be opened from a ngen file containing an Application , by clicking on F2. It allows to visualize bigger graphs than the Job Graph View thanks to an efficient layout.","title":"Editor"},{"location":"modulecomposition/","text":"Composing modules Presentation of the problem Let us imagine a dummy hydrodynamic module Hydro defined in Hydro.n file and its own application defined in Hydro.ngen file. You now want to introduce a new remapping module Remap . This module does not have its own application. It is designed to be coupled with the hydrodynamic module into one application defined in a HydroRemap.ngen file. From a NabLab point of view, it consists in merging the data flow graphs of the two modules in defining equalities between module's variables. Creating the project Just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and a module name: Enter Tutorial as project name, select the Module radio button, enter Hydro as module name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( Hydro.n , and Hydro.ngen ) in the Tutorial/src/hydro/ folder: A dummy Hydro module Here is an example code of a dummy Hydro module. Copy and paste it in Hydro.n file. module Hydro; itemtypes { node, cell } connectivity nodes: \u2192 {node}; connectivity cells: \u2192 {cell}; option \u211d maxTime = 0.1; option \u2115 maxIter = 500; option \u211d \u03b4t = 1.0; let \u211d t = 0.0; \u211d[2] X{nodes}; \u211d hv1{cells}, hv2{cells}, hv3{cells}, hv4{cells}, hv5{cells}; Hj1: \u2200c\u2208cells(), hv2{c} = hv1{c}; Hj2: \u2200c\u2208cells(), hv3{c} = hv2{c}; Hj3: \u2200c\u2208cells(), hv5{c} = hv3{c} + hv4{c}; The algorithm is stupid: the goal is just to introduce dependencies between variables and jobs. Job In Variables Out Variables Hj1 hv1 hv2 Hj2 hv2 hv3 Hj3 hv3, hv4 hv5 The Hydro application is defined in a classical Hydro.ngen file (see Ngen language reference for details). Copy and paste it in Hydro.ngen file. Application Hydro; MainModule Hydro hydro { meshClassName = \"CartesianMesh2D\"; nodeCoord = X; time = t; timeStep = \u03b4t; iterationMax = maxIter; timeMax = maxTime; } StlThread { outputPath = \"/NablaTest/src-gen-cpp/stl-thread\"; N_CXX_COMPILER = \"/usr/bin/g++\"; } The Job Graph Editor , triggered by pressing F2 key on Hydro.ngen file, displays: Note Let the mouse over a job to display its in/out variables. A dummy Remap module Create now a new file for the Remap module. Just type CTRL-N or click on the main menu File > New > Other to create a new file: A new wizard is launched, select File: Click Next> , select the Tutorial/src/hydro folder and enter Remap.n as file name: Here is an example code of a dummy Remap module. Copy and paste it in Remap.n file. module Remap; itemtypes { cell } connectivity cells: \u2192 {cell}; \u211d rv1{cells}, rv2{cells}, rv3{cells}; Rj1: \u2200c\u2208cells(), rv2{c} = rv1{c}; Rj2: \u2200c\u2208cells(), rv3{c} = rv2{c}; The algorithm is as stupid as the Hydro one: the goal is just to introduce dependencies between variables and jobs. Job In Variables Out Variables Rj1 rv1 rv2 Rj2 rv2 rv3 It is not possible to display the graph of jobs because there is no ngen application file for the Remap module. It is not a standalone module and it is designed to be coupled with the Hydro one. Hydro/Remap association The aim is to associate the Hydro and Remap modules by coupling their data flow as follows: We will create a new application from the previous one. In the explorer, copy Hydro.ngen file and paste it in the same folder. A wizard will ask you for the name of the new file, enter HydroRemap.ngen . The new file must appears in the src/hydro folder as follows: The HydroRemap.ngen file defines the application coupling between Hydro and Remap modules. Change the name of the application from Hydro to HydroRemap at the beginning of the file. Application HydroRemap; The Hydro module stays the main module of the application. The Remap module will be added to the application: in the HydroRemap.ngen file, between the MainModule and the StlThread blocks, introduce a block to add the additional module Remap and define variable equalities like they appear in the graph above: AdditionalModule Remap remap { remap.rv1 = hydro.hv1; remap.rv2 = hydro.hv4; } Note Module names and their variables are available by contextual code completion with CTRL-Space keys. Only variables of the same type can be declared as equals: the ngen editor will display an error if it is not the case. The Job Graph Editor , triggered by pressing F2 key on HydroRemap.ngen file, displays: Note In this example, there is no iterate instruction to define time iterators and consequently no variable with time iterators like t^{n} . If it is the case, time iterators must belong to the main module: they are forbidden in additional modules. Code generation Generate the code in the same way as usual: right-click on the HydroRemap.ngen file and select Generate Code . The StlThread generation target will produce the following files, as expected: Multiple additional modules It is possible to define multiple additional modules, even if they have the same type, as long as they have different name. For example, you can couple 2 Remap modules named r1 and r2 to the Hydro module hydro in the following scenario: The content of the Hydro.n file becomes: module Hydro; itemtypes { node, cell } connectivity nodes: \u2192 {node}; connectivity cells: \u2192 {cell}; option \u211d maxTime = 0.1; option \u2115 maxIter = 500; option \u211d \u03b4t = 1.0; let \u211d t = 0.0; \u211d[2] X{nodes}; \u211d hv1{cells}, hv2{cells}, hv3{cells}, hv4{cells}, hv5{cells}, hv6{cells}, hv7{cells}; Hj1: \u2200c\u2208cells(), hv3{c} = hv2{c}; Hj2: \u2200c\u2208cells(), hv5{c} = hv3{c}; Hj3: \u2200c\u2208cells(), hv7{c} = hv4{c} + hv5{c} + hv6{c}; The Remap module does not change while the content of the HydroRemap.ngen file integrates two additional modules instead of the previous remap one: AdditionalModule Remap r1 { r1.rv1 = h.hv1; r1.rv2 = h.hv4; } AdditionalModule Remap r2 { r2.rv1 = h.hv3; r2.rv3 = h.hv6; } The StlThread target will generate the following files: The above picture shows that generated files have the same name as the module instances (defined in the HydroRemap.ngen file) starting with an upper case, i.e. Hydro , R1 and R2 .","title":"Composing modules"},{"location":"modulecomposition/#composing-modules","text":"","title":"Composing modules"},{"location":"modulecomposition/#presentation-of-the-problem","text":"Let us imagine a dummy hydrodynamic module Hydro defined in Hydro.n file and its own application defined in Hydro.ngen file. You now want to introduce a new remapping module Remap . This module does not have its own application. It is designed to be coupled with the hydrodynamic module into one application defined in a HydroRemap.ngen file. From a NabLab point of view, it consists in merging the data flow graphs of the two modules in defining equalities between module's variables.","title":"Presentation of the problem"},{"location":"modulecomposition/#creating-the-project","text":"Just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and a module name: Enter Tutorial as project name, select the Module radio button, enter Hydro as module name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( Hydro.n , and Hydro.ngen ) in the Tutorial/src/hydro/ folder:","title":"Creating the project"},{"location":"modulecomposition/#a-dummy-hydro-module","text":"Here is an example code of a dummy Hydro module. Copy and paste it in Hydro.n file. module Hydro; itemtypes { node, cell } connectivity nodes: \u2192 {node}; connectivity cells: \u2192 {cell}; option \u211d maxTime = 0.1; option \u2115 maxIter = 500; option \u211d \u03b4t = 1.0; let \u211d t = 0.0; \u211d[2] X{nodes}; \u211d hv1{cells}, hv2{cells}, hv3{cells}, hv4{cells}, hv5{cells}; Hj1: \u2200c\u2208cells(), hv2{c} = hv1{c}; Hj2: \u2200c\u2208cells(), hv3{c} = hv2{c}; Hj3: \u2200c\u2208cells(), hv5{c} = hv3{c} + hv4{c}; The algorithm is stupid: the goal is just to introduce dependencies between variables and jobs. Job In Variables Out Variables Hj1 hv1 hv2 Hj2 hv2 hv3 Hj3 hv3, hv4 hv5 The Hydro application is defined in a classical Hydro.ngen file (see Ngen language reference for details). Copy and paste it in Hydro.ngen file. Application Hydro; MainModule Hydro hydro { meshClassName = \"CartesianMesh2D\"; nodeCoord = X; time = t; timeStep = \u03b4t; iterationMax = maxIter; timeMax = maxTime; } StlThread { outputPath = \"/NablaTest/src-gen-cpp/stl-thread\"; N_CXX_COMPILER = \"/usr/bin/g++\"; } The Job Graph Editor , triggered by pressing F2 key on Hydro.ngen file, displays: Note Let the mouse over a job to display its in/out variables.","title":"A dummy Hydro module"},{"location":"modulecomposition/#a-dummy-remap-module","text":"Create now a new file for the Remap module. Just type CTRL-N or click on the main menu File > New > Other to create a new file: A new wizard is launched, select File: Click Next> , select the Tutorial/src/hydro folder and enter Remap.n as file name: Here is an example code of a dummy Remap module. Copy and paste it in Remap.n file. module Remap; itemtypes { cell } connectivity cells: \u2192 {cell}; \u211d rv1{cells}, rv2{cells}, rv3{cells}; Rj1: \u2200c\u2208cells(), rv2{c} = rv1{c}; Rj2: \u2200c\u2208cells(), rv3{c} = rv2{c}; The algorithm is as stupid as the Hydro one: the goal is just to introduce dependencies between variables and jobs. Job In Variables Out Variables Rj1 rv1 rv2 Rj2 rv2 rv3 It is not possible to display the graph of jobs because there is no ngen application file for the Remap module. It is not a standalone module and it is designed to be coupled with the Hydro one.","title":"A dummy Remap module"},{"location":"modulecomposition/#hydroremap-association","text":"The aim is to associate the Hydro and Remap modules by coupling their data flow as follows: We will create a new application from the previous one. In the explorer, copy Hydro.ngen file and paste it in the same folder. A wizard will ask you for the name of the new file, enter HydroRemap.ngen . The new file must appears in the src/hydro folder as follows: The HydroRemap.ngen file defines the application coupling between Hydro and Remap modules. Change the name of the application from Hydro to HydroRemap at the beginning of the file. Application HydroRemap; The Hydro module stays the main module of the application. The Remap module will be added to the application: in the HydroRemap.ngen file, between the MainModule and the StlThread blocks, introduce a block to add the additional module Remap and define variable equalities like they appear in the graph above: AdditionalModule Remap remap { remap.rv1 = hydro.hv1; remap.rv2 = hydro.hv4; } Note Module names and their variables are available by contextual code completion with CTRL-Space keys. Only variables of the same type can be declared as equals: the ngen editor will display an error if it is not the case. The Job Graph Editor , triggered by pressing F2 key on HydroRemap.ngen file, displays: Note In this example, there is no iterate instruction to define time iterators and consequently no variable with time iterators like t^{n} . If it is the case, time iterators must belong to the main module: they are forbidden in additional modules.","title":"Hydro/Remap association"},{"location":"modulecomposition/#code-generation","text":"Generate the code in the same way as usual: right-click on the HydroRemap.ngen file and select Generate Code . The StlThread generation target will produce the following files, as expected:","title":"Code generation"},{"location":"modulecomposition/#multiple-additional-modules","text":"It is possible to define multiple additional modules, even if they have the same type, as long as they have different name. For example, you can couple 2 Remap modules named r1 and r2 to the Hydro module hydro in the following scenario: The content of the Hydro.n file becomes: module Hydro; itemtypes { node, cell } connectivity nodes: \u2192 {node}; connectivity cells: \u2192 {cell}; option \u211d maxTime = 0.1; option \u2115 maxIter = 500; option \u211d \u03b4t = 1.0; let \u211d t = 0.0; \u211d[2] X{nodes}; \u211d hv1{cells}, hv2{cells}, hv3{cells}, hv4{cells}, hv5{cells}, hv6{cells}, hv7{cells}; Hj1: \u2200c\u2208cells(), hv3{c} = hv2{c}; Hj2: \u2200c\u2208cells(), hv5{c} = hv3{c}; Hj3: \u2200c\u2208cells(), hv7{c} = hv4{c} + hv5{c} + hv6{c}; The Remap module does not change while the content of the HydroRemap.ngen file integrates two additional modules instead of the previous remap one: AdditionalModule Remap r1 { r1.rv1 = h.hv1; r1.rv2 = h.hv4; } AdditionalModule Remap r2 { r2.rv1 = h.hv3; r2.rv3 = h.hv6; } The StlThread target will generate the following files: The above picture shows that generated files have the same name as the module instances (defined in the HydroRemap.ngen file) starting with an upper case, i.e. Hydro , R1 and R2 .","title":"Multiple additional modules"},{"location":"nablablanguage/","text":"NabLab language Module and extensions A NabLab file, extension n , defines a module or an extension . Module A module represents a NabLab program and its definition strictly follows the following sequence: Imports Item types and connectivities Reductions Functions Variables and options Time iterators Jobs A module is generally associated with a NabLab application . Several modules can also be composed into a single application: see module composition documentation. Extension An extension is a way to extent the language with external functions. Its definition strictly follows the following sequence: Imports Reductions Functions Functions of an extension can be called from a NabLab module. To use an extension X, a module has to import the extension with the instruction with X.*; (see below). Note The extension and extension provider mechanisms are the way to call legacy libraries, like linear algebra libraries, from NabLab applications. Extensions provide external functions, i.e. functions with no NabLab body. Those functions are implemented in an another language, generally C or C++. To link NabLab function declaration to its native definition, providers have to be defined: see NabLab extension providers for details. Imports The with keyword allows to import NabLab extensions, libraries of reductions and functions external to the module. NabLab provides two native extensions: Math and Linear Algebra (follow the link to see the available functions and reductions). To use them in your own module, just create an import section as follow: module ImplicitHeatEquation; with Math.*; with LinearAlgebra.*; Items and connectivities Items are elements of a set, typically mesh elements. The various types of items are defined in a set. itemtypes { node, cell, face } Note Sets are surrounded by curly brackets and separated by a comma. A connectivity declaration id defined by a name, its inputs items and an output item or a set of output items. connectivity nodes: \u2192 {node}; // mesh nodes connectivity cells: \u2192 {cell}; // mesh cells connectivity faces: \u2192 {face}; // mesh faces connectivity neighborCells: cell \u2192 {cell}; // neighbor cells of a cell connectivity nodesOfFace: face \u2192 {node}; // nodes of a face connectivity nodesOfCell: cell \u2192 {node}; // nodes of a cell connectivity commonFace: cell \u00d7 cell \u2192 face; // common face of two cells Reductions and functions Reductions Reductions are defined by their name, neutral element (seed of the reduction) and type corresponding to the type of their arguments and also their return type. They can be overloaded: it is possible to create multiple reductions with same name and different type. def \u2211, 0.0: \u211d, (a, b) \u2192 return a + b; def \u2211, 0.0: x | \u211d[x], (a, b) \u2192 return a + b; Functions Functions are defined by their name, input arguments, return type and body. They can be overloaded: it is possible to create multiple functions with same name and different input arguments. Function's body is a unique instruction or a block of instructions. It cannot refer to global variables. That is the reason why functions are declared before variables. def one: \u2192 \u2115, () \u2192 return 1; // function with no in arg def inc: \u2115 \u2192 \u2115, (a) \u2192 return a+1; // overloaded function inc on \u2115 def inc: \u211d \u2192 \u211d, (a) \u2192 return a+1.0; // overloaded function inc on \u211d def dot: x | \u211d[x] \u00d7 \u211d[x] \u2192 \u211d, (a , b) \u2192 { let \u211d result = 0.0; \u2200 i \u2208 [0;x[, result = result + a[i]*b[i]; return result; } In an extension, functions can be external, without body definition. In this case the definition of an extension provider allows to call a native function (C, C++...). This mechanism allows to use legacy libraries, like linear algebra libraries. Note External functions, i.e. functions with no body, are not allowed in modules, only in extensions. Global variables Global variables are defined by their type, name and eventually one or several supports representing the connectivity on which the variable lives. Note UTF-8 characters for variable names are supported to fit domain scientists classical notations, for example \u03b4t, \u03c1... The type of the variable is one of the 3 NabLab base types: boolean \u213e , integer \u2115 or real \u211d . It can be scalar or array. Arrays are defined by giving a comma separated list of sizes between brackets. Note NabLab text editor offers a contextual code completion and interactive ASCII template sequences to enter UTF-8 keywords. \u213e is_ok; // boolean \u2115 i, j; // integers \u211d t, \u03b4t; // reals \u211d[2] x; // 1 dimension real array \u211d[2, 2] xx; // 2 dimensions real array \u211d[2] X{nodes}; // array of 2 reals on each node \u211d[2, 2] Ajr{cells, nodesOfCell}; // 2x2 matrix on each node of each cell Multiple variables can be declared in the same instruction into a comma separated list. \u211d t, \u03b4t; \u211d c{cells}, m{cells}, p{cells}; A variable initialized with a default value is preceded by the let keyword. It is not possible to assign several variables in one definition. A user option is preceded by the option keyword. The option can be set in a Json data file. If the option has a default value it becomes optional in the data file otherwise the execution will produce an error if the option has no default value and is not found in the data file. let \u211d \u03b3 = 3.0; // real scalar let \u211d[2] N = [0.0, 1.0]; // 1 dimension real array let \u211d[2, 2] N = [ [0.0, 1.0], N ]; // 2 dimensions real array let \u2115[2,2] I = [ [1, 0], [0, 1] ]; // 2 dimensions int array option \u2115 maxIter = 200; // optional integer user option option \u211d maxTime; // mandatory real user option Time iterators The iterate section is used to define time iterators and the stop conditions of their time loop. // definition of time iterator n iterate n while (residual > \u03b5); Variables can be referenced with defined iterators. In the above example defining a n time iterator, a variable can be referenced at n=0 , n and n+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} and t^{n+1} . Note For the moment, only the +1 increment of the iterator is allowed. It is possible to define several time iterators into a comma separated list: the iterator of index k+1 is then nested into the iterator of index k . // definition of time iterators n and k. iterate n while (t^{n+1} < stopTime && n+1 < maxIterations), k while (residual > \u03b5 && check(k+1 < maxIterationsK)); In case of several iterators, variables can be referenced by a list of defined time iterators, respecting the order of inclusion. In the above example defining n and k inside n, a variable can be referenced by n=0 , n , n+1 , n+1, k=0 , n+1, n , and n+1, k+1 . Variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} , t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} . It is also possible to define a block of inner iterators to define several loops included in a main time loop. iterate n while (t^{n+1} < maxTime && n+1 < maxIter), { k while (k+1 < maxIterK); l while (l+1 < maxIterL); } In the above example defining n, k inside n and l inside n, a variable can be referenced by n=0 , n , n+1 and either n+1, k=0 , n+1, n , n+1, k+1 or n+1, l=0 , n+1, l , n+1, l+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} and either t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} or t^{n+1, l=0} , t^{n+1, l} , t^{n+1, l+1} . Note For a time iterator n , if a variable is initialized at n=0 , NabLab automatically initializes n with n=0 value of the variable at the beginning of the time loop and with n+1 value during loop iterations. Jobs Jobs are identified by a name, starting with an upper case. They are composed of an instruction, or a block of instructions. Ini: j = 0; IniTime: t^{n=0} = 0.0; ComputeDensity: \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; The execution of a NabLab program does not start at its beginning and jobs execution order does not correspond to their position in the file. During the compilation phase, the data flow graph of the program is computed according to input and output variables of each job. Jobs are annotated with an at statement corresponding to its hierarchical logical time (HLT). The HLT concept is explicitly expressed to go beyond the classical single-program-multiple-data or bulk-synchronous-parallel programming models. The at logical timestamp explicitly declares the task-based parallelism of jobs. However, this way to schedule jobs imposes to have a dedicated tool to visualize the graph representing the program execution. This feature has been developed and integrated into the NabLab environment (see getting started documentation for details). Instructions The main instructions of the language are: local variable and set definitions, affectations, blocks, loops, conditionals. An instruction ends with the ; character except blocks surrounded by curly brackets. Local variables and set definitions Local variables can be defined with the same syntax than global ones but local definitions include neither variables with supports nor user options. Set of items can be defined locally by calling a connectivity, like this: set my_cells = cells(); Affectations An affectation is composed of a variable reference, the = character and an expression. \u03c1_ic = \u03c1IniZg; t^{n=0} = 0.0; N = [0.0, 1.0]; Cjr_ic{j,r} = 0.5 * perp(X^{n=0}{r+1} - X^{n=0}{r-1}); Blocks A block is a list of instructions. It follows the Composite Design Pattern : The block is an instruction and contains itself a list of instructions. The block is surrounded with curly brackets. { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; } Loops NabLab provides two instructions for loops: while and \u2200 . The while is composed of a condition, which is an expression, and an instruction that can be a block. while (t^{n} < 5.0) x = 0; while (residual > \u03b5) { alpha = 1.0 / det(a); I = [ [1.0, 0.0], [0.0, 1.0] ]; } The \u2200 loop provides two kinds of iteration blocks: interval and space iterators. Interval are going from 0 to n-1 with n an integer result of an expression. \u2200i\u2208[0;5[, x = 0; \u2200i\u2208[0;x+4[, { beta = i * a; A = [i, 0]; } Space iterators allows to loop on connectivity sets. // loop on cells \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; // loop on topNodes \u2200r\u2208topNodes(), { let \u211d[2] N = [0.0, 1.0]; let \u211d[2,2] NxN = tensProduct(N,N); let \u211d[2,2] IcP = I - NxN; bt{r} = matVectProduct(IcP, b{r}); } // loop on cells with a reduction on nodesOfCell \u2200j\u2208cells(), V{j} = 0.5 * \u2211{r\u2208nodesOfCell(j)}(dot(C{j,r}, X^{n}{r})); // loop on cells and inner loop on nodesOfCell \u2200j\u2208cells(), \u2200r\u2208nodesOfCell(j), Ajr{j,r} = ((\u03c1{j} * c{j}) / l{j,r}) * tensProduct(C{j,r}, C{j,r}); It is possible to define a loop iterator counter viewed as an integer local variable. \u2200j, ij \u2208cells(), \u03c1{j} = V{j} * ij; Conditionals Conditionals are defined with the classical if , else sequence. The condition in the if instruction is an expression, like for the while instruction. The else clause is optional. if (center[0] < xInterface) { \u03c1_ic = \u03c1IniZg; p_ic = pIniZg; } else { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; } Expressions Expressions are composed of the following elements: Unary operators minus - and not ! Binary operators add + , substract - , multiply * , divide / and modulo % Comparison operators greater than > , greater than or equal >= , less than < , less than or equal <= , equal == , not equal != Boolean operators and && and or || Contracted if operator (condition) ? true : false Min and max constants for integer and real base types: \u2115.MinValue , \u2115.MaxValue , \u211d.MinValue , \u211d.MaxValue Array initializations by comma separated list of expressions between brackets, for example [1, 2+3, -5] for \u2115[3] , [ [1.1, 1.2], [2.1, 2.2], [3.1, 3.2] ] for \u211d[3,2] Argument/variable references and reduction/function calls detailed below. Arguments and variable references Function arguments and variables are referenced by their name that can be followed by: A list of time iterators surrounded by the ^{ } and separated by a comma: t^{n+1} , t^{n+1, k} For variables with a support, a list of space iterators surrounded by the { } and separated by a comma: P{j} , Ajr{j, r} . Iterators are defined by loops and reductions. Iterators can have an increment, like X{r+1} or X{r-1} , to access the item before or after the original iterator in the set where it is defined. For arrays, a list of indices surrounded by [ ] and separated by a comma: X[0] , Y[i, 0] . Indices are expressions. Reduction and function calls A reduction call includes an iteration on a set or interval, like for a space iterator loop, and an expression of the type of the reduction. For example, to compute the sum of a real variable P defined on cells, the call includes the cells set iterator and the variable reference P{j} : let \u211d sum = \u2211{j\u2208cells()}(P{j}); A function call is defined by the name of the function and the right number and type of input arguments as expressions: let \u211d my_cos = cos(3.14 + 3.14);","title":"NabLab language reference"},{"location":"nablablanguage/#nablab-language","text":"","title":"NabLab language"},{"location":"nablablanguage/#module-and-extensions","text":"A NabLab file, extension n , defines a module or an extension .","title":"Module and extensions"},{"location":"nablablanguage/#module","text":"A module represents a NabLab program and its definition strictly follows the following sequence: Imports Item types and connectivities Reductions Functions Variables and options Time iterators Jobs A module is generally associated with a NabLab application . Several modules can also be composed into a single application: see module composition documentation.","title":"Module"},{"location":"nablablanguage/#extension","text":"An extension is a way to extent the language with external functions. Its definition strictly follows the following sequence: Imports Reductions Functions Functions of an extension can be called from a NabLab module. To use an extension X, a module has to import the extension with the instruction with X.*; (see below). Note The extension and extension provider mechanisms are the way to call legacy libraries, like linear algebra libraries, from NabLab applications. Extensions provide external functions, i.e. functions with no NabLab body. Those functions are implemented in an another language, generally C or C++. To link NabLab function declaration to its native definition, providers have to be defined: see NabLab extension providers for details.","title":"Extension"},{"location":"nablablanguage/#imports","text":"The with keyword allows to import NabLab extensions, libraries of reductions and functions external to the module. NabLab provides two native extensions: Math and Linear Algebra (follow the link to see the available functions and reductions). To use them in your own module, just create an import section as follow: module ImplicitHeatEquation; with Math.*; with LinearAlgebra.*;","title":"Imports"},{"location":"nablablanguage/#items-and-connectivities","text":"Items are elements of a set, typically mesh elements. The various types of items are defined in a set. itemtypes { node, cell, face } Note Sets are surrounded by curly brackets and separated by a comma. A connectivity declaration id defined by a name, its inputs items and an output item or a set of output items. connectivity nodes: \u2192 {node}; // mesh nodes connectivity cells: \u2192 {cell}; // mesh cells connectivity faces: \u2192 {face}; // mesh faces connectivity neighborCells: cell \u2192 {cell}; // neighbor cells of a cell connectivity nodesOfFace: face \u2192 {node}; // nodes of a face connectivity nodesOfCell: cell \u2192 {node}; // nodes of a cell connectivity commonFace: cell \u00d7 cell \u2192 face; // common face of two cells","title":"Items and connectivities"},{"location":"nablablanguage/#reductions-and-functions","text":"","title":"Reductions and functions"},{"location":"nablablanguage/#reductions","text":"Reductions are defined by their name, neutral element (seed of the reduction) and type corresponding to the type of their arguments and also their return type. They can be overloaded: it is possible to create multiple reductions with same name and different type. def \u2211, 0.0: \u211d, (a, b) \u2192 return a + b; def \u2211, 0.0: x | \u211d[x], (a, b) \u2192 return a + b;","title":"Reductions"},{"location":"nablablanguage/#functions","text":"Functions are defined by their name, input arguments, return type and body. They can be overloaded: it is possible to create multiple functions with same name and different input arguments. Function's body is a unique instruction or a block of instructions. It cannot refer to global variables. That is the reason why functions are declared before variables. def one: \u2192 \u2115, () \u2192 return 1; // function with no in arg def inc: \u2115 \u2192 \u2115, (a) \u2192 return a+1; // overloaded function inc on \u2115 def inc: \u211d \u2192 \u211d, (a) \u2192 return a+1.0; // overloaded function inc on \u211d def dot: x | \u211d[x] \u00d7 \u211d[x] \u2192 \u211d, (a , b) \u2192 { let \u211d result = 0.0; \u2200 i \u2208 [0;x[, result = result + a[i]*b[i]; return result; } In an extension, functions can be external, without body definition. In this case the definition of an extension provider allows to call a native function (C, C++...). This mechanism allows to use legacy libraries, like linear algebra libraries. Note External functions, i.e. functions with no body, are not allowed in modules, only in extensions.","title":"Functions"},{"location":"nablablanguage/#global-variables","text":"Global variables are defined by their type, name and eventually one or several supports representing the connectivity on which the variable lives. Note UTF-8 characters for variable names are supported to fit domain scientists classical notations, for example \u03b4t, \u03c1... The type of the variable is one of the 3 NabLab base types: boolean \u213e , integer \u2115 or real \u211d . It can be scalar or array. Arrays are defined by giving a comma separated list of sizes between brackets. Note NabLab text editor offers a contextual code completion and interactive ASCII template sequences to enter UTF-8 keywords. \u213e is_ok; // boolean \u2115 i, j; // integers \u211d t, \u03b4t; // reals \u211d[2] x; // 1 dimension real array \u211d[2, 2] xx; // 2 dimensions real array \u211d[2] X{nodes}; // array of 2 reals on each node \u211d[2, 2] Ajr{cells, nodesOfCell}; // 2x2 matrix on each node of each cell Multiple variables can be declared in the same instruction into a comma separated list. \u211d t, \u03b4t; \u211d c{cells}, m{cells}, p{cells}; A variable initialized with a default value is preceded by the let keyword. It is not possible to assign several variables in one definition. A user option is preceded by the option keyword. The option can be set in a Json data file. If the option has a default value it becomes optional in the data file otherwise the execution will produce an error if the option has no default value and is not found in the data file. let \u211d \u03b3 = 3.0; // real scalar let \u211d[2] N = [0.0, 1.0]; // 1 dimension real array let \u211d[2, 2] N = [ [0.0, 1.0], N ]; // 2 dimensions real array let \u2115[2,2] I = [ [1, 0], [0, 1] ]; // 2 dimensions int array option \u2115 maxIter = 200; // optional integer user option option \u211d maxTime; // mandatory real user option","title":"Global variables"},{"location":"nablablanguage/#time-iterators","text":"The iterate section is used to define time iterators and the stop conditions of their time loop. // definition of time iterator n iterate n while (residual > \u03b5); Variables can be referenced with defined iterators. In the above example defining a n time iterator, a variable can be referenced at n=0 , n and n+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} and t^{n+1} . Note For the moment, only the +1 increment of the iterator is allowed. It is possible to define several time iterators into a comma separated list: the iterator of index k+1 is then nested into the iterator of index k . // definition of time iterators n and k. iterate n while (t^{n+1} < stopTime && n+1 < maxIterations), k while (residual > \u03b5 && check(k+1 < maxIterationsK)); In case of several iterators, variables can be referenced by a list of defined time iterators, respecting the order of inclusion. In the above example defining n and k inside n, a variable can be referenced by n=0 , n , n+1 , n+1, k=0 , n+1, n , and n+1, k+1 . Variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} , t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} . It is also possible to define a block of inner iterators to define several loops included in a main time loop. iterate n while (t^{n+1} < maxTime && n+1 < maxIter), { k while (k+1 < maxIterK); l while (l+1 < maxIterL); } In the above example defining n, k inside n and l inside n, a variable can be referenced by n=0 , n , n+1 and either n+1, k=0 , n+1, n , n+1, k+1 or n+1, l=0 , n+1, l , n+1, l+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} and either t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} or t^{n+1, l=0} , t^{n+1, l} , t^{n+1, l+1} . Note For a time iterator n , if a variable is initialized at n=0 , NabLab automatically initializes n with n=0 value of the variable at the beginning of the time loop and with n+1 value during loop iterations.","title":"Time iterators"},{"location":"nablablanguage/#jobs","text":"Jobs are identified by a name, starting with an upper case. They are composed of an instruction, or a block of instructions. Ini: j = 0; IniTime: t^{n=0} = 0.0; ComputeDensity: \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; The execution of a NabLab program does not start at its beginning and jobs execution order does not correspond to their position in the file. During the compilation phase, the data flow graph of the program is computed according to input and output variables of each job. Jobs are annotated with an at statement corresponding to its hierarchical logical time (HLT). The HLT concept is explicitly expressed to go beyond the classical single-program-multiple-data or bulk-synchronous-parallel programming models. The at logical timestamp explicitly declares the task-based parallelism of jobs. However, this way to schedule jobs imposes to have a dedicated tool to visualize the graph representing the program execution. This feature has been developed and integrated into the NabLab environment (see getting started documentation for details).","title":"Jobs"},{"location":"nablablanguage/#instructions","text":"The main instructions of the language are: local variable and set definitions, affectations, blocks, loops, conditionals. An instruction ends with the ; character except blocks surrounded by curly brackets.","title":"Instructions"},{"location":"nablablanguage/#local-variables-and-set-definitions","text":"Local variables can be defined with the same syntax than global ones but local definitions include neither variables with supports nor user options. Set of items can be defined locally by calling a connectivity, like this: set my_cells = cells();","title":"Local variables and set definitions"},{"location":"nablablanguage/#affectations","text":"An affectation is composed of a variable reference, the = character and an expression. \u03c1_ic = \u03c1IniZg; t^{n=0} = 0.0; N = [0.0, 1.0]; Cjr_ic{j,r} = 0.5 * perp(X^{n=0}{r+1} - X^{n=0}{r-1});","title":"Affectations"},{"location":"nablablanguage/#blocks","text":"A block is a list of instructions. It follows the Composite Design Pattern : The block is an instruction and contains itself a list of instructions. The block is surrounded with curly brackets. { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; }","title":"Blocks"},{"location":"nablablanguage/#loops","text":"NabLab provides two instructions for loops: while and \u2200 . The while is composed of a condition, which is an expression, and an instruction that can be a block. while (t^{n} < 5.0) x = 0; while (residual > \u03b5) { alpha = 1.0 / det(a); I = [ [1.0, 0.0], [0.0, 1.0] ]; } The \u2200 loop provides two kinds of iteration blocks: interval and space iterators. Interval are going from 0 to n-1 with n an integer result of an expression. \u2200i\u2208[0;5[, x = 0; \u2200i\u2208[0;x+4[, { beta = i * a; A = [i, 0]; } Space iterators allows to loop on connectivity sets. // loop on cells \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; // loop on topNodes \u2200r\u2208topNodes(), { let \u211d[2] N = [0.0, 1.0]; let \u211d[2,2] NxN = tensProduct(N,N); let \u211d[2,2] IcP = I - NxN; bt{r} = matVectProduct(IcP, b{r}); } // loop on cells with a reduction on nodesOfCell \u2200j\u2208cells(), V{j} = 0.5 * \u2211{r\u2208nodesOfCell(j)}(dot(C{j,r}, X^{n}{r})); // loop on cells and inner loop on nodesOfCell \u2200j\u2208cells(), \u2200r\u2208nodesOfCell(j), Ajr{j,r} = ((\u03c1{j} * c{j}) / l{j,r}) * tensProduct(C{j,r}, C{j,r}); It is possible to define a loop iterator counter viewed as an integer local variable. \u2200j, ij \u2208cells(), \u03c1{j} = V{j} * ij;","title":"Loops"},{"location":"nablablanguage/#conditionals","text":"Conditionals are defined with the classical if , else sequence. The condition in the if instruction is an expression, like for the while instruction. The else clause is optional. if (center[0] < xInterface) { \u03c1_ic = \u03c1IniZg; p_ic = pIniZg; } else { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; }","title":"Conditionals"},{"location":"nablablanguage/#expressions","text":"Expressions are composed of the following elements: Unary operators minus - and not ! Binary operators add + , substract - , multiply * , divide / and modulo % Comparison operators greater than > , greater than or equal >= , less than < , less than or equal <= , equal == , not equal != Boolean operators and && and or || Contracted if operator (condition) ? true : false Min and max constants for integer and real base types: \u2115.MinValue , \u2115.MaxValue , \u211d.MinValue , \u211d.MaxValue Array initializations by comma separated list of expressions between brackets, for example [1, 2+3, -5] for \u2115[3] , [ [1.1, 1.2], [2.1, 2.2], [3.1, 3.2] ] for \u211d[3,2] Argument/variable references and reduction/function calls detailed below.","title":"Expressions"},{"location":"nablablanguage/#arguments-and-variable-references","text":"Function arguments and variables are referenced by their name that can be followed by: A list of time iterators surrounded by the ^{ } and separated by a comma: t^{n+1} , t^{n+1, k} For variables with a support, a list of space iterators surrounded by the { } and separated by a comma: P{j} , Ajr{j, r} . Iterators are defined by loops and reductions. Iterators can have an increment, like X{r+1} or X{r-1} , to access the item before or after the original iterator in the set where it is defined. For arrays, a list of indices surrounded by [ ] and separated by a comma: X[0] , Y[i, 0] . Indices are expressions.","title":"Arguments and variable references"},{"location":"nablablanguage/#reduction-and-function-calls","text":"A reduction call includes an iteration on a set or interval, like for a space iterator loop, and an expression of the type of the reduction. For example, to compute the sum of a real variable P defined on cells, the call includes the cells set iterator and the variable reference P{j} : let \u211d sum = \u2211{j\u2208cells()}(P{j}); A function call is defined by the name of the function and the right number and type of input arguments as expressions: let \u211d my_cos = cos(3.14 + 3.14);","title":"Reduction and function calls"},{"location":"ngenlanguage/","text":"Ngen language A ngen file, extension ngen , defines an Application or n (or several) ExtensionProvider . An Application reference a module while an ExtensionProvider references an extension . Application The application is identified by a name starting with an upper case. Application Glace2d; Main module identification The first part of the ngen file identifies the main module of the application. It is defined by a reference to a NabLab module and a name. It must provide some additional parameters useful for code interpretation/generation: meshClassName identifies the name of the mesh class and the name of the mesh class factory. For example, if the name is CartesianMesh2D , NabLab waits for a factory names CartesianMesh2DFactory with a CartesianMesh2D create() method. nodeCoord identifies the NabLab variable representing node coordinates. time , timeStep , iterationMax and timeMax identifies respectively the NabLab variables representing the time of the simulation, the timeStep of the simulation, the maximum number of iterations of the main time loop and the maximum time of the simulation. MainModule Glace2d glace2d { meshClassName = \"CartesianMesh2D\"; nodeCoord = X; time = t; timeStep = \u03b4t; iterationMax = maxIterations; timeMax = stopTime; } Note iterationMax and timeMax variables are mandatory for C++ code generation, optional otherwise. Note Code completion is available with CTRL-space for all module and variable references. VTK output NabLab provides a PVD file format serializer, a VTK compatible file format. The next block of the ngen file aims at configuring this serializer. It is an optional block. The periodReferenceVariable defines the module variable used as a reference for the frequency of the outputs. Most of the time, it is the iteration number (often named n ) or the time of the simulation (often named t ). VtkOutput { periodReferenceVariable = glace2d.n; outputVariables = glace2d.\u03c1 as \"Density\"; } When the VtkOutput block exists in the ngen file, two options must appear in the Json data file: outputPath and outputPeriod representing respectively the VTK output directory and the frequency period of the output. For example, for an outputPeriod of 1 and a periodReferenceVariable of n , VTK files will be written at each iteration of the simulation. Here is the VTK part of the default generated Json file (in src-gen directory): \"_outputPath_comment\":\"empty outputPath to disable output\", \"outputPath\":\"output\", \"outputPeriod\":1, Dump variables NabLab provides a mechanism to dump variable values. It uses the LevelDB library for Java and C++ . The Java LevelDB library is included in the NabLab environment. To use the C++ one, you have to download and install it on your computer. To trigger the dump of all variables (except linear algebra ones) of your code, add a LevelDB block. In addition to that, in case of C++ generation, provide the path to the LevelDB installation. LevelDB { levelDBPath = \"$ENV{HOME}/leveldb/leveldb-install\"; } Note The levelDBPath value supports CMake syntax like $ENV{HOME} in the example above. When the LevelDB block exists in the ngen file, the nonRegression option must appear in the Json data file. If its value is CreateReference , variables are dumped in a directory named ApplicationNameDB.ref . If its value is CompareToReference , variables are dumped in a directory named Application NameDB.current and are compared to variables stored in ApplicationNameDB.ref . \"_nonRegression_comment\":\"empty value to disable, CreateReference or CompareToReference to take action\", \"nonRegression\":\"\" Configuring interpretation Interpreter needs to be configured only if you use an extension with no Java provider. See the extension section for details. Configuring generation To configure generation, create as many generation blocks as desired generation targets. Possible targets are: Java for a multi-threaded Java code, Kokkos for a Kokkos multi-threaded C++ code based on Open MP, KokkosTeamThread for a Kokkos hierarchical multi-threaded C++ code with team of threads, OpenMP for an Open MP multi-threaded C++ code, CppSequential for a sequential C++ code, StlThread for a multi-threaded C++ code based on an STL threads API provided by the NabLab library. Here is an example of a generation block: Kokkos { outputPath = \"/NabLabExamples/src-gen-cpp/kokkos\"; N_CXX_COMPILER = \"/usr/bin/g++\"; N_KOKKOS_PATH = \"$ENV{HOME}/kokkos/kokkos-install\"; } All targets have to define the outputPath of the generation and a set of variables which will be reported in the CMakeLists.txt file. Note A good practice is to name \"src-gen\" a directory containing only generated code. For C++ targets, the N_CXX_COMPILER variable is mandatory. For Kokkos , KokkosTeamThread , the Kokkos library has to be installed and the path to the library has to be provided is the N_KOKKOS_PATH variable. Note Variables can use CMake syntax in their value like $ENV{HOME} for path in the example above. Provider A NabLab module can import some extensions. Those extensions contain some functions. Some of them can be external functions i.e. functions with just a signature definition and no body. In this case, these external functions are defined in a native language, for example C++. To connect definitions to signatures, providers have to be defined: some glue code must be written, providers have to be declared in a ngen file. Note NabLab offers a code generator to initialize the glue code and the ngen file for extension providers. See My first extension for that. Most of the time, all providers of an extension are declared in the same ngen file. For example, for linearalgebra extension part of the NabLab library, defined in the linearalgebra.n file, a linearalgebra.ngen file contains the providers. Provider LinearAlgebraStl : LinearAlgebra { target = StlThread; compatibleTargets = CppSequential, OpenMP; outputPath = \"/.nablab/linearalgebra\"; } Provider LinearAlgebraKokkos : LinearAlgebra { target = Kokkos; compatibleTargets = KokkosTeamThread; outputPath = \"/.nablab/linearalgebra\"; } Provider LinearAlgebraJava : LinearAlgebra { target = Java; outputPath = \"/.nablab/linearalgebra\"; } A provider is defined by its name and the extension it implements (after the : character). The provider block is composed of: target defining which generation target the provider implements. compatibleTargets , an optional field, representing a list of generation targets compatible with the target previously defined. In the above LinearAlgebraKokkos example, the target indicates that the provider's source code is designed for a multi-threaded C++ Kokkos source code. The compatibleTargets indicates that a caller generated with a KokkosTeamThread target can use this provider. outputPath containing the directory of the providers's source code.","title":"Ngen language reference"},{"location":"ngenlanguage/#ngen-language","text":"A ngen file, extension ngen , defines an Application or n (or several) ExtensionProvider . An Application reference a module while an ExtensionProvider references an extension .","title":"Ngen language"},{"location":"ngenlanguage/#application","text":"The application is identified by a name starting with an upper case. Application Glace2d;","title":"Application"},{"location":"ngenlanguage/#main-module-identification","text":"The first part of the ngen file identifies the main module of the application. It is defined by a reference to a NabLab module and a name. It must provide some additional parameters useful for code interpretation/generation: meshClassName identifies the name of the mesh class and the name of the mesh class factory. For example, if the name is CartesianMesh2D , NabLab waits for a factory names CartesianMesh2DFactory with a CartesianMesh2D create() method. nodeCoord identifies the NabLab variable representing node coordinates. time , timeStep , iterationMax and timeMax identifies respectively the NabLab variables representing the time of the simulation, the timeStep of the simulation, the maximum number of iterations of the main time loop and the maximum time of the simulation. MainModule Glace2d glace2d { meshClassName = \"CartesianMesh2D\"; nodeCoord = X; time = t; timeStep = \u03b4t; iterationMax = maxIterations; timeMax = stopTime; } Note iterationMax and timeMax variables are mandatory for C++ code generation, optional otherwise. Note Code completion is available with CTRL-space for all module and variable references.","title":"Main module identification"},{"location":"ngenlanguage/#vtk-output","text":"NabLab provides a PVD file format serializer, a VTK compatible file format. The next block of the ngen file aims at configuring this serializer. It is an optional block. The periodReferenceVariable defines the module variable used as a reference for the frequency of the outputs. Most of the time, it is the iteration number (often named n ) or the time of the simulation (often named t ). VtkOutput { periodReferenceVariable = glace2d.n; outputVariables = glace2d.\u03c1 as \"Density\"; } When the VtkOutput block exists in the ngen file, two options must appear in the Json data file: outputPath and outputPeriod representing respectively the VTK output directory and the frequency period of the output. For example, for an outputPeriod of 1 and a periodReferenceVariable of n , VTK files will be written at each iteration of the simulation. Here is the VTK part of the default generated Json file (in src-gen directory): \"_outputPath_comment\":\"empty outputPath to disable output\", \"outputPath\":\"output\", \"outputPeriod\":1,","title":"VTK output"},{"location":"ngenlanguage/#dump-variables","text":"NabLab provides a mechanism to dump variable values. It uses the LevelDB library for Java and C++ . The Java LevelDB library is included in the NabLab environment. To use the C++ one, you have to download and install it on your computer. To trigger the dump of all variables (except linear algebra ones) of your code, add a LevelDB block. In addition to that, in case of C++ generation, provide the path to the LevelDB installation. LevelDB { levelDBPath = \"$ENV{HOME}/leveldb/leveldb-install\"; } Note The levelDBPath value supports CMake syntax like $ENV{HOME} in the example above. When the LevelDB block exists in the ngen file, the nonRegression option must appear in the Json data file. If its value is CreateReference , variables are dumped in a directory named ApplicationNameDB.ref . If its value is CompareToReference , variables are dumped in a directory named Application NameDB.current and are compared to variables stored in ApplicationNameDB.ref . \"_nonRegression_comment\":\"empty value to disable, CreateReference or CompareToReference to take action\", \"nonRegression\":\"\"","title":"Dump variables"},{"location":"ngenlanguage/#configuring-interpretation","text":"Interpreter needs to be configured only if you use an extension with no Java provider. See the extension section for details.","title":"Configuring interpretation"},{"location":"ngenlanguage/#configuring-generation","text":"To configure generation, create as many generation blocks as desired generation targets. Possible targets are: Java for a multi-threaded Java code, Kokkos for a Kokkos multi-threaded C++ code based on Open MP, KokkosTeamThread for a Kokkos hierarchical multi-threaded C++ code with team of threads, OpenMP for an Open MP multi-threaded C++ code, CppSequential for a sequential C++ code, StlThread for a multi-threaded C++ code based on an STL threads API provided by the NabLab library. Here is an example of a generation block: Kokkos { outputPath = \"/NabLabExamples/src-gen-cpp/kokkos\"; N_CXX_COMPILER = \"/usr/bin/g++\"; N_KOKKOS_PATH = \"$ENV{HOME}/kokkos/kokkos-install\"; } All targets have to define the outputPath of the generation and a set of variables which will be reported in the CMakeLists.txt file. Note A good practice is to name \"src-gen\" a directory containing only generated code. For C++ targets, the N_CXX_COMPILER variable is mandatory. For Kokkos , KokkosTeamThread , the Kokkos library has to be installed and the path to the library has to be provided is the N_KOKKOS_PATH variable. Note Variables can use CMake syntax in their value like $ENV{HOME} for path in the example above.","title":"Configuring generation"},{"location":"ngenlanguage/#provider","text":"A NabLab module can import some extensions. Those extensions contain some functions. Some of them can be external functions i.e. functions with just a signature definition and no body. In this case, these external functions are defined in a native language, for example C++. To connect definitions to signatures, providers have to be defined: some glue code must be written, providers have to be declared in a ngen file. Note NabLab offers a code generator to initialize the glue code and the ngen file for extension providers. See My first extension for that. Most of the time, all providers of an extension are declared in the same ngen file. For example, for linearalgebra extension part of the NabLab library, defined in the linearalgebra.n file, a linearalgebra.ngen file contains the providers. Provider LinearAlgebraStl : LinearAlgebra { target = StlThread; compatibleTargets = CppSequential, OpenMP; outputPath = \"/.nablab/linearalgebra\"; } Provider LinearAlgebraKokkos : LinearAlgebra { target = Kokkos; compatibleTargets = KokkosTeamThread; outputPath = \"/.nablab/linearalgebra\"; } Provider LinearAlgebraJava : LinearAlgebra { target = Java; outputPath = \"/.nablab/linearalgebra\"; } A provider is defined by its name and the extension it implements (after the : character). The provider block is composed of: target defining which generation target the provider implements. compatibleTargets , an optional field, representing a list of generation targets compatible with the target previously defined. In the above LinearAlgebraKokkos example, the target indicates that the provider's source code is designed for a multi-threaded C++ Kokkos source code. The compatibleTargets indicates that a caller generated with a KokkosTeamThread target can use this provider. outputPath containing the directory of the providers's source code.","title":"Provider"}]}