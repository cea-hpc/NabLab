{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is NabLab ? Presentation of the project NabLab is a open-source research project led by HPC initiative of the CEA . It aims is to provide a productive development way for exascale HPC technologies, flexible enough to be competitive in terms of performances. It is composed of: a numerical analysis Domain Specific Language (DSL) to improve applied mathematicians productivity throughput and enables new algorithmic developments for the construction of hierarchical and composable high-performance scientific applications. an full-fledged environment to edit, interpret, debug specific numerical-analysis sources and to generate optimized code for various C++ targets. Motivation Addressing the major challenges of software productivity and performance portability is becoming necessary to take advantage of emerging extreme-scale computing architectures. As software development costs will continuously increase to address exascale hardware issues, higher-level programming abstraction will facilitate the path to go. There is a growing demand for new programming environments in order to improve scientific productivity, to facilitate the design and implementation, and to optimize large production codes. How it works NabLab is based on Eclipse Modeling Framework (EMF) . The Nabla DSL is realized with Xtext that allows to offer a rich textual editor with syntax coloring, code completion, quick fixes... The code in the editor has an internal EMF model representation. This representation, close to the language, is transformed into a numerical analysis specific Intermediate Representation (IR) also implemented as an Ecore metamodel. The concepts of the IR facilitate the code generation. Currently Kokkos , Open MP and STL based threads C++ backends are implemented. Publications Fostering metamodels and grammars within a dedicated environment for HPC: the NabLab environment Applying Model-Driven Engineering to High-Performance Computing: Experience Report, Lessons Learned, and Remaining Challenges Licence and copyright This program and the accompanying materials are made available under the terms of the Eclipse Public License v. 2.0 . SPDX-License-Identifier: EPL-2.0. Please refer to the license for details. Written by CEA and Contributors. (C) Copyright 2021, by CEA. All rights reserved. All content is the property of the respective authors or their employers. For more information regarding authorship of content, please consult the listed source code repository logs.","title":"What is NabLab"},{"location":"#what-is-nablab","text":"","title":"What is NabLab ?"},{"location":"#presentation-of-the-project","text":"NabLab is a open-source research project led by HPC initiative of the CEA . It aims is to provide a productive development way for exascale HPC technologies, flexible enough to be competitive in terms of performances. It is composed of: a numerical analysis Domain Specific Language (DSL) to improve applied mathematicians productivity throughput and enables new algorithmic developments for the construction of hierarchical and composable high-performance scientific applications. an full-fledged environment to edit, interpret, debug specific numerical-analysis sources and to generate optimized code for various C++ targets.","title":"Presentation of the project"},{"location":"#motivation","text":"Addressing the major challenges of software productivity and performance portability is becoming necessary to take advantage of emerging extreme-scale computing architectures. As software development costs will continuously increase to address exascale hardware issues, higher-level programming abstraction will facilitate the path to go. There is a growing demand for new programming environments in order to improve scientific productivity, to facilitate the design and implementation, and to optimize large production codes.","title":"Motivation"},{"location":"#how-it-works","text":"NabLab is based on Eclipse Modeling Framework (EMF) . The Nabla DSL is realized with Xtext that allows to offer a rich textual editor with syntax coloring, code completion, quick fixes... The code in the editor has an internal EMF model representation. This representation, close to the language, is transformed into a numerical analysis specific Intermediate Representation (IR) also implemented as an Ecore metamodel. The concepts of the IR facilitate the code generation. Currently Kokkos , Open MP and STL based threads C++ backends are implemented.","title":"How it works"},{"location":"#publications","text":"Fostering metamodels and grammars within a dedicated environment for HPC: the NabLab environment Applying Model-Driven Engineering to High-Performance Computing: Experience Report, Lessons Learned, and Remaining Challenges","title":"Publications"},{"location":"#licence-and-copyright","text":"This program and the accompanying materials are made available under the terms of the Eclipse Public License v. 2.0 . SPDX-License-Identifier: EPL-2.0. Please refer to the license for details. Written by CEA and Contributors. (C) Copyright 2021, by CEA. All rights reserved. All content is the property of the respective authors or their employers. For more information regarding authorship of content, please consult the listed source code repository logs.","title":"Licence and copyright"},{"location":"debug/","text":"Monitoring and debugging NabLab debugger is part of the Debug4Science project . Coming soon...","title":"Monitoring and debugging"},{"location":"debug/#monitoring-and-debugging","text":"NabLab debugger is part of the Debug4Science project . Coming soon...","title":"Monitoring and debugging"},{"location":"firstextension/","text":"My first extension Coming soon...","title":"My first extension"},{"location":"firstextension/#my-first-extension","text":"Coming soon...","title":"My first extension"},{"location":"firstmodule/","text":"My first module Presentation of the problem The aim of this tutorial is to implement a simple equation of diffusion in NabLab: \\[ \\begin{equation} \\begin{cases} \\partial_t u - div(K \\nabla u) &= f \\text{ in } \\Omega \\\\ (K \\nabla u)n &= g \\text{ on } \\partial \\Omega \\end{cases} \\end{equation} \\] In this tutorial the equation is discretized with a finite volume scheme on a 2D cartesian mesh. A constant approximation of u by cell gives: \\[ \\begin{equation} \\begin{aligned} \\frac{u_M^{n+1} - u_M^n}{\\Delta t} &= f_M + \\frac{1}{V_M}\\int_{M}{div(K \\nabla u^n)} \\\\ &= f_M + \\frac{1}{V_M}\\int_{\\partial M}{div(K \\nabla u^n)} \\nu \\\\ &= f_M + \\frac{1}{V_M}\\sum_{M' \\text{neighbor of } M}{K_{MM'} \\frac{u_{M'}^n - u_{M}^n}{MM'}} \\end{aligned} \\end{equation} \\] with \\[ \\begin{equation} K_{MM'} = K \\text{ on } M \\cap M' \\end{equation} \\] Consequently \\[ \\begin{equation} \\begin{aligned} u_M^{n+1} &= \\Delta t f_M + 1 + \\frac{\\Delta t}{V_M} + \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'}}{MM'}} . u_M^n \\\\ &- \\frac{\\Delta t}{V_M} \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'} u_{M'}^n}{MM'}} \\end{aligned} \\end{equation} \\] Creating the project Just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and a module name: Enter Tutorial as project name and HeatEquation as module name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( HeatEquation.n , and HeatEquation.ngen ) in the Tutorial/src/heatequation/ folder: Implementation Items and connectivities TO BE CONTINUED","title":"My first module"},{"location":"firstmodule/#my-first-module","text":"","title":"My first module"},{"location":"firstmodule/#presentation-of-the-problem","text":"The aim of this tutorial is to implement a simple equation of diffusion in NabLab: \\[ \\begin{equation} \\begin{cases} \\partial_t u - div(K \\nabla u) &= f \\text{ in } \\Omega \\\\ (K \\nabla u)n &= g \\text{ on } \\partial \\Omega \\end{cases} \\end{equation} \\] In this tutorial the equation is discretized with a finite volume scheme on a 2D cartesian mesh. A constant approximation of u by cell gives: \\[ \\begin{equation} \\begin{aligned} \\frac{u_M^{n+1} - u_M^n}{\\Delta t} &= f_M + \\frac{1}{V_M}\\int_{M}{div(K \\nabla u^n)} \\\\ &= f_M + \\frac{1}{V_M}\\int_{\\partial M}{div(K \\nabla u^n)} \\nu \\\\ &= f_M + \\frac{1}{V_M}\\sum_{M' \\text{neighbor of } M}{K_{MM'} \\frac{u_{M'}^n - u_{M}^n}{MM'}} \\end{aligned} \\end{equation} \\] with \\[ \\begin{equation} K_{MM'} = K \\text{ on } M \\cap M' \\end{equation} \\] Consequently \\[ \\begin{equation} \\begin{aligned} u_M^{n+1} &= \\Delta t f_M + 1 + \\frac{\\Delta t}{V_M} + \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'}}{MM'}} . u_M^n \\\\ &- \\frac{\\Delta t}{V_M} \\sum_{M' \\text{ neighbor of } M}{\\frac{K_{MM'} u_{M'}^n}{MM'}} \\end{aligned} \\end{equation} \\]","title":"Presentation of the problem"},{"location":"firstmodule/#creating-the-project","text":"Just click on the main menu File > New > NabLab Project to create a new project: A new wizard is launched, asking for a project name and a module name: Enter Tutorial as project name and HeatEquation as module name and click on the Finish button to create the new project. The new project is available in the Model Explorer on the left of the window. It contains two files ( HeatEquation.n , and HeatEquation.ngen ) in the Tutorial/src/heatequation/ folder:","title":"Creating the project"},{"location":"firstmodule/#implementation","text":"","title":"Implementation"},{"location":"firstmodule/#items-and-connectivities","text":"TO BE CONTINUED","title":"Items and connectivities"},{"location":"gettingstarted/","text":"Getting started Download and install Prerequisite NabLab requires Java 11 or later to build & run. Do not forget to set the JAVA_HOME variable to the java installation directory and to update your path. Installing NabLab The latest NabLab environment can be downloaded here . Download the file corresponding to your platform, unzip it and lauch the NabLab executable in the root directory. For Mac users, depending on your security configuration, you have to enter the following command to execute NabLab: xattr -d com.apple.quarantine NabLab.app . Installing NabLab debugger NabLab debugger is part of the Debug4Science project . It is based on GraalVM and Monilog . It is still under development. The temporary installation process is: Download GraalVM community edition 21.0.0 here and extract it in the directory of your choice. Install Graalpython in following the instructions available here . Note that numpy is a supported package of GraalVM: just replace pandas by numpy in the package installation instructions . For Monilog and GraalVM support of NabLab, download the 3 files available here . To install the NabLab and Monilog languages support for GraalVM, type the following command: /path/to/graalvm/bin/gu -L install -f nabla-component.jar . Then create the folder /path/to/graalvm/tools/monilogger and copy the file monilogger.jar into it. Into your NabLab product, click on the menu Help > Install New Software... , a dialog box appears, clic on Add... > Archive and select the graalvm-integration.zip file. In the root directory of your NabLab installation, add the following option to the NabLab.ini file -vm /path/to/graalvm-ce-java11-21.0.0/bin/java . Build via Maven 3.x If you need to build NabLab products (Windows/Linux/MacOS and Eclipse update-site) from the source code (instead of downloading it), run the following command from the root of the repository: mvn clean; mvn verify . Note the ';' after mvn clean . The products resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/products/NabLab-X.Y.Z.yyyymmddHHMM-YOUR_PLATFORM.zip . The Eclipse update-site resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/fr.cea.nabla.updatesite-X.Y.Z.yyyymmddHHMM.zip . If you want to skip tests execution, you can run the following command: mvn clean; mvn verify -Dmaven.test.skip=true First step in the environment Overview The NabLab environment is based on the Eclipse Modeling Framework (EMF). The central part of the NabLab environment displays a textual editor, based on Xtext which provides contextual code completion, code folding, syntax highlighting, error detection, quick fixes, variable scoping, and type checking. The left part of the environment proposes a model explorer and a dedicated interactive outline view to navigate easily through the textual editor. The bottom part is composed of several views including a rich LaTeX visualization of the selection in the editor. A graphical editor based on Sirius allows to visualize the data flow graph between jobs. Perspective Once the NabLab environment has been launched, the NabLab perspective should be selected. If it is not the case, just select the NabLab perspective from the Window > Perspective > Open Perspective > Other ... > NabLab menu. The NabLab perspective provides a set of Views and wizards shortcuts allowing to easily create and develop NabLab projects. Examples project Just click on the main menu From the File > New > NabLab Examples to import the examples project: A new wizard is launched: Just click on the Finish button to import the examples project that becomes available in the Model Explorer view on the left of the perspective. It contains a set of examples including Glace2D, HeatEquation, ExplicitHeatEquation, IterativeHeatEquation and ImplicitHeatEquation. Code generation To launch code generation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Generate Code Java and C++ source code files are generated in src-gen-java and src-gen-cpp folders respectively. For each C++ folder a CMakeLists.txt file is generated. A LaTeX file containing the content of the jobs and an example of json data file are also generated in the src-gen folder. Interpretation To launch code interpretation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Run As > Start Interpretation . To change the Json file of your interpretation, right-click on the ngen file and select Run As > Run Configurations , select your configuration, for example ExplicitHeatEquation.ngen, and change the Json file in the dialog window. Note If you have installed and configured GraalVM for NabLab, you can interpret your module using GraalVM: just select Run As > Start Truffle-Based Interpretation instead of Run As > Start Interpretation . You can set configuration like previously and set the monilog file and python executable path. LaTeX view The LaTeX View is located on the bottom of the NabLab environment. It allows to visualize in an elegant way the formulas contained in a .n file. If you do not use the NabLab perspective the The LaTeX View is not visible. You can access it through the Window > Show View > Other... > NabLab > LaTeX View main menu. This view is automatically updated and synchronized with the selection in the current NabLab editor. Job graph NabLab offers 2 visualization modes for job graph: a fast rendering view and an editor with a more efficient layout. In case of job cycles, both of the modes will display the cycle graphically to highlight the error. Note In both visualization modes, let the mouse over a job node to display its input and output variables. View The Job Graph View can be opened from a ngen file containing an Application , by clicking on F1. It allows to quickly visualize the data flow graph of the application described in the ngen file. Editor NabLab offers another way of visualizing the data flow graph of an application. The Job Graph Editor can be opened from a ngen file containing an Application , by clicking on F2. It allows to visualize bigger graphs than the Job Graph View thanks to an efficient layout.","title":"Getting started"},{"location":"gettingstarted/#getting-started","text":"","title":"Getting started"},{"location":"gettingstarted/#download-and-install","text":"","title":"Download and install"},{"location":"gettingstarted/#prerequisite","text":"NabLab requires Java 11 or later to build & run. Do not forget to set the JAVA_HOME variable to the java installation directory and to update your path.","title":"Prerequisite"},{"location":"gettingstarted/#installing-nablab","text":"The latest NabLab environment can be downloaded here . Download the file corresponding to your platform, unzip it and lauch the NabLab executable in the root directory. For Mac users, depending on your security configuration, you have to enter the following command to execute NabLab: xattr -d com.apple.quarantine NabLab.app .","title":"Installing NabLab"},{"location":"gettingstarted/#installing-nablab-debugger","text":"NabLab debugger is part of the Debug4Science project . It is based on GraalVM and Monilog . It is still under development. The temporary installation process is: Download GraalVM community edition 21.0.0 here and extract it in the directory of your choice. Install Graalpython in following the instructions available here . Note that numpy is a supported package of GraalVM: just replace pandas by numpy in the package installation instructions . For Monilog and GraalVM support of NabLab, download the 3 files available here . To install the NabLab and Monilog languages support for GraalVM, type the following command: /path/to/graalvm/bin/gu -L install -f nabla-component.jar . Then create the folder /path/to/graalvm/tools/monilogger and copy the file monilogger.jar into it. Into your NabLab product, click on the menu Help > Install New Software... , a dialog box appears, clic on Add... > Archive and select the graalvm-integration.zip file. In the root directory of your NabLab installation, add the following option to the NabLab.ini file -vm /path/to/graalvm-ce-java11-21.0.0/bin/java .","title":"Installing NabLab debugger"},{"location":"gettingstarted/#build-via-maven-3x","text":"If you need to build NabLab products (Windows/Linux/MacOS and Eclipse update-site) from the source code (instead of downloading it), run the following command from the root of the repository: mvn clean; mvn verify . Note the ';' after mvn clean . The products resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/products/NabLab-X.Y.Z.yyyymmddHHMM-YOUR_PLATFORM.zip . The Eclipse update-site resulting from the build will be accessible in /releng/fr.cea.nabla.updatesite/target/fr.cea.nabla.updatesite-X.Y.Z.yyyymmddHHMM.zip . If you want to skip tests execution, you can run the following command: mvn clean; mvn verify -Dmaven.test.skip=true","title":"Build via Maven 3.x"},{"location":"gettingstarted/#first-step-in-the-environment","text":"","title":"First step in the environment"},{"location":"gettingstarted/#overview","text":"The NabLab environment is based on the Eclipse Modeling Framework (EMF). The central part of the NabLab environment displays a textual editor, based on Xtext which provides contextual code completion, code folding, syntax highlighting, error detection, quick fixes, variable scoping, and type checking. The left part of the environment proposes a model explorer and a dedicated interactive outline view to navigate easily through the textual editor. The bottom part is composed of several views including a rich LaTeX visualization of the selection in the editor. A graphical editor based on Sirius allows to visualize the data flow graph between jobs.","title":"Overview"},{"location":"gettingstarted/#perspective","text":"Once the NabLab environment has been launched, the NabLab perspective should be selected. If it is not the case, just select the NabLab perspective from the Window > Perspective > Open Perspective > Other ... > NabLab menu. The NabLab perspective provides a set of Views and wizards shortcuts allowing to easily create and develop NabLab projects.","title":"Perspective"},{"location":"gettingstarted/#examples-project","text":"Just click on the main menu From the File > New > NabLab Examples to import the examples project: A new wizard is launched: Just click on the Finish button to import the examples project that becomes available in the Model Explorer view on the left of the perspective. It contains a set of examples including Glace2D, HeatEquation, ExplicitHeatEquation, IterativeHeatEquation and ImplicitHeatEquation.","title":"Examples project"},{"location":"gettingstarted/#code-generation","text":"To launch code generation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Generate Code Java and C++ source code files are generated in src-gen-java and src-gen-cpp folders respectively. For each C++ folder a CMakeLists.txt file is generated. A LaTeX file containing the content of the jobs and an example of json data file are also generated in the src-gen folder.","title":"Code generation"},{"location":"gettingstarted/#interpretation","text":"To launch code interpretation corresponding to the NabLab module, just right-click on the ngen file of the project of your choice, for example NabLabExamples/src/explicitheatequation/ExplicitHeatEquation.ngen and select Run As > Start Interpretation . To change the Json file of your interpretation, right-click on the ngen file and select Run As > Run Configurations , select your configuration, for example ExplicitHeatEquation.ngen, and change the Json file in the dialog window. Note If you have installed and configured GraalVM for NabLab, you can interpret your module using GraalVM: just select Run As > Start Truffle-Based Interpretation instead of Run As > Start Interpretation . You can set configuration like previously and set the monilog file and python executable path.","title":"Interpretation"},{"location":"gettingstarted/#latex-view","text":"The LaTeX View is located on the bottom of the NabLab environment. It allows to visualize in an elegant way the formulas contained in a .n file. If you do not use the NabLab perspective the The LaTeX View is not visible. You can access it through the Window > Show View > Other... > NabLab > LaTeX View main menu. This view is automatically updated and synchronized with the selection in the current NabLab editor.","title":"LaTeX view"},{"location":"gettingstarted/#job-graph","text":"NabLab offers 2 visualization modes for job graph: a fast rendering view and an editor with a more efficient layout. In case of job cycles, both of the modes will display the cycle graphically to highlight the error. Note In both visualization modes, let the mouse over a job node to display its input and output variables.","title":"Job graph"},{"location":"gettingstarted/#view","text":"The Job Graph View can be opened from a ngen file containing an Application , by clicking on F1. It allows to quickly visualize the data flow graph of the application described in the ngen file.","title":"View"},{"location":"gettingstarted/#editor","text":"NabLab offers another way of visualizing the data flow graph of an application. The Job Graph Editor can be opened from a ngen file containing an Application , by clicking on F2. It allows to visualize bigger graphs than the Job Graph View thanks to an efficient layout.","title":"Editor"},{"location":"modulecomposition/","text":"Composing modules Coming soon...","title":"Composing modules"},{"location":"modulecomposition/#composing-modules","text":"Coming soon...","title":"Composing modules"},{"location":"nablablanguage/","text":"NabLab language Module and extensions A NabLab file, extension n , defines a module or an extension . Module A module represents a NabLab program and its definition strictly follows the following sequence: Imports Item types and connectivities Reductions Functions Variables and options Time iterators Jobs A module is generally associated with a NabLab application . Several modules can also be composed into a single application: see module composition documentation. Extension An extension is a way to extent the language with external functions. Its definition strictly follows the following sequence: Imports Reductions Functions Functions of an extension can be called from a NabLab module. To use an extension X, a module has to import the extension with the instruction with X.*; (see below). Note The extension and extension provider mechanisms are the way to call legacy libraries, like linear algebra libraries, from NabLab applications. Extensions provide external functions, i.e. functions with no NabLab body. Those functions are implemented in an another language, generally C or C++. To link NabLab function declaration to its native definition, providers have to be defined: see NabLab extension providers for details. Imports The with keyword allows to import NabLab extensions, libraries of reductions and functions external to the module. NabLab provides two native extensions: Math and Linear Algebra (follow the link to see the available functions and reductions). To use them in your own module, just create an import section as follow: module ImplicitHeatEquation; with Math.*; with LinearAlgebra.*; Items and connectivities Items are elements of a set, typically mesh elements. The various types of items are defined in a set. itemtypes { node, cell, face } Note Sets are surrounded by curly brackets and separated by a comma. A connectivity declaration id defined by a name, its inputs items and an output item or a set of output items. connectivity nodes: \u2192 {node}; // mesh nodes connectivity cells: \u2192 {cell}; // mesh cells connectivity faces: \u2192 {face}; // mesh faces connectivity neighborCells: cell \u2192 {cell}; // neighbor cells of a cell connectivity nodesOfFace: face \u2192 {node}; // nodes of a face connectivity nodesOfCell: cell \u2192 {node}; // nodes of a cell connectivity commonFace: cell \u00d7 cell \u2192 face; // common face of two cells Reductions and functions Reductions Reductions are defined by their name, neutral element (seed of the reduction) and type corresponding to the type off their arguments and also their return type. They can be overloaded: it is possible to create multiple reductions with same name and different type. def \u2211, 0.0: \u211d, (a, b) \u2192 return a + b; def \u2211, 0.0: x | \u211d[x], (a, b) \u2192 return a + b; Functions Functions are defined by their name, input arguments, return type and body. They can be overloaded: it is possible to create multiple functions with same name and different input arguments. Function's body is a unique instruction or a block of instructions. It can not refer to global variables. That is the reason why functions are declared before variables. def one: \u2192 \u2115, () \u2192 return 1; // function with no in arg def inc: \u2115 \u2192 \u2115, (a) \u2192 return a+1; // overloaded function inc on \u2115 def inc: \u211d \u2192 \u211d, (a) \u2192 return a+1.0; // overloaded function inc on \u211d def dot: x | \u211d[x] \u00d7 \u211d[x] \u2192 \u211d, (a , b) \u2192 { let \u211d result = 0.0; \u2200 i \u2208 [0;x[, result = result + a[i]*b[i]; return result; } In an extension, functions can be external, without body definition. In this case the definition of an extension provider allows to call a native function (C, C++...). This mechanism allows to use legacy libraries, like linear algebra libraries. Note External functions, i.e. functions with no body, are not allowed in modules, only in extensions. Global variables Global variables are defined by their type, name and eventually one or several supports representing the connectivity on which the variable lives. Note UTF-8 characters for variable names are supported to fit domain scientists classical notations, for example \u03b4t, \u03c1... The type of the variable is one of the 3 NabLab base types: boolean \u213e , integer \u2115 or real \u211d . It can be scalar or array. Arrays are defined by giving a comma separated list of sizes between brackets. Note NabLab text editor offers a contextual code completion and interactive ASCII template sequences to enter UTF-8 keywords. \u213e is_ok; // boolean \u2115 i, j; // integers \u211d t, \u03b4t; // reals \u211d[2] x; // 1 dimension real array \u211d[2, 2] xx; // 2 dimensions real array \u211d[2] X{nodes}; // array of 2 reals on each node \u211d[2, 2] Ajr{cells, nodesOfCell}; // 2x2 matrix on each node of each cell Multiple variables can be declared in the same instruction into a comma separated list. \u211d t, \u03b4t; \u211d c{cells}, m{cells}, p{cells}; A variable initialized with a default value is preceded by the let keyword. It is not possible to assign several variables in one definition. A user option is preceded by the option keyword. The option can be set in a Json data file. If the option has a default value it becomes optional in the data file otherwise the execution will produce an error if the option has no default value and is not found in the data file. let \u211d \u03b3 = 3.0; // real scalar let \u211d[2] N = [0.0, 1.0]; // 1 dimension real array let \u211d[2, 2] N = [ [0.0, 1.0], N ]; // 2 dimensions real array let \u2115[2,2] I = [ [1, 0], [0, 1] ]; // 2 dimensions int array option \u2115 maxIter = 200; // optional integer user option option \u211d maxTime; // mandatory real user option Time iterators The iterate section is used to define time iterators and the stop conditions of their time loop. // definition of time iterator n iterate n while (residual > \u03b5); Variables can be referenced with defined iterators. In the above example defining a n time iterator, a variable can be referenced at n=0 , n and n+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} and t^{n+1} . Note For the moment, only the +1 increment of the iterator is allowed. Is is possible to define several time iterators into a comma separated list: the iterator of index k+1 is then nested into the iterator of index k . // definition of time iterators n and k. iterate n while (t^{n+1} < stopTime && n+1 < maxIterations), k while (residual > \u03b5 && check(k+1 < maxIterationsK)); In case of several iterators, variables can be referenced by a list of defined time iterators, respecting the order of inclusion. In the above example defining n and k inside n, a variable can be referenced by n=0 , n , n+1 , n+1, k=0 , n+1, n , and n+1, k+1 . variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} , t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} . It is also possible to define a block of inner iterators to define several loops included in a main time loop. iterate n while (t^{n+1} < maxTime && n+1 < maxIter), { k while (k+1 < maxIterK); l while (l+1 < maxIterL); } In the above example defining n, k inside n and l inside n, a variable can be referenced by n=0 , n , n+1 and either n+1, k=0 , n+1, n , n+1, k+1 or n+1, l=0 , n+1, l , n+1, l+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} and either t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} or t^{n+1, l=0} , t^{n+1, l} , t^{n+1, l+1} . Note For a time iterator n , if a variable is initialized at n=0 , NabLab automatically initializes n with n=0 value of the variable at the beginning of the time loop and with n+1 value during loop iterations. Jobs Jobs are identified by a name, starting with an upper case. They are composed of an instruction, or a block of instructions. Ini: j = 0; IniTime: t^{n=0} = 0.0; ComputeDensity: \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; The execution of a NabLab program does not start at its beginning and jobs execution order does not correspond to their position in the file. During the compilation phase, the data flow graph of the program is computed according to input and output variables of each job. Jobs are annotated with a at statement corresponding to its hierarchical logical time (HLT). The HLT concept is explicitly expressed to go beyond the classical single-program-multiple-data or bulk-synchronous-parallel programming models. The at logical timestamp explicitly declares the task-based parallelism of jobs. However, this way to schedule jobs imposes to have a dedicated tool to visualize the graph representing the program execution. This feature has been developed and integrated into the NabLab environment (see getting started documentation for details). Instructions The main instructions of the language are: local variable and set definitions, affectations, blocks, loops, conditionals. An instruction ends with the ; character except blocks surrounded by curly brackets. Local variables and set definitions Local variables can be defined with the same syntax than global ones but local definitions include neither variables with supports nor user options. Set of items can be defined locally by calling a connectivity, like this: set my_cells = cells(); Affectations An affectation is composed of a variable reference, the = character and an expression. \u03c1_ic = \u03c1IniZg; t^{n=0} = 0.0; N = [0.0, 1.0]; Cjr_ic{j,r} = 0.5 * perp(X^{n=0}{r+1} - X^{n=0}{r-1}); Blocks A block is a list of instructions. It follows the Composite Design Pattern : The block is an instruction and contains itself a list of instructions. The block is surrounded with curly brackets. { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; } Loops NabLab provides two instructions for loops: while and \u2200 . The while is composed of a condition, which is an expression, and an instruction that can be a block. while (t^{n} < 5.0) x = 0; while (residual > \u03b5) { alpha = 1.0 / det(a); I = [ [1.0, 0.0], [0.0, 1.0] ]; } The \u2200 loop provides two kinds of iteration blocks: interval and space iterators. Interval are going from 0 to n-1 with n an integer result of an expression. \u2200i\u2208[0;5[, x = 0; \u2200i\u2208[0;x+4[, { beta = i * a; A = [i, 0]; } Space iterators allows to loop on connectivity sets. // loop on cells \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; // loop on topNodes \u2200r\u2208topNodes(), { let \u211d[2] N = [0.0, 1.0]; let \u211d[2,2] NxN = tensProduct(N,N); let \u211d[2,2] IcP = I - NxN; bt{r} = matVectProduct(IcP, b{r}); } // loop on cells with a reduction on nodesOfCell \u2200j\u2208cells(), V{j} = 0.5 * \u2211{r\u2208nodesOfCell(j)}(dot(C{j,r}, X^{n}{r})); // loop on cells and inner loop on nodesOfCell \u2200j\u2208cells(), \u2200r\u2208nodesOfCell(j), Ajr{j,r} = ((\u03c1{j} * c{j}) / l{j,r}) * tensProduct(C{j,r}, C{j,r}); It is possible to define a loop iterator counter viewed as an integer local variable. \u2200j, ij \u2208cells(), \u03c1{j} = V{j} * ij; Conditionals Conditionals are defined with the classical if , else sequence. The condition in the if instruction is an expression, like for the while instruction. The else clause is optional. if (center[0] < xInterface) { \u03c1_ic = \u03c1IniZg; p_ic = pIniZg; } else { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; } Expressions Expressions are composed of the following elements: Unary operators minus - and not ! Binary operators add + , substract - , multiply * , divide / and modulo % Comparison operators greater than > , greater than or equal >= , less than < , less than or equal <= , equal == , not equal != Boolean operators and && and or || Contracted if operator (condition) ? true : false Min and max constants for integer and real base types: \u2115.MinValue , \u2115.MaxValue , \u211d.MinValue , \u211d.MaxValue Array initializations by comma separated list of expressions between brackets, for example [1, 2+3, -5] for \u2115[3] , [ [1.1, 1.2], [2.1, 2.2], [3.1, 3.2] ] for \u211d[3,2] Argument/variable references and reduction/function calls detailed below. Arguments and variable references Function arguments and variables are referenced by their name that can be followed by: A list of time iterators surrounded by the ^{ } and separated by a comma: t^{n+1} , t^{n+1, k} For variables with a support, a list of space iterators surrounded by the { } and separated by a comma: P{j} , Ajr{j, r} . Iterators are defined by loops and reductions. Iterators can have an increment, like X{r+1} or X{r-1} , to access the item before or after the original iterator in the set where it is defined. For arrays, a list of indices surrounded by [ ] and separated by a comma: X[0] , Y[i, 0] . Indices are expressions. Reduction and function calls A reduction call includes an iteration on a set or interval, like for a space iterator loop, and an expression of the type of the reduction. For example, to compute the sum of a real variable P defined on cells, the call includes the cells set iterator and the variable reference P{j} : let \u211d sum = \u2211{j\u2208cells()}(P{j}); A function call is defined by the name of the function and the right number and type of input arguments as expressions: let \u211d my_cos = cos(3.14 + 3.14);","title":"NabLab language reference"},{"location":"nablablanguage/#nablab-language","text":"","title":"NabLab language"},{"location":"nablablanguage/#module-and-extensions","text":"A NabLab file, extension n , defines a module or an extension .","title":"Module and extensions"},{"location":"nablablanguage/#module","text":"A module represents a NabLab program and its definition strictly follows the following sequence: Imports Item types and connectivities Reductions Functions Variables and options Time iterators Jobs A module is generally associated with a NabLab application . Several modules can also be composed into a single application: see module composition documentation.","title":"Module"},{"location":"nablablanguage/#extension","text":"An extension is a way to extent the language with external functions. Its definition strictly follows the following sequence: Imports Reductions Functions Functions of an extension can be called from a NabLab module. To use an extension X, a module has to import the extension with the instruction with X.*; (see below). Note The extension and extension provider mechanisms are the way to call legacy libraries, like linear algebra libraries, from NabLab applications. Extensions provide external functions, i.e. functions with no NabLab body. Those functions are implemented in an another language, generally C or C++. To link NabLab function declaration to its native definition, providers have to be defined: see NabLab extension providers for details.","title":"Extension"},{"location":"nablablanguage/#imports","text":"The with keyword allows to import NabLab extensions, libraries of reductions and functions external to the module. NabLab provides two native extensions: Math and Linear Algebra (follow the link to see the available functions and reductions). To use them in your own module, just create an import section as follow: module ImplicitHeatEquation; with Math.*; with LinearAlgebra.*;","title":"Imports"},{"location":"nablablanguage/#items-and-connectivities","text":"Items are elements of a set, typically mesh elements. The various types of items are defined in a set. itemtypes { node, cell, face } Note Sets are surrounded by curly brackets and separated by a comma. A connectivity declaration id defined by a name, its inputs items and an output item or a set of output items. connectivity nodes: \u2192 {node}; // mesh nodes connectivity cells: \u2192 {cell}; // mesh cells connectivity faces: \u2192 {face}; // mesh faces connectivity neighborCells: cell \u2192 {cell}; // neighbor cells of a cell connectivity nodesOfFace: face \u2192 {node}; // nodes of a face connectivity nodesOfCell: cell \u2192 {node}; // nodes of a cell connectivity commonFace: cell \u00d7 cell \u2192 face; // common face of two cells","title":"Items and connectivities"},{"location":"nablablanguage/#reductions-and-functions","text":"","title":"Reductions and functions"},{"location":"nablablanguage/#reductions","text":"Reductions are defined by their name, neutral element (seed of the reduction) and type corresponding to the type off their arguments and also their return type. They can be overloaded: it is possible to create multiple reductions with same name and different type. def \u2211, 0.0: \u211d, (a, b) \u2192 return a + b; def \u2211, 0.0: x | \u211d[x], (a, b) \u2192 return a + b;","title":"Reductions"},{"location":"nablablanguage/#functions","text":"Functions are defined by their name, input arguments, return type and body. They can be overloaded: it is possible to create multiple functions with same name and different input arguments. Function's body is a unique instruction or a block of instructions. It can not refer to global variables. That is the reason why functions are declared before variables. def one: \u2192 \u2115, () \u2192 return 1; // function with no in arg def inc: \u2115 \u2192 \u2115, (a) \u2192 return a+1; // overloaded function inc on \u2115 def inc: \u211d \u2192 \u211d, (a) \u2192 return a+1.0; // overloaded function inc on \u211d def dot: x | \u211d[x] \u00d7 \u211d[x] \u2192 \u211d, (a , b) \u2192 { let \u211d result = 0.0; \u2200 i \u2208 [0;x[, result = result + a[i]*b[i]; return result; } In an extension, functions can be external, without body definition. In this case the definition of an extension provider allows to call a native function (C, C++...). This mechanism allows to use legacy libraries, like linear algebra libraries. Note External functions, i.e. functions with no body, are not allowed in modules, only in extensions.","title":"Functions"},{"location":"nablablanguage/#global-variables","text":"Global variables are defined by their type, name and eventually one or several supports representing the connectivity on which the variable lives. Note UTF-8 characters for variable names are supported to fit domain scientists classical notations, for example \u03b4t, \u03c1... The type of the variable is one of the 3 NabLab base types: boolean \u213e , integer \u2115 or real \u211d . It can be scalar or array. Arrays are defined by giving a comma separated list of sizes between brackets. Note NabLab text editor offers a contextual code completion and interactive ASCII template sequences to enter UTF-8 keywords. \u213e is_ok; // boolean \u2115 i, j; // integers \u211d t, \u03b4t; // reals \u211d[2] x; // 1 dimension real array \u211d[2, 2] xx; // 2 dimensions real array \u211d[2] X{nodes}; // array of 2 reals on each node \u211d[2, 2] Ajr{cells, nodesOfCell}; // 2x2 matrix on each node of each cell Multiple variables can be declared in the same instruction into a comma separated list. \u211d t, \u03b4t; \u211d c{cells}, m{cells}, p{cells}; A variable initialized with a default value is preceded by the let keyword. It is not possible to assign several variables in one definition. A user option is preceded by the option keyword. The option can be set in a Json data file. If the option has a default value it becomes optional in the data file otherwise the execution will produce an error if the option has no default value and is not found in the data file. let \u211d \u03b3 = 3.0; // real scalar let \u211d[2] N = [0.0, 1.0]; // 1 dimension real array let \u211d[2, 2] N = [ [0.0, 1.0], N ]; // 2 dimensions real array let \u2115[2,2] I = [ [1, 0], [0, 1] ]; // 2 dimensions int array option \u2115 maxIter = 200; // optional integer user option option \u211d maxTime; // mandatory real user option","title":"Global variables"},{"location":"nablablanguage/#time-iterators","text":"The iterate section is used to define time iterators and the stop conditions of their time loop. // definition of time iterator n iterate n while (residual > \u03b5); Variables can be referenced with defined iterators. In the above example defining a n time iterator, a variable can be referenced at n=0 , n and n+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} and t^{n+1} . Note For the moment, only the +1 increment of the iterator is allowed. Is is possible to define several time iterators into a comma separated list: the iterator of index k+1 is then nested into the iterator of index k . // definition of time iterators n and k. iterate n while (t^{n+1} < stopTime && n+1 < maxIterations), k while (residual > \u03b5 && check(k+1 < maxIterationsK)); In case of several iterators, variables can be referenced by a list of defined time iterators, respecting the order of inclusion. In the above example defining n and k inside n, a variable can be referenced by n=0 , n , n+1 , n+1, k=0 , n+1, n , and n+1, k+1 . variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} , t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} . It is also possible to define a block of inner iterators to define several loops included in a main time loop. iterate n while (t^{n+1} < maxTime && n+1 < maxIter), { k while (k+1 < maxIterK); l while (l+1 < maxIterL); } In the above example defining n, k inside n and l inside n, a variable can be referenced by n=0 , n , n+1 and either n+1, k=0 , n+1, n , n+1, k+1 or n+1, l=0 , n+1, l , n+1, l+1 . A variable named t can be referenced like this: t^{n=0} , t^{n} , t^{n+1} and either t^{n+1, k=0} , t^{n+1, k} , t^{n+1, k+1} or t^{n+1, l=0} , t^{n+1, l} , t^{n+1, l+1} . Note For a time iterator n , if a variable is initialized at n=0 , NabLab automatically initializes n with n=0 value of the variable at the beginning of the time loop and with n+1 value during loop iterations.","title":"Time iterators"},{"location":"nablablanguage/#jobs","text":"Jobs are identified by a name, starting with an upper case. They are composed of an instruction, or a block of instructions. Ini: j = 0; IniTime: t^{n=0} = 0.0; ComputeDensity: \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; The execution of a NabLab program does not start at its beginning and jobs execution order does not correspond to their position in the file. During the compilation phase, the data flow graph of the program is computed according to input and output variables of each job. Jobs are annotated with a at statement corresponding to its hierarchical logical time (HLT). The HLT concept is explicitly expressed to go beyond the classical single-program-multiple-data or bulk-synchronous-parallel programming models. The at logical timestamp explicitly declares the task-based parallelism of jobs. However, this way to schedule jobs imposes to have a dedicated tool to visualize the graph representing the program execution. This feature has been developed and integrated into the NabLab environment (see getting started documentation for details).","title":"Jobs"},{"location":"nablablanguage/#instructions","text":"The main instructions of the language are: local variable and set definitions, affectations, blocks, loops, conditionals. An instruction ends with the ; character except blocks surrounded by curly brackets.","title":"Instructions"},{"location":"nablablanguage/#local-variables-and-set-definitions","text":"Local variables can be defined with the same syntax than global ones but local definitions include neither variables with supports nor user options. Set of items can be defined locally by calling a connectivity, like this: set my_cells = cells();","title":"Local variables and set definitions"},{"location":"nablablanguage/#affectations","text":"An affectation is composed of a variable reference, the = character and an expression. \u03c1_ic = \u03c1IniZg; t^{n=0} = 0.0; N = [0.0, 1.0]; Cjr_ic{j,r} = 0.5 * perp(X^{n=0}{r+1} - X^{n=0}{r-1});","title":"Affectations"},{"location":"nablablanguage/#blocks","text":"A block is a list of instructions. It follows the Composite Design Pattern : The block is an instruction and contains itself a list of instructions. The block is surrounded with curly brackets. { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; }","title":"Blocks"},{"location":"nablablanguage/#loops","text":"NabLab provides two instructions for loops: while and \u2200 . The while is composed of a condition, which is an expression, and an instruction that can be a block. while (t^{n} < 5.0) x = 0; while (residual > \u03b5) { alpha = 1.0 / det(a); I = [ [1.0, 0.0], [0.0, 1.0] ]; } The \u2200 loop provides two kinds of iteration blocks: interval and space iterators. Interval are going from 0 to n-1 with n an integer result of an expression. \u2200i\u2208[0;5[, x = 0; \u2200i\u2208[0;x+4[, { beta = i * a; A = [i, 0]; } Space iterators allows to loop on connectivity sets. // loop on cells \u2200j\u2208cells(), \u03c1{j} = m{j} / V{j}; // loop on topNodes \u2200r\u2208topNodes(), { let \u211d[2] N = [0.0, 1.0]; let \u211d[2,2] NxN = tensProduct(N,N); let \u211d[2,2] IcP = I - NxN; bt{r} = matVectProduct(IcP, b{r}); } // loop on cells with a reduction on nodesOfCell \u2200j\u2208cells(), V{j} = 0.5 * \u2211{r\u2208nodesOfCell(j)}(dot(C{j,r}, X^{n}{r})); // loop on cells and inner loop on nodesOfCell \u2200j\u2208cells(), \u2200r\u2208nodesOfCell(j), Ajr{j,r} = ((\u03c1{j} * c{j}) / l{j,r}) * tensProduct(C{j,r}, C{j,r}); It is possible to define a loop iterator counter viewed as an integer local variable. \u2200j, ij \u2208cells(), \u03c1{j} = V{j} * ij;","title":"Loops"},{"location":"nablablanguage/#conditionals","text":"Conditionals are defined with the classical if , else sequence. The condition in the if instruction is an expression, like for the while instruction. The else clause is optional. if (center[0] < xInterface) { \u03c1_ic = \u03c1IniZg; p_ic = pIniZg; } else { \u03c1_ic = \u03c1IniZd; p_ic = pIniZd; }","title":"Conditionals"},{"location":"nablablanguage/#expressions","text":"Expressions are composed of the following elements: Unary operators minus - and not ! Binary operators add + , substract - , multiply * , divide / and modulo % Comparison operators greater than > , greater than or equal >= , less than < , less than or equal <= , equal == , not equal != Boolean operators and && and or || Contracted if operator (condition) ? true : false Min and max constants for integer and real base types: \u2115.MinValue , \u2115.MaxValue , \u211d.MinValue , \u211d.MaxValue Array initializations by comma separated list of expressions between brackets, for example [1, 2+3, -5] for \u2115[3] , [ [1.1, 1.2], [2.1, 2.2], [3.1, 3.2] ] for \u211d[3,2] Argument/variable references and reduction/function calls detailed below.","title":"Expressions"},{"location":"nablablanguage/#arguments-and-variable-references","text":"Function arguments and variables are referenced by their name that can be followed by: A list of time iterators surrounded by the ^{ } and separated by a comma: t^{n+1} , t^{n+1, k} For variables with a support, a list of space iterators surrounded by the { } and separated by a comma: P{j} , Ajr{j, r} . Iterators are defined by loops and reductions. Iterators can have an increment, like X{r+1} or X{r-1} , to access the item before or after the original iterator in the set where it is defined. For arrays, a list of indices surrounded by [ ] and separated by a comma: X[0] , Y[i, 0] . Indices are expressions.","title":"Arguments and variable references"},{"location":"nablablanguage/#reduction-and-function-calls","text":"A reduction call includes an iteration on a set or interval, like for a space iterator loop, and an expression of the type of the reduction. For example, to compute the sum of a real variable P defined on cells, the call includes the cells set iterator and the variable reference P{j} : let \u211d sum = \u2211{j\u2208cells()}(P{j}); A function call is defined by the name of the function and the right number and type of input arguments as expressions: let \u211d my_cos = cos(3.14 + 3.14);","title":"Reduction and function calls"},{"location":"ngenlanguage/","text":"Ngen language A ngen file, extension ngen , defines an Application or n (or several) ExtensionProvider . An Application reference a module while an ExtensionProvider references an extension . Application The application is identified by a name starting with an upper case. Application Glace2d; Main module identification The first part of the ngen file identifies the main module of the application. It is defined by a reference to a NabLab module and a name. It must provide some additional parameters useful for code interpretation/generation: meshClassName identifies the name of the mesh class and the name of the mesh class factory. For example, if the name is CartesianMesh2D , NabLab waits for a factory names CartesianMesh2DFactory with a CartesianMesh2D create() method. nodeCoord identifies the NabLab variable representing node coordinates. time , timeStep , iterationMax and timeMax identifies respectively the NabLab variables representing the time of the simulation, the timeStep of the simulation, the maximum number of iterations of the main time loop and the maximum time of the simulation. MainModule Glace2d glace2d { meshClassName = \"CartesianMesh2D\"; nodeCoord = X; time = t; timeStep = \u03b4t; iterationMax = maxIterations; timeMax = stopTime; } Note iterationMax and timeMax variables are mandatory for C++ code generation, optional otherwise. Note Code completion is available with CTRL-space for all NabLab module and variable references. VTK output NabLab provides a PVD file format serializer, a VTK compatible file format. The next block of the ngen file aims at configuring this serializer. It is an optional block. The periodReferenceVariable defines the module variable used as a reference for the frequency of the outputs. Most of the time, it is the iteration number (often named n ) or the time of the simulation (often named t ). VtkOutput { periodReferenceVariable = glace2d.n; outputVariables = glace2d.\u03c1 as \"Density\"; } When the VtkOutput block exists in the ngen file, two options must appear in the Json data file: outputPath and outputPeriod representing respectively the VTK output directory and the frequency period of the output. For example, for an outputPeriod of 1 and a periodReferenceVariable of n , VTK files will be written at each iteration of the simulation. Here is the VTK part of the default generated Json file (in src-gen directory): \"_outputPath_comment\":\"empty outputPath to disable output\", \"outputPath\":\"output\", \"outputPeriod\":1, Dump variables NabLab provides a mechanism to dump variable values. It uses the LevelDB library for Java and C++ . The Java LevelDB library is included in the NabLab environment. To use the C++ one, you have to download and install it on your computer. To trigger the dump of all variables (except linear algebra ones) of your code, add a LevelDB block. In addition to that, in case of C++ generation, provide the path to the LevelDB installation. LevelDB { levelDBPath = \"$ENV{HOME}/leveldb/leveldb-install\"; } Note The levelDBPath value supports CMake syntax like $ENV{HOME} in the example above. When the LevelDB block exists in the ngen file, the nonRegression option must appear in the Json data file. If its value is CreateReference , variables are dumped in a directory named ApplicationNameDB.ref . If its value is CompareToReference , variables are dumped in a directory named Application NameDB.current and are compared to variables stored in ApplicationNameDB.ref . \"_nonRegression_comment\":\"empty value to disable, CreateReference or CompareToReference to take action\", \"nonRegression\":\"\" Configuring interpretation Interpreter needs to be configured only if you use an extension with no Java provider. See the extension section for details. Configuring generation To configure generation, create as many generation blocks as desired generation targets. Possible targets are: Java for a multi-threaded Java code, Kokkos for a Kokkos multi-threaded C++ code based on Open MP, KokkosTeamThread for a Kokkos hierarchical multi-threaded C++ code with team of threads, OpenMP for an Open MP multi-threaded C++ code, CppSequential for a sequential C++ code, StlThread for a multi-threaded C++ code based on an STL threads API provided by the NabLab library. Here is an example of a generation block: Kokkos { outputPath = \"/NabLabExamples/src-gen-cpp/kokkos\"; N_CXX_COMPILER = \"/usr/bin/g++\"; N_KOKKOS_PATH = \"$ENV{HOME}/kokkos/kokkos-install\"; } All targets have to define the outputPath of the generation and a set of variables which will be reported in the CMakeLists.txt file. For C++ targets, the N_CXX_COMPILER variable is mandatory. For Kokkos , KokkosTeamThread , the Kokkos library has to be installed and the path to the library has to be provided is the N_KOKKOS_PATH variable. Note Variables can use CMake syntax in their value like $ENV{HOME} for path in the example above. Provider A NabLab module can import some extensions. Those extensions contain some functions. Some of them can be external functions i.e. functions with just a signature definition and no body. In this case, these external functions are defined in a native language, for example C++. To connect definitions to signatures, providers have to be defined: some glue code must be written, providers have to be declared in a ngen file. Note NabLab offers a code generator to initialize the glue code and the ngen file for extension providers. See My first extension for that. Most of the time, all providers of an extension are declared in the same ngen file. For example, for linearalgebra extension part of the NabLab library, defined in the linearalgebra.n file, a linearalgebra.ngen file contains the providers. Provider LinearAlgebraStl : LinearAlgebra { target = StlThread; compatibleTargets = CppSequential, OpenMP; outputPath = \"/.nablab/linearalgebra\"; } Provider LinearAlgebraKokkos : LinearAlgebra { target = Kokkos; compatibleTargets = KokkosTeamThread; outputPath = \"/.nablab/linearalgebra\"; } Provider LinearAlgebraJava : LinearAlgebra { target = Java; outputPath = \"/.nablab/linearalgebra\"; } A provider is defined by its name and the extension it implements (after the : character). The provider block is composed of: target defining which generation target the provider implements. compatibleTargets , an optional field, representing a list of generation targets compatible with the target previously defined. In the above LinearAlgebraKokkos example, the target indicates that the provider's source code is designed for a multi-threaded C++ Kokkos source code. The compatibleTargets indicates that a caller generated with a KokkosTeamThread target can use this provider. outputPath containing the directory of the providers's source code.","title":"Ngen language reference"},{"location":"ngenlanguage/#ngen-language","text":"A ngen file, extension ngen , defines an Application or n (or several) ExtensionProvider . An Application reference a module while an ExtensionProvider references an extension .","title":"Ngen language"},{"location":"ngenlanguage/#application","text":"The application is identified by a name starting with an upper case. Application Glace2d;","title":"Application"},{"location":"ngenlanguage/#main-module-identification","text":"The first part of the ngen file identifies the main module of the application. It is defined by a reference to a NabLab module and a name. It must provide some additional parameters useful for code interpretation/generation: meshClassName identifies the name of the mesh class and the name of the mesh class factory. For example, if the name is CartesianMesh2D , NabLab waits for a factory names CartesianMesh2DFactory with a CartesianMesh2D create() method. nodeCoord identifies the NabLab variable representing node coordinates. time , timeStep , iterationMax and timeMax identifies respectively the NabLab variables representing the time of the simulation, the timeStep of the simulation, the maximum number of iterations of the main time loop and the maximum time of the simulation. MainModule Glace2d glace2d { meshClassName = \"CartesianMesh2D\"; nodeCoord = X; time = t; timeStep = \u03b4t; iterationMax = maxIterations; timeMax = stopTime; } Note iterationMax and timeMax variables are mandatory for C++ code generation, optional otherwise. Note Code completion is available with CTRL-space for all NabLab module and variable references.","title":"Main module identification"},{"location":"ngenlanguage/#vtk-output","text":"NabLab provides a PVD file format serializer, a VTK compatible file format. The next block of the ngen file aims at configuring this serializer. It is an optional block. The periodReferenceVariable defines the module variable used as a reference for the frequency of the outputs. Most of the time, it is the iteration number (often named n ) or the time of the simulation (often named t ). VtkOutput { periodReferenceVariable = glace2d.n; outputVariables = glace2d.\u03c1 as \"Density\"; } When the VtkOutput block exists in the ngen file, two options must appear in the Json data file: outputPath and outputPeriod representing respectively the VTK output directory and the frequency period of the output. For example, for an outputPeriod of 1 and a periodReferenceVariable of n , VTK files will be written at each iteration of the simulation. Here is the VTK part of the default generated Json file (in src-gen directory): \"_outputPath_comment\":\"empty outputPath to disable output\", \"outputPath\":\"output\", \"outputPeriod\":1,","title":"VTK output"},{"location":"ngenlanguage/#dump-variables","text":"NabLab provides a mechanism to dump variable values. It uses the LevelDB library for Java and C++ . The Java LevelDB library is included in the NabLab environment. To use the C++ one, you have to download and install it on your computer. To trigger the dump of all variables (except linear algebra ones) of your code, add a LevelDB block. In addition to that, in case of C++ generation, provide the path to the LevelDB installation. LevelDB { levelDBPath = \"$ENV{HOME}/leveldb/leveldb-install\"; } Note The levelDBPath value supports CMake syntax like $ENV{HOME} in the example above. When the LevelDB block exists in the ngen file, the nonRegression option must appear in the Json data file. If its value is CreateReference , variables are dumped in a directory named ApplicationNameDB.ref . If its value is CompareToReference , variables are dumped in a directory named Application NameDB.current and are compared to variables stored in ApplicationNameDB.ref . \"_nonRegression_comment\":\"empty value to disable, CreateReference or CompareToReference to take action\", \"nonRegression\":\"\"","title":"Dump variables"},{"location":"ngenlanguage/#configuring-interpretation","text":"Interpreter needs to be configured only if you use an extension with no Java provider. See the extension section for details.","title":"Configuring interpretation"},{"location":"ngenlanguage/#configuring-generation","text":"To configure generation, create as many generation blocks as desired generation targets. Possible targets are: Java for a multi-threaded Java code, Kokkos for a Kokkos multi-threaded C++ code based on Open MP, KokkosTeamThread for a Kokkos hierarchical multi-threaded C++ code with team of threads, OpenMP for an Open MP multi-threaded C++ code, CppSequential for a sequential C++ code, StlThread for a multi-threaded C++ code based on an STL threads API provided by the NabLab library. Here is an example of a generation block: Kokkos { outputPath = \"/NabLabExamples/src-gen-cpp/kokkos\"; N_CXX_COMPILER = \"/usr/bin/g++\"; N_KOKKOS_PATH = \"$ENV{HOME}/kokkos/kokkos-install\"; } All targets have to define the outputPath of the generation and a set of variables which will be reported in the CMakeLists.txt file. For C++ targets, the N_CXX_COMPILER variable is mandatory. For Kokkos , KokkosTeamThread , the Kokkos library has to be installed and the path to the library has to be provided is the N_KOKKOS_PATH variable. Note Variables can use CMake syntax in their value like $ENV{HOME} for path in the example above.","title":"Configuring generation"},{"location":"ngenlanguage/#provider","text":"A NabLab module can import some extensions. Those extensions contain some functions. Some of them can be external functions i.e. functions with just a signature definition and no body. In this case, these external functions are defined in a native language, for example C++. To connect definitions to signatures, providers have to be defined: some glue code must be written, providers have to be declared in a ngen file. Note NabLab offers a code generator to initialize the glue code and the ngen file for extension providers. See My first extension for that. Most of the time, all providers of an extension are declared in the same ngen file. For example, for linearalgebra extension part of the NabLab library, defined in the linearalgebra.n file, a linearalgebra.ngen file contains the providers. Provider LinearAlgebraStl : LinearAlgebra { target = StlThread; compatibleTargets = CppSequential, OpenMP; outputPath = \"/.nablab/linearalgebra\"; } Provider LinearAlgebraKokkos : LinearAlgebra { target = Kokkos; compatibleTargets = KokkosTeamThread; outputPath = \"/.nablab/linearalgebra\"; } Provider LinearAlgebraJava : LinearAlgebra { target = Java; outputPath = \"/.nablab/linearalgebra\"; } A provider is defined by its name and the extension it implements (after the : character). The provider block is composed of: target defining which generation target the provider implements. compatibleTargets , an optional field, representing a list of generation targets compatible with the target previously defined. In the above LinearAlgebraKokkos example, the target indicates that the provider's source code is designed for a multi-threaded C++ Kokkos source code. The compatibleTargets indicates that a caller generated with a KokkosTeamThread target can use this provider. outputPath containing the directory of the providers's source code.","title":"Provider"}]}