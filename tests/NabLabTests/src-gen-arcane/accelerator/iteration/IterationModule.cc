/* DO NOT EDIT THIS FILE - it is machine generated */

#include "IterationModule.h"
#include <arcane/Concurrency.h>
#include <arcane/ITimeLoopMng.h>

using namespace Arcane;

/*** Free functions **********************************************************/

namespace iterationfreefuncs
{
	bool assertEquals(Real expected, Real actual)
	{
		const bool ret((expected == actual));
		if (!ret) 
			ARCANE_FATAL("** Assertion failed");
		return ret;
	}
}

/*** Module/Service **********************************************************/

IterationModule::IterationModule(const ModuleBuildInfo& bi)
: ArcaneIterationObject(bi)
, m_default_queue(subDomain()->acceleratorMng()->defaultQueue())
{}

void IterationModule::init()
{
	// initialization of mesh attributes
	m_mesh = CartesianMesh2D::createInstance(mesh());

	// initialization of other attributes
	m_n = 0;
	m_k = 0;
	m_l = 0;

	// constant time step
	m_global_deltat = m_delta_t;

	// calling jobs
	iniTime(); // @1.0
	iniVk(); // @1.0
	iniVn(); // @1.0
	setUpTimeLoopN(); // @2.0
}

/**
 * Job computeTn called @1.0 in executeTimeLoopN method.
 * In variables: delta_t, t_n
 * Out variables: t_nplus1
 */
void IterationModule::computeTn()
{
	m_t_nplus1 = m_t_n + m_delta_t;
}

/**
 * Job iniTime called @1.0 in simulate method.
 * In variables: 
 * Out variables: t_n0
 */
void IterationModule::iniTime()
{
	m_t_n0 = 0.0;
}

/**
 * Job iniVk called @1.0 in simulate method.
 * In variables: 
 * Out variables: vk_nplus1_k0
 */
void IterationModule::iniVk()
{
	auto command = makeCommand(m_default_queue);
	auto out_vk_nplus1_k0 = ax::viewOut(command, m_vk_nplus1_k0);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_vk_nplus1_k0[jCells] = 0.0;
	};
}

/**
 * Job iniVn called @1.0 in simulate method.
 * In variables: 
 * Out variables: vn_n0
 */
void IterationModule::iniVn()
{
	auto command = makeCommand(m_default_queue);
	auto out_vn_n0 = ax::viewOut(command, m_vn_n0);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_vn_n0[jCells] = 0.0;
	};
}

/**
 * Job setUpTimeLoopK called @1.0 in executeTimeLoopN method.
 * In variables: vk_nplus1_k0
 * Out variables: vk_nplus1_k
 */
void IterationModule::setUpTimeLoopK()
{
	auto command = makeCommand(m_default_queue);
	auto in_vk_nplus1_k0 = ax::viewIn(command, m_vk_nplus1_k0);
	auto out_vk_nplus1_k = ax::viewOut(command, m_vk_nplus1_k);
	command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
	{
		out_vk_nplus1_k[i1Cells] = in_vk_nplus1_k0[i1Cells];
	};
}

/**
 * Job updateVk called @1.0 in executeTimeLoopK method.
 * In variables: vk_nplus1_k
 * Out variables: vk_nplus1_kplus1
 */
void IterationModule::updateVk()
{
	auto command = makeCommand(m_default_queue);
	auto in_vk_nplus1_k = ax::viewIn(command, m_vk_nplus1_k);
	auto out_vk_nplus1_kplus1 = ax::viewOut(command, m_vk_nplus1_kplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_vk_nplus1_kplus1[jCells] = in_vk_nplus1_k[jCells] + 2;
	};
}

/**
 * Job updateVl called @1.0 in executeTimeLoopL method.
 * In variables: vl_nplus1_l
 * Out variables: vl_nplus1_lplus1
 */
void IterationModule::updateVl()
{
	auto command = makeCommand(m_default_queue);
	auto in_vl_nplus1_l = ax::viewIn(command, m_vl_nplus1_l);
	auto out_vl_nplus1_lplus1 = ax::viewOut(command, m_vl_nplus1_lplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_vl_nplus1_lplus1[jCells] = in_vl_nplus1_l[jCells] + 1;
	};
}

/**
 * Job executeTimeLoopK called @2.0 in executeTimeLoopN method.
 * In variables: k, maxIterK, vk_nplus1_k
 * Out variables: vk_nplus1_kplus1
 */
void IterationModule::executeTimeLoopK()
{
	m_k = 0;
	bool continueLoop = true;
	do
	{
		m_k++;
		info() << "Start iteration k: " << std::setprecision(5) << m_k;
		updateVk(); // @1.0
	
		// Evaluate loop condition with variables at time n
		continueLoop = (m_k < m_maxIterK);
	
		auto command = makeCommand(m_default_queue);
		auto in_vk_nplus1_kplus1 = ax::viewIn(command, m_vk_nplus1_kplus1);
		auto out_vk_nplus1_k = ax::viewOut(command, m_vk_nplus1_k);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			out_vk_nplus1_k[i1Cells] = in_vk_nplus1_kplus1[i1Cells];
		};
	} while (continueLoop);
}

/**
 * Job setUpTimeLoopN called @2.0 in simulate method.
 * In variables: t_n0, vn_n0
 * Out variables: t_n, vn_n
 */
void IterationModule::setUpTimeLoopN()
{
	m_t_n = m_t_n0;
	{
		auto command = makeCommand(m_default_queue);
		auto in_vn_n0 = ax::viewIn(command, m_vn_n0);
		auto out_vn_n = ax::viewOut(command, m_vn_n);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			out_vn_n[i1Cells] = in_vn_n0[i1Cells];
		};
	}
}

/**
 * Job executeTimeLoopN called @3.0 in simulate method.
 * In variables: maxIterN, n, t_n, vk_n, vl_n, vn_n
 * Out variables: t_nplus1, vk_nplus1, vl_nplus1, vn_nplus1
 */
void IterationModule::executeTimeLoopN()
{
	m_n++;
	computeTn(); // @1.0
	setUpTimeLoopK(); // @1.0
	executeTimeLoopK(); // @2.0
	tearDownTimeLoopK(); // @3.0
	iniVl(); // @4.0
	oracleVk(); // @4.0
	setUpTimeLoopL(); // @5.0
	executeTimeLoopL(); // @6.0
	tearDownTimeLoopL(); // @7.0
	oracleVl(); // @8.0
	updateVn(); // @8.0
	oracleVn(); // @9.0
	
	// Evaluate loop condition with variables at time n
	bool continueLoop = (m_n < m_maxIterN);
	
	m_t_n = m_t_nplus1;
	{
		auto command = makeCommand(m_default_queue);
		auto in_vn_nplus1 = ax::viewIn(command, m_vn_nplus1);
		auto out_vn_n = ax::viewOut(command, m_vn_n);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			out_vn_n[i1Cells] = in_vn_nplus1[i1Cells];
		};
	}
	{
		auto command = makeCommand(m_default_queue);
		auto in_vk_nplus1 = ax::viewIn(command, m_vk_nplus1);
		auto out_vk_n = ax::viewOut(command, m_vk_n);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			out_vk_n[i1Cells] = in_vk_nplus1[i1Cells];
		};
	}
	{
		auto command = makeCommand(m_default_queue);
		auto in_vl_nplus1 = ax::viewIn(command, m_vl_nplus1);
		auto out_vl_n = ax::viewOut(command, m_vl_n);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			out_vl_n[i1Cells] = in_vl_nplus1[i1Cells];
		};
	}
	
	if (!continueLoop)
		subDomain()->timeLoopMng()->stopComputeLoop(true);
}

/**
 * Job tearDownTimeLoopK called @3.0 in executeTimeLoopN method.
 * In variables: vk_nplus1_kplus1
 * Out variables: vk_nplus1
 */
void IterationModule::tearDownTimeLoopK()
{
	auto command = makeCommand(m_default_queue);
	auto in_vk_nplus1_kplus1 = ax::viewIn(command, m_vk_nplus1_kplus1);
	auto out_vk_nplus1 = ax::viewOut(command, m_vk_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
	{
		out_vk_nplus1[i1Cells] = in_vk_nplus1_kplus1[i1Cells];
	};
}

/**
 * Job iniVl called @4.0 in executeTimeLoopN method.
 * In variables: vk_nplus1
 * Out variables: vl_nplus1_l0
 */
void IterationModule::iniVl()
{
	auto command = makeCommand(m_default_queue);
	auto in_vk_nplus1 = ax::viewIn(command, m_vk_nplus1);
	auto out_vl_nplus1_l0 = ax::viewOut(command, m_vl_nplus1_l0);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_vl_nplus1_l0[jCells] = in_vk_nplus1[jCells] + 8;
	};
}

/**
 * Job oracleVk called @4.0 in executeTimeLoopN method.
 * In variables: vk_nplus1
 * Out variables: 
 */
void IterationModule::oracleVk()
{
	auto command = makeCommand(m_default_queue);
	auto in_vk_nplus1 = ax::viewIn(command, m_vk_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const bool testVk(iterationfreefuncs::assertEquals(12.0, in_vk_nplus1[jCells]));
	};
}

/**
 * Job setUpTimeLoopL called @5.0 in executeTimeLoopN method.
 * In variables: vl_nplus1_l0
 * Out variables: vl_nplus1_l
 */
void IterationModule::setUpTimeLoopL()
{
	auto command = makeCommand(m_default_queue);
	auto in_vl_nplus1_l0 = ax::viewIn(command, m_vl_nplus1_l0);
	auto out_vl_nplus1_l = ax::viewOut(command, m_vl_nplus1_l);
	command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
	{
		out_vl_nplus1_l[i1Cells] = in_vl_nplus1_l0[i1Cells];
	};
}

/**
 * Job executeTimeLoopL called @6.0 in executeTimeLoopN method.
 * In variables: l, maxIterL, vl_nplus1_l
 * Out variables: vl_nplus1_lplus1
 */
void IterationModule::executeTimeLoopL()
{
	m_l = 0;
	bool continueLoop = true;
	do
	{
		m_l++;
		info() << "Start iteration l: " << std::setprecision(5) << m_l;
		updateVl(); // @1.0
	
		// Evaluate loop condition with variables at time n
		continueLoop = (m_l < m_maxIterL);
	
		auto command = makeCommand(m_default_queue);
		auto in_vl_nplus1_lplus1 = ax::viewIn(command, m_vl_nplus1_lplus1);
		auto out_vl_nplus1_l = ax::viewOut(command, m_vl_nplus1_l);
		command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
		{
			out_vl_nplus1_l[i1Cells] = in_vl_nplus1_lplus1[i1Cells];
		};
	} while (continueLoop);
}

/**
 * Job tearDownTimeLoopL called @7.0 in executeTimeLoopN method.
 * In variables: vl_nplus1_lplus1
 * Out variables: vl_nplus1
 */
void IterationModule::tearDownTimeLoopL()
{
	auto command = makeCommand(m_default_queue);
	auto in_vl_nplus1_lplus1 = ax::viewIn(command, m_vl_nplus1_lplus1);
	auto out_vl_nplus1 = ax::viewOut(command, m_vl_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, i1Cells, allCells())
	{
		out_vl_nplus1[i1Cells] = in_vl_nplus1_lplus1[i1Cells];
	};
}

/**
 * Job oracleVl called @8.0 in executeTimeLoopN method.
 * In variables: vl_nplus1
 * Out variables: 
 */
void IterationModule::oracleVl()
{
	auto command = makeCommand(m_default_queue);
	auto in_vl_nplus1 = ax::viewIn(command, m_vl_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const bool testVl(iterationfreefuncs::assertEquals(27.0, in_vl_nplus1[jCells]));
	};
}

/**
 * Job updateVn called @8.0 in executeTimeLoopN method.
 * In variables: vl_nplus1, vn_n
 * Out variables: vn_nplus1
 */
void IterationModule::updateVn()
{
	auto command = makeCommand(m_default_queue);
	auto in_vn_n = ax::viewIn(command, m_vn_n);
	auto in_vl_nplus1 = ax::viewIn(command, m_vl_nplus1);
	auto out_vn_nplus1 = ax::viewOut(command, m_vn_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		out_vn_nplus1[jCells] = in_vn_n[jCells] + in_vl_nplus1[jCells] * 2;
	};
}

/**
 * Job oracleVn called @9.0 in executeTimeLoopN method.
 * In variables: n, vn_nplus1
 * Out variables: 
 */
void IterationModule::oracleVn()
{
	auto command = makeCommand(m_default_queue);
	auto in_n = m_n;
	auto in_vn_nplus1 = ax::viewIn(command, m_vn_nplus1);
	command << RUNCOMMAND_ENUMERATE(Cell, jCells, allCells())
	{
		const bool testVn(iterationfreefuncs::assertEquals(54.0 * in_n, in_vn_nplus1[jCells]));
	};
}

ARCANE_REGISTER_MODULE_ITERATION(IterationModule);
