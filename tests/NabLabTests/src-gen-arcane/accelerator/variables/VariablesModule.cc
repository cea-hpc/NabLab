/* DO NOT EDIT THIS FILE - it is machine generated */

#include "VariablesModule.h"
#include <arcane/Concurrency.h>
#include <arcane/ITimeLoopMng.h>

using namespace Arcane;

/*** Free functions **********************************************************/

namespace variablesfreefuncs
{
	bool assertEquals(Int32 expected, Int32 actual)
	{
		const bool ret((expected == actual));
		if (!ret) 
			ARCANE_FATAL("** Assertion failed");
		return ret;
	}
	
	bool assertEquals(RealArrayVariant expected, RealArrayVariant actual)
	{
		for (Int32 i=0; i<expected.size(); i++)
		{
			if (expected(i) != actual(i)) 
				ARCANE_FATAL("** Assertion failed");
		}
		return true;
	}
	
	bool assertEquals(Real expected, Real actual)
	{
		const bool ret((expected == actual));
		if (!ret) 
			ARCANE_FATAL("** Assertion failed");
		return ret;
	}
	
	RealArrayVariant operatorAdd(RealArrayVariant a, RealArrayVariant b)
	{
		NumArray<Real,MDDim1> result(a.size());
		for (Int32 ix0=0; ix0<a.size(); ix0++)
		{
			result(ix0) = a(ix0) + b(ix0);
		}
		return result;
	}
}

/*** Module/Service **********************************************************/

VariablesModule::VariablesModule(const ModuleBuildInfo& bi)
: ArcaneVariablesObject(bi)
, m_default_queue(subDomain()->acceleratorMng()->defaultQueue())
{}

void VariablesModule::init()
{
	// initialization of mesh attributes
	m_mesh = CartesianMesh2D::createInstance(mesh());

	// initialization of other attributes
	m_optVect3 = variablesfreefuncs::operatorAdd(options()->optVect1(), options()->optVect2());
	m_varVec = Real2{1.0, 1.0};
	m_dynamicVec.resize(options()->optDim());

	// constant time step
	m_global_deltat = m_delta_t;

	// calling jobs
	dynamicVecInitialization(); // @1.0
	varVecInitialization(); // @1.0
	oracle(); // @2.0

	// No compute loop entry point: end of computation triggered to avoid infinite loop in tests
	subDomain()->timeLoopMng()->stopComputeLoop(true);
}

/**
 * Job dynamicVecInitialization called @1.0 in simulate method.
 * In variables: optDim
 * Out variables: checkDynamicDim, dynamicVec
 */
void VariablesModule::dynamicVecInitialization()
{
	const Int32 tmp_optDim(options()->optDim());
	{
		Int32 cpt(0);
		{
			auto command = makeCommand(m_default_queue);
			auto out_dynamicVec = ax::viewOut(command, m_dynamicVec);
			command << RUNCOMMAND_LOOP1(i, tmp_optDim)
			{
				out_dynamicVec(i) = 3.3;
			};
		}
		for (Int32 i=0; i<tmp_optDim; i++)
		{
			cpt = cpt + 1;
		}
		m_checkDynamicDim = cpt;
	}
}

/**
 * Job varVecInitialization called @1.0 in simulate method.
 * In variables: constexprDim
 * Out variables: varVec
 */
void VariablesModule::varVecInitialization()
{
	m_varVec = Real2{2.2, 2.2};
}

/**
 * Job oracle called @2.0 in simulate method.
 * In variables: checkDynamicDim, constexprDim, constexprVec, dynamicVec, optDim, optVect1, optVect2, optVect3, varVec
 * Out variables: 
 */
void VariablesModule::oracle()
{
	const Int32 tmp_optDim(options()->optDim());
	{
		const bool testOptDim(variablesfreefuncs::assertEquals(2, options()->optDim()));
		const bool testOptVect1(variablesfreefuncs::assertEquals(Real2{1.0, 1.0}, options()->optVect1()));
		const bool testOptVect2(variablesfreefuncs::assertEquals(Real2{2.0, 2.0}, options()->optVect2()));
		const bool testOptVect3(variablesfreefuncs::assertEquals(Real2{3.0, 3.0}, m_optVect3));
		const bool testConstexprDim(variablesfreefuncs::assertEquals(2, m_constexprDim));
		const bool testConstexprVec(variablesfreefuncs::assertEquals(Real2{1.1, 1.1}, m_constexprVec));
		const bool testVarVec(variablesfreefuncs::assertEquals(Real2{2.2, 2.2}, m_varVec));
		const bool testDynamicVecLength(variablesfreefuncs::assertEquals(2, m_checkDynamicDim));
		{
			auto command = makeCommand(m_default_queue);
			auto in_dynamicVec = ax::viewIn(command, m_dynamicVec);
			command << RUNCOMMAND_LOOP1(i, tmp_optDim)
			{
				const bool testDynamicVec(variablesfreefuncs::assertEquals(3.3, in_dynamicVec(i)));
			};
		}
	}
}

ARCANE_REGISTER_MODULE_VARIABLES(VariablesModule);
