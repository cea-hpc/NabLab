# 1 "nabla_glcNxtStp3_sed_iG2Kb7"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "nabla_glcNxtStp3_sed_iG2Kb7"
# 1 "glcNxtStp3.n"
with â„Â²; // On est en 2D!!!

// Il nous faut ca
â„Â³ perp(â„Â³ Î±, â„Â³ Î²){ return â„Â³(Î².y-Î±.y,-Î².x+Î±.x,0.0);}
â„ trace(â„Â³Ë£Â³ M){return M.x.x+M.y.y+M.z.z;}

// Et ca


//#define id3 matrix3x3Id();

options {
  // Options obligatoires pour compiler
  â„ LENGTH = 1.0;
  â„• X_EDGE_ELEMS = 8;
  â„• Y_EDGE_ELEMS = 8;
  â„• Z_EDGE_ELEMS = 1;
  â„ option_stoptime = 0.1;
  â„• option_max_iterations = 48;

  // Autres options
 â„ Î³ = 1.4;
 â„ option_p_ini_zg = 1.0;
 â„ option_Ï_ini_zg = 1.0;
 â„ option_p_ini_zd = 0.1;
 â„ option_Ï_ini_zd = 0.125;

 â„ option_x_interface = 0.5;
  â„ option_Î´t_ini = 1.0E-5;
  â„ option_Î´t_max = 0.01;
 â„ option_Î´t_cfl = 0.1;
  â„ option_Î´t_min_variation = 0.9;
  â„ option_Î´t_max_variation = 0.1;

};

global {
 â„ t, t_n_plus_1;
  //â„ Î´t; // Î´t est pour l'instant declare par le backend, *pas beau*
  â„ Î´t_n_plus_1;
  â„ Min6f4a6c1c;
};

nodes {
 â„Â³ X, X_n_plus_1, X_ic, b, bt, fu;
 â„Â³Ë£Â³ M, Mt;
};

cells {
 â„ p_ic, Ï_ic, V_ic, c, m, p, Ï, e, E, E_n_plus_1, V, Î´tj, absC[nodes];
 â„Â³ u, u_n_plus_1, center, C_ic[nodes], C[nodes], F[nodes];
 â„Â³Ë£Â³ A[nodes];
};

// Ne pas oublier de recuperer les coordonnes
âˆ€ nodes @ -40 { X_ic = coord; }

Init_t @ -3.0 { t = 0.0;}

Init_Î´t @ -3.0 { Î´t = 0.0;}

âˆ€ cells IniCenter @ -3.0 {
 â„Â³ Sum957dad8 = 0;
 âˆ€ nodes {
  Sum957dad8 += X_ic;
 }
 center = (1.0 / 4.0) * Sum957dad8;
}

âˆ€ cells ComputeCjrIc @ -3.0 {
 âˆ€ nodes {
  C_ic = 0.5 * perp(X_ic[#-1], X_ic[#+1]);
 }
}

âˆ€ nodes Init_ComputeXn @ -3.0 {
 X = X_ic;
}

âˆ€ cells Init_ComputeUn @ -3.0 {
 u = â„Â³(0.0, 0.0, 0.0);
}

Init_Min6f4a6c1c @ -3.0 { Min6f4a6c1c = âˆ;}

Init_ComputeDt @ -3.0 {
 Î´t = option_Î´t_ini;
}

Init_ComputeTn @ -3.0 { t = 0.0; }

âˆ€ cells IniIc @ -2.0 {
 if (center.x < option_x_interface) {
  Ï_ic = option_Ï_ini_zg;
  p_ic = option_p_ini_zg;
 }
 else {
  Ï_ic = option_Ï_ini_zd;
  p_ic = option_p_ini_zd;
 }
}

âˆ€ cells IniVIc @ -2.0 {
 â„ Sum49fbd39 = 0;
 âˆ€ nodes {
  Sum49fbd39 += dot(C_ic, X_ic);
 }
 V_ic = 0.5 * Sum49fbd39;
}

âˆ€ cells IniM @ -1.0 {
 m = Ï_ic * V_ic;
}

âˆ€ cells Init_ComputeEn @ -1.0 {
  assert(Î³!=0.0);
 E = p_ic / ((Î³ - 1.0) * Ï_ic);
}

// ****************************************************************************
// * Partie boucle de calcul ]+0.0,+âˆ[ 
// ****************************************************************************
computeLoop @ 0.0 { printf("\n[37m[#%d] %f[0m",iteration, time);}

âˆ€ cells ComputeCjr @ 1.0 {
 âˆ€ nodes {
  C = 0.5 * perp(X[#-1], X[#+1]);
 }
}

âˆ€ cells ComputeInternalEngergy @ 1.0 {
 e = E - 0.5 * dot(u, u);
}

âˆ€ cells ComputeAbsjr @ 2.0 {
 âˆ€ nodes {
  absC = norm(C);
 }
}

âˆ€ cells ComputeV @ 2.0 {
 â„ Sum4da90722 = 0;
 âˆ€ nodes {
  Sum4da90722 += dot(C, X);
 }
 V = 0.5 * Sum4da90722;
}

âˆ€ cells ComputeDensity @ 3.0 {
 Ï = m / V;
}

âˆ€ cells ComputeEOSp @ 4.0 {
 p = (Î³ - 1.0) * Ï * e;
}

âˆ€ cells ComputeEOSc @ 5.0 {
 c = sqrt(Î³ * p / Ï);
}

âˆ€ cells ComputeÎ´tj @ 6.0 {
 â„ Sum369f5f84 = 0;
 âˆ€ nodes {
  Sum369f5f84 += absC;
 }
 Î´tj = 2.0 * V / (c * Sum369f5f84);
}

âˆ€ cells ComputeAjr @ 6.0 {
  âˆ€ nodes A = ((Ï * c) / absC) * opProdTens(C, C);
}

âˆ€ nodes ComputeMr @ 7.0 {
  // C'est lui qui te foutait la zone!
 â„Â³Ë£Â³ Sum17c4ec2b = â„Â³(0.0,0.0,1.0); // Vachtre on est en 2D!
 âˆ€ cells {
  Sum17c4ec2b += A;
 }
 M = Sum17c4ec2b;
}

âˆ€ nodes ComputeBr @ 7.0 {
 â„Â³ Sum3f9840de = 0;
 âˆ€ cells {
  Sum3f9840de += C * p + opProdTensVec(A, u);
 }
 b = Sum3f9840de;
}

âˆ€ cells Min6f4a6c1c <?= Î´tj @ 7.0;

âˆ€ inner nodes ComputeMt @ 8.0 {
 Mt = M;
}

âˆ€ inner nodes ComputeBt @ 8.0 {
 bt = b;
}

âˆ€ outer faces YOuterFacesComputations @ 8.0{
  â„ Y_MIN = 0.0;
  â„ Y_MAX = LENGTH;
  â„Â³Ë£Â³ I = matrix3x3Id();
  â„Â³ nY={0.0,1.0,0.0};
 âˆ€ nodes {
    if ((X.y==Y_MIN)||(X.y==Y_MAX)){
      â„ sign = (X.y==Y_MIN)?-1.0:1.0;
      â„Â³ n = sign*nY;
      â„Â³Ë£Â³ nxn = opProdTens(n,n);
      â„Â³Ë£Â³ IcP = I - nxn;
   bt = opProdTensVec(IcP, b);
   Mt = IcP * (M * IcP) + nxn*trace(Mt);
  }
 }
}
âˆ€ outer faces XOuterFacesComputations @ 8.0 {
  â„ X_MIN = 0.0;
  â„ X_MAX = LENGTH;
  â„Â³Ë£Â³ I = matrix3x3Id();
 âˆ€ nodes {
    if (!((fabs(X.x-X_MIN)<1.e-10) ||
          ((fabs(X.x-X_MAX)<1.e-10)))) continue;
    Mt = I;
    bt = â„Â³(0.0, 0.0, 0.0);
  }
}

Compute_ComputeDt @ 8.0 {
 Î´t_n_plus_1 = option_Î´t_cfl * Min6f4a6c1c;
}

CopyÎ´t_n_plus_1 @ 9.0 {
 Î´t = Î´t_n_plus_1;
}

âˆ€ nodes ComputeU @ 9.0 {
  â„ det = matrixDeterminant(Mt);
  assert(det!=0.0);
 fu = opProdTensVec(inverseMatrix(Mt,det), bt);
}

Compute_ComputeTn @ 9.0 { t_n_plus_1 = t + Î´t_n_plus_1; }

Copyt_n_plus_1 @ 10.0 { t = t_n_plus_1; }

âˆ€ cells ComputeFjr @ 10.0 {
 âˆ€ nodes {
  F = p * C + opProdTensVec(A, (u - fu));
 }
}

âˆ€ nodes Compute_ComputeXn @ 10.0 {
 X_n_plus_1 = X + Î´t * fu;
}

âˆ€ nodes CopyX_n_plus_1 @ 11.0 {
 X = X_n_plus_1;
}

âˆ€ cells Compute_ComputeUn @ 11.0 {
 â„Â³ Sum20e1e014 = 0;
 âˆ€ nodes {
  Sum20e1e014 += F;
 }
 u_n_plus_1 = u - (Î´t / m )* Sum20e1e014;
}

âˆ€ cells Compute_ComputeEn @ 11.0 {
 â„ Sum3fd117d8 = 0;
 âˆ€ nodes {
  Sum3fd117d8 += dot(F, fu);
 }
 E_n_plus_1 = E -(Î´t / m )* Sum3fd117d8;
}

âˆ€ cells CopyE_n_plus_1 @ 12.0 {
 E = E_n_plus_1;
}

âˆ€ cells Copyu_n_plus_1 @ 12.0 {
 u = u_n_plus_1;
}
